 WS2000ÿ1.00ÿÿÿÿ PSTIMES2.PDFÿÿÿ      0 !Releaseÿ3.00ÿÿÿ !,   18162       13,+1993  1 28+*1989  2  3*-ÿ -.ÿ ./ÿ /0ÿ ÿ ÿ ÿ ÿ 01ÿ ÿ ÿ ÿ ÿ 12ÿ 2u 0  1i 0  0i^  6^_  1_[Aÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ<$).38=BGLQV[`ejoty~ƒˆ’—ÿÿ[a 67a\ 10\] 10]b11be1ef1fg1gh00h`1  3  2`:133:s011111sE0     0   0     0     0E&%PAGE&
E0     0   2    12   999E
v
.jcgPART GRAPHING

.jcgCHAPTER Basic Graphing

.jcgSECTION Introduction
DIMFILM includes a collection of subprograms to facilitate the production of graph plots, while retaining the advantages of the overall system.  The graphing routines may be freely intermixed with the general plotting routines.  The system is designed to permit the user considerable freedom, and although this must inevitably introduce some pitfalls for the unwary, a large amount of checking is performed, and warning messages are included.  These are controlled as are those in the general plotting routines, through the check level.  Users interested primarily in graphing output should first familiarise themselves with the earlier sections on basic plotting.
Graphing may be freely intermixed with calls to all other plot routines.  DIMFILM attempts to ensure that on exit from any graphing routine, all internal parameters are set to their values on entry.  The beam is also positioned so that general plotting may be resumed easily.  Such properties as intensity, orientation and height of symbol strings, broken lines etc., will be maintained.  It is possible therefore, to interrupt a diagrammatic plot to perform graphical plotting and then to resume.  A few limitations are, however, necessary.  Primarily, on return, a broken line pattern will commence at the beginning of its sequence (the consequence of a beam off movement).  Symbol strings will commence with all their initial features active.  If TXTCON has previously been called, it will be operable on all but the first subsequent calls to SYMTXT.
Except where otherwise indicated, all graphical drawing routines are performed as CSType 1 operations.  All graph textual annotation will be treated as CSType 2, while non-textual annotation is a CSType 3 operation.  All graph titling and labelling (user supplied) will be subject to any escape sequences as described in Section 3.  Graphs will also be subject to interruption by markers, when the routine INTRPT has been called.  This applies only to plots where a set of data values has been supplied; when interpolation is used the interrupt only applies to the supplied data points ie.  a call of INTRPT(N,CHAR) would cause each Nth data point to be marked with character CHAR.  The height used would be that currently used outside the graph plot.
The use of intermixed general and graph plotting will be illustrated in a later section.  It is emphasised that this mixing may be performed freely within a frame, and at the simplest level it may mean only the changing of intensity for axes etc.

.jcgSECTION Graph Location
The overall size of a graph is taken to be identical to the current pre-clipping rectangle.  That is, the user by making a call to PANE (or through the default pre-clipping rectangle being the same as the overall bounds) has set the area to be occupied by the graph.  This area includes a margin for captions and values, and the proportions used are preset in DIMFILM.
Of specific interest to the user, is the area occupied by the actual graph plot, excluding margins etc.  This is 83% of the pre-clipping rectangle in each direction.  The graph labels and values will be in the margins between this rectangle and the actual graph plot.  Each margin in the X(or Y)-direction will be 8.5% of the corresponding X(or Y)-dimension of the rectangle.
This enables the user to position the graph plot anywhere within the bounds and graphs in equal area will appear identical, whilst those of similar areas would be reduced or enlarged accordingly.  This ensures continuity over a large number of plots and assists the user in making more than one plot in an area, but changing axis scales as required.  The actual co-ordinates used in calls to PANE etc.  are not referred to by the user during the course of graphical plotting All scaling of graphs is accomplished internally.  The X-axis of a graph will always by parallel to the X-direction of the frame and the Y-axis parallel to the Y-direction.  Hence, the orientation of a plot is determined by the current mode of the device.
.jcgSECTION Axis determination _
In any graphical work the user is obliged to determine the axis types required before commencing a plot.  There are few conditions imposed on the user performing graph plotting with DIMFILM, and these are summarised below.  The axis type need only be declared if a change is to be made, and clearly this must be done before plotting or assigning values to the axis etc.  is performed.  By default, it is assumed that both X-and Y- axes are linear.  A number of routines are available for changing or resetting axis types, at present the user will only be concerned with:

.jcgTT

	LINX	to set a linear X-axis.
  
	LINY	to set a linear Y-axis.
  
	LINXY	to set linear X- and Y-axis.
  
	LOGX	to set a logarithmic (base 10) X-axis.
  
	LOGY	to set a logarithmic (base 10) Y-axis.
  
	LOGXY	to set logarithmic (base 10) X- and Y-axis.

.jcgEE
Any combination of these calls is permissible, the last declared type for each axis being accepted.
For a basic graph, the user will have a set of (X,Y) co-ordinates that are to be plotted.  It may be that the plot is to be made along axes that have ranges automatically determined by the X- and Y- ranges of the data, or alternatively along axes having predefined ranges.  The default is for automatic range determination along both axes to be performed as in the former requirement.  For the latter requirement, the user may supply a range along either or both axes by the following.

.jcgTT

	XAXIS(XL,XR)
 
	YAXIS(YL,YR)
 
	where XL is the left bound and XR the right bound for the X-axis and YL is the low bound and YU the upper bound for the Y-axis.  In each case the bounds are given in terms of the user's graph units.

.jcgEE
Should both bounds be equal in a call to one of these routines, then DIMFILM will go into auto mode for that axis.
Axis ranges set in this way remain set until such time as they are either set to some other value or auto mode is restored using the following routines:

.jcgTT

	AUTOX	to set auto range determination on the X-axis.
  
	AUTOY	to set auto range determination on the Y-axis.
  
	AUTOXY	to set auto range determination on both axes.

.jcgEE

.jcgSECTION Drawing the Graph _
Having determined axis types and ranges as required, a single call to the routine
.jcgTT

	GRAPH(X,Y,N)
 
	will accomplish the plotting.  X and Y are REAL arrays (of dimension at least N) holding the N X- and Y- coordinates respectively.  This will join consecutive co-ordinates by straight line segments.  The co-ordinates should be supplied monotonically in X.  N must be at least 2.

.jcgEE
To complete the graph with labels, values and to frame it, the following routine may be called:

.jcgTT

	GRDEF(TITLE,XLAB,YLAB,IXY)
 
	where TITLE,XLAB and YLAB are all strings of type CHARACTER with an appropriate length:
 
	 TITLE	is the title to appear at the base of the graph.
  
	  XLAB	is the label to appear below the X edge of the plot.
  
	  YLAB	is the label to appear to the left of the Y edge of the plot.
  
	  IXY	is used to control the presence or absence of axes, according to its value -
.jcgNL
=0 :- neither axis will appear,
.jcgNL
=1 :- the X-axis only will appear and be ticked,
.jcgNL
=2 :- the Y-axis only will appear and be ticked,
.jcgNL
=any other value :- both axes will appear and be ticked.

.jcgEE

In addition to these titles, labels and axes, the plot will be framed (i.e.  the actual graph will be boxed), all edges will be ticked and values will appear adjacent to the ticks.
(It should be noted that any axis can only be plotted if it lies within the range of the orthogonal co-ordinate.  For example the X-axis at y=0 can only be plotted if zero is included in the Y-range.)
Essentially, this routine is present to offer a default set for the annotation of the plot.  It is not expected that all users will wish for this set of annotations and consequently a large number of routines are included to perform the individual parts.  It is suggested that each user constructs his own standard set of calls in a single subroutine and references this at the end of each plot.  Of course, he may wish to annotate each plot differently and in this case, the full range of routines may be accessed.  These routines will now be described.
A simple convention is used to refer to the sides of any line.  For lines in the X-direction there is a lower (L) and upper (U) side, referring to the normal Y-values which are orthogonal to this line.
Similarly, for a line in the Y-direction there is a left (L) and right (R) side.  The graph itself may, or may not have the axes included in it and is bounded by four edges, surrounding which are the margins; the whole being contained exactly within the pane.
For all the following routines that perform titling or labelling, the symbol strings are passed through the SYMTXT routine and all the facilities described in section 3.1 are available (although it should be noted that text continuation will not operate, each string commencing with the selected features).  Text strings will be appropriately centred.
Titles may be placed below the lower edge or above the upper edge by the following.

.jcgTT

	LTITLE(TITLE)
 
	for titling below the lower edge
 
	UTITLE(TITLE)
 
	for titling above the upper edge

.jcgEE
TITLE is a string of type CHARACTER of the appropriate length, which contains the text to be passed to SYMTXT.
Labels may be placed against any edge or either axis, although for the latter option it is necessary for the axis to be within the orthogonal axis range.

.jcgTT

	LXLAB(LABEL)
 
	labels the lower edge
 
	UXLAB(LABEL)
 
	labels the upper edge
 
	LYLAB(LABEL)
 
	labels the left edge
 
	RYLAB(LABEL)
 
	labels the right edge
 
	LXALAB(LABEL)
 
	labels below the X-axis
 
	UXALAB(LABEL)
 
	labels above the X-axis
 
	LYALAB(LABEL)
 
	labels to the left of the Y-axis
 
	RYALAB(LABEL)
 
	labels to the right of the Y-axis

.jcgEE
In each of these calls LABEL is a string of type CHARACTER of the appropriate length, which contains the text to be used as the label.
The edges and axes may be ticked as required, the ticks corresponding to steps in the range in the appropriate direction and taking account of the axis type.  The spacing of ticks etc., will be considered below.

.jcgTT

	LXTIK	will cause ticking of the lower edge
 
	UXTIK	will cause ticking of the upper edge
 
	LUXTIK	will cause ticking of both the lower and upper edges
 
	LYTIK	will cause ticking of the left edge
 
	RYTIK	will cause ticking of the right edge
 
	LRYTIK	will cause ticking of both the left and right edges

.jcgEE
In each of these cases the ticking would be directed inwards.

.jcgTT

	LXATIK	will cause ticking on the lower side of the X-axis
 
	UXATIK	will cause ticking on the upper side of the X-axis
 
	LYATIK	will cause ticking on the left of the Y-axis
 
	RYATIK	will cause ticking on the right of the Y-axis

.jcgEE
Values corresponding to the ticking of edges and axes may be plotted.

.jcgTT

	LXVAL	plots values below the lower edge
 
	UXVAL	plots values above the upper edge
 
	LUXVAL	plots values below the lower edge and above the upper edge
 
	LYVAL	plots values to the left of the left edge
 
	RYVAL	plots values to the right of the right edge
 
	LRYVAL	plots values to the left of the left edge and to the right of the right edge

.jcgEE

Similarly for the axes,

.jcgTT

	LXAVAL	plots values below the X-axis
 
	UXAVAL	plots values above the X-axis
 
	LYAVAL	plots values to the left of the Y-axis
 
	RYAVAL	plots values to the right of the Y-axis

.jcgEE

The axes themselves may be drawn by the following

.jcgTT

	DRAWXA	to plot the X-axis
 
	DRAWYA	to plot the Y-axis

.jcgEE
As an alternative to ticking the edges etc., the user may grid the plot entirely using the following

.jcgTT

	XGRID	will plot grid lines normal to the X-axis (i.e.  parallel to the Y-axis )
 
	YGRID	will plot grid lines normal to the Y-axis
 
	XYGRID	will completely grid the plot in both directions

.jcgEE
It is clear that when ticking (or gridding) and valuing are applied, or labelling an axis, it is essential that the ranges for each axis are defined first.  They may either be explicitly defined by calls to XAXIS and YAXIS, or if auto mode is in operation on either axis,they will be known internally after the plotting of the graph (i.e.  as described in this section through a call to GRAPH ).  Clearly then a sequence for these calls has been formulated.  This may be summarised in priority, after the definition of the pre-clipping area:

.jcgTT

	 1) axis type declarations
 
	 2) axis range specifications
 
	 3) ticking, valuing, gridding or labelling axes

.jcgEE

Titling and edge labelling may occur at any point.  If automatic mode is in operation on either axis then the graph call which fulfills the function of range determination must occur at step 2, otherwise it may appear anywhere after stage 1.  Steps 1 and 2 will be retained from any previous graph plot and so do not need redefinition for subsequent plots.  Of course, if auto mode is active then the previously determined range(s) will hold until reset by a call to a graph plot routine.
Although the user has considerable freedom, it is suggested that the safest course is :

.jcgTT

	 1) axis type declarations (if changes to be made)
 
	 2) axis range specifications (if non-auto, or to be reset)
 
	 3) graph plot
 
	 4) all annotations (in any order)

.jcgEE

The edges of the graph area may be plotted by

.jcgTT

	GRFRAM

.jcgEE

This will be required in nearly all cases.  The frame is drawn as CSType 3.
To outline the current pane, call

.jcgTT

	OPANE	(as described in section 2 - CSType 3.)

.jcgEE

The determination of value intervals (also used for ticking and gridding) is performed automatically (although see section 4.2 later) depending on the axis ranges.
For linear axes with a range of length d x 10**i with d greater or equal to 1.0 and less than 10.0 (i.e.  d in [1.0,10.0)) an interval between values will be chosen according to the value of d as shown below:

.jcgCONTIG INLINE


.jcgTT

	 d in [1.0,3.0) interval = 2.0 x 10**(i-1)
 
	 d in [3.0,7.0) interval = 5.0 x 10**(i-1)
 
	 d in [7.0,10.0) interval = 1.0 x 10**i

.jcgEE


.jcgENDC

The values marked will be integral multiples of the interval, thus ensuring that 0.0 would be a value point.  The choice of these intervals maintains a reasonable number of divisions without overcrowding (always more than 4 and less than 16).  The values themselves will be plotted in a format to maintain the maximum accuracy without excessive digits appearing.  Where possible a common power of ten factor will be removed (and indicated adjacent to the edge or axis being 'valued').
The same value points are used for the tick spacing, the tick lengths being one hundredth of the size of the shorter pane side.
For logarithmic axes, to ensure clarity, if there are less than two cycles along the axis values of the logarithm (base 10) the values will be plotted and determined as for the linear axes.  If at least two cycles are contained along the axes then the values as integer powers of 10 will be appropriately placed at cycle boundaries.
Ticking will occur at these boundary points, and if fewer than five cycles are contained on the axis, then intermediate half-size, faint ticks will be plotted (these correspond to the normal intermediate divisions of a log cycle).
When gridding is specified the spacing is the same as the corresponding ticking as described above.








.jcgCHAPTER Refined Graphing
The features described in the previous section enable the user to plot straight line graphs from a set of co-ordinate pairs, against linear or logarithmic axes.  The immediate extension of this is for some form of interpolation to be performed between consecutive data points to give a smooth curve for the finished plot.  DIMFILM provides the choice of two polynomial interpolations - third or fifth degree.  To effect either of these the call to GRAPH should be replaced by

.jcgTT

	POLY3(X,Y,N)
 
	for third degree polynomial interpolation
 
	POLY5(X,Y,N)
 
	for fifth degree polynomial interpolation

.jcgEE
X and Y are REAL arrays (of dimension at least N) holding the N pairs of co-ordinates to be graphed.  There is a proviso that N must exceed the degree of the polynomial interpolation being performed.  Plotting of an interpolated graph will terminate should a singularity be found during the interpolation process.
By default the number of steps between consecutive abscissae at which interpolated values will be found is 5.  The larger this value, the smoother the resultant curve, although execution time for the program will increase correspondingly.  The number of steps for this interpolation may be altered by

.jcgTT

	INTERP(NSTEPS)
 
	where NSTEPS is the number of intermediate steps at which the interpolation polynomial will be evaluated.

.jcgEE
An alternative output that might be required from a set of co-ordinate pairs might be a simple point plot, when no join is made between the points.  To accomplish this,

.jcgTT

	PTPLOT(X,Y,N,NCHAR)
 
	where X,Y and N are as before, and NCHAR is the number of the required marker symbol at each point (from the current Marker Font), NCHAR is an integer in the inclusive range 1 to 48 .  As for the normal call to GRAPH, N must be at least 2.

.jcgEE

When discrete co-ordinate pairs are provided, it may be desired to produce a histogram bar chart.  The bars will in each case be in the Y- direction, and correspond to each abscissa input.  The appropriate instruction is

.jcgTT

	HISTGR(X,Y,N,BAR)
 
	X,Y and N being as before.

.jcgEE
The fourth parameter, BAR, controls the type of histogram that will be produced.

.jcgCONTIG INLINE


.jcgTT

	BAR = -1.	- auto-width histograms will be produced, so that adjacent bars touch.
  
	  = 0.	- histogram lines are produced (i.e.  a special case of fixed width bars).
  
	  > 0.	- histogram bars width BAR (in user axis units) will be plotted.

.jcgEE


.jcgENDC

Several variations of histogram bar charts are possible.
A step histogram may be plotted by

.jcgTT

	STEPGR(X,Y,N)
 
	the three arguments being the same as the first three arguments for HISTGR.

.jcgEE
The effect is to produce an auto-width histogram with common verticals removed.  This is the common staircase type of histogram.
It is possible to shade the histogram bars (when bars of a finite width are to be produced).  This is performed by

.jcgTT

	SHDEGR(X,Y,N,BAR,THETA,GAP)
 
	The first four arguments are those for HISTGR, with the limitation that for BAR = 0.0 histogram lines (i.e.  bars of zero width) only will be produced.  The last two arguments are used to define the type of shading, and correspond to the arguments for HATCH (section *.x)
 
	 THETA	is the angle (AGroup1, default degrees - see I.1.9) the shading lines make with the positive X-direction, and should be in the range (-90.0,90.0)[degrees].
  
	  GAP	is the perpendicular distance, in user overall units, between consecutive shading lines.

.jcgEE

The shading of each bar is performed separately, and is defined under HATCH.  The user may force two histogram bar charts, each with different shading types, to be plotted with bars of the two data sets adjacent for comparison by the appropriate positive specification for BAR, and a shift in X range (by BAR) between the calls to SHDEGR for the two data sets.
With all the histograms, it is the case that a vertical line may coincide with an edge of the graphical area.  DIMFILM has no knowledge of whether the user will draw the edges, and consequently the default is to plot such verticals.  However, when the Y edges are plotted, such verticals will be superimposed, which may not be desired.

.jcgTT

	HREP	causes the suppression of histogram verticals that coincide with the Y-edges, while
 
	HPER	restores the default, whereby the plotting of such verticals is permitted.

.jcgEE
It will often be the case that a graphical plot of a known function is to be made.  In this case the appropriate call would be

.jcgTT

	GRAPHF(FN)
 
	where FN is a REAL FUNCTION, supplied by the user, and which should be declared EXTERNAL in the calling program.  The function should have two REAL arguments and be referenced as 
	Y = FN(X,DX)
 
	where the value returned in the function is the function value (i.e.  Y co-ordinate) at X.  The argument DX on return should be the increment in the X direction to be made for the next plotted point.  These values are all in terms of the axis co-ordinate scales.

.jcgEE
GRAPHF starts at the minimum X-axis value, and proceeds until the maximum is reached or , in the case of a curve which becomes double valued in X , the minimum is passed.  That is, plotting commences until the graph leaves the X-axis range.  Alternatively, the graphing will cease when two consecutive zero values for DX are returned.  The general comments under Part I, section 4 relating to FNPLOT apply, with references to X and Y ranges being, in the case of GRAPHF, references to the axis ranges.
With GRAPHF it is obvious that automatic axis scaling cannot be applied; hence both axis ranges must have previously been determined.  If either axis is in auto mode at the initiation of a call to GRAPHF, then the current axis range for that axis will hold, ie.  it will be the range used for the immediately preceding graph plot (possibly determined under auto-mode).  Should no previously defined range exist then an error condition will occur and no plot will result.
All the above graph plotting routines take full account of the various axis types.
A further axis type is available, and is of particular use for commercial plots.  This is the month axis.
.jcgTT

	MONTHX(SMONTH)
 
	will set the X-axis to months,
 
	MONTHY(SMONTH)
 
	will set the Y-axis to months.

.jcgEE
In either case, the REAL argument SMONTH is used to indicate the starting month along the appropriate axis.  The months January to December running from 1.  to 12.  respectively, a fractional value is permitted to denote the plot is to commence at a fraction of a month.  The left limit will be the 1st of this month.
E.g.  February 7th would be 2.25 for SMONTH, and the axis would commence at February 1st with the first plot occurring at February 7th.
The value of SMONTH must be in the range 1.0 to 13.0 .  If an illegal value is requested, 1.0 will be substituted.
A subsequent call to GRAPH, POLY3, POLY5, PTPLOT, or HISTGR with arguments (X,Y,N) (and BAR in the case of HISTGR, and NCHAR in the case of PTPLOT) will cause plotting with the appropriate month axis from the starting point SMONTH at monthly intervals for the N values along the orthogonal axis.  This is the auto-mode month axis, the argument N being the number of months to be as plotted.  The orthogonal axis values should be held in the REAL array X or Y as appropriate, the other array being a scratch array that will be used during the call, and its contents lost.
This situation will be clarified by example:

.jcgTT

	LOGY	Y-axis set as a log axis
 
	MONTHX(3.0)	X-axis a month axis, commencing at March 1st
 
	GRAPH(X,Y,N)

.jcgEE
This will plot the N values from REAL array Y at monthly intervals starting at March 1st, i.e.  Y(1) will be the Y value plotted against March 1st, Y(2) against April 1st, etc.  REAL array X must be available for use by GRAPH.  The X axis will be divided into months.
Similarly,

.jcgTT

	LINX	X-axis set as linear axis
 
	MONTHY(3.0)	Y-axis a month axis, starting at March 1st
 
	GRAPH(X,Y,N)

.jcgEE
will plot N values from REAL array X at monthly intervals commencing with March 1st, i.e.  X(1) will be the X-value plotted against March 1st, X(2) against April 1st, etc...  REAL array Y must be available for use by GRAPH.  The Y axis will be divided into months.
After a call of MONTHX or MONTHY the relevant axis will remain a month axis until reset (for example, by a reference to LINx or LOGx).  It is not permissible for both axes to be of type month for any plot.
Ticking and valuing will apply to month axes with each month being ticked when 12 or fewer months are plotted along the axis.  For greater numbers of months not every month will be marked, as indicated:

.jcgCONTIG INLINE


.jcgTABSET 10,30

	Number of months	Month interval for 
		 ticking, etc.

.jcgTABSET 15,40

	<12	1 
	(12,24]	2 
	(24,36]	4 
	(36,60]	6 
	>60	12

.jcgENDC

The above methods have shown the use of automatic month plotting, when each successive data point is exactly a month from the previous point.
It may be necessary to plot at intervals other than exact months, in which case it is necessary to define the number of months that are to be plotted along the month axis.
.jcgTT

	MONSX(NMNTHS)
 
	sets the number of months along the X-axis
 
	MONSY(NMNTHS)
 
	sets the number of months along the Y-axis
 
	 NMNTHS is the number (INTEGER) of months to be plotted along the appropriate axis.  These calls do not replace the calls to MONTHX or MONTHY, which should also be made.  Any subsequent call of AUTOX, AUTOY or AUTOXY will reset the relevant month axis to auto mode.

.jcgEE
When this mode of fixing the month range is in operation the previously scratch array in the X,Y arguments to GRAPH etc., is used differently.  It should now hold the offset, in months, from the beginning of the starting month (as set by MONTHX etc).  An example will illustrate this:

.jcgTT

	LOGY	sets logarithmic Y-axis
 
	MONTHX(2.5)	sets X-axis to months, beginning February 14th for auto mode month plots.
  
	MONSX(10)	indicates fixed number (10) months along X-axis
 
	GRAPH(X,Y,N)

.jcgEE
N points will be plotted, Y(I) will hold the Y-value of the Ith point (I=1,N) and X(I) holds the offset, in months, from the 1st February (this being the start month), although the axis will start at the 14th (as set).
Suppose X(1)=1.25 , X(2)=1.50 , X(3)=2.00 , ....
Y(1) would be plotted as March 7th (1.25 months after Feb 1st)
Y(2) would be plotted as March 14th (1.50 months after Feb 1st)
Y(3) would be plotted as April 1st (2.00 months after Feb 1st)
etc.
When discrete data is provided to a graphical routine (excepting, therefore, GRAPHF) the user may wish symmetric or asymmetric error bars to appear for each data point in the X and/or Y directions.
Separate calls exist for this purpose, and are listed below:

.jcgTT

	GRAPHE(X,Y,N,MX,MY)
 
	which corresponds to GRAPH, producing straight line joins between data points.
  
	PTPLTE(X,Y,N,NCHAR,MX,MY)
 
	corresponding to PTPLOT, each data point being plotted with the marker designated by NCHAR
 
	POLY3E(X,Y,N,MX,MY)
 
	POLY5E(X,Y,N,MX,MY)
 
	corresponding to POLY3,POLY5 respectively with polynomial interpolation between data points

.jcgEE
The arguments are of somewhat different form than the corresponding routines.
X and Y are real arrays of dimension X(N,MX), Y(N,MY), where N is the number of data points.
MX and MY may each have the value 1, 2 or 3.
Considering the array Z(N,MZ); Z=X,Y, then in each case Z(I,1) holds the Ith Z data value which will be plotted.
For MZ=1 no error bars will be produced in the Z-direction.
MZ=2 implies symmetric error bars should appear in the Z-direction, and for the Ith data point, the Z error bar will be +/- Z(I,2) in magnitude.
MZ=3 implies asymmetric error bars in the Z direction, in which case the Ith data point will have Z error bar given by +ABS(Z(I,2)), -ABS(Z(I,3)).
The error bars are plotted with the same line type as the graph, although the tick heads to each bar will be solid.  It should be noted that MX need not equal MY, and for error bars in one direction only the other MZ should be set to 1.  Tick heads will have the same size as other graphical ticks.
To force the error bars to be of different line type it is necessary to make a standard call to GRAPH etc.  followed by the required line type change and then a call to PTPLTE with NCHAR set to 0 (unless some character is required at the data points additional to the error bars).
It is possible for axes to be drawn at any particular X- or Y-value, i.e.  at other than the normal zero lines.  To set this

.jcgTT

	AXCUT(XO,YO)
 
	where (XO,YO) is the co-ordinate pair at axis intersection.  By default this will be at (0.,0.).  The axis intersection point will then define axis positions for all subsequent axis drawing, ticking labelling etc., until reset.

.jcgEE
The user may wish, for linear axes, to control the interval between ticks, and hence values.

.jcgTT

	DIVUNI(DIVX,DIVY)
 
	(with DIVX,DIVY 0.0) will cause all subsequent linear axis ticking etc., to be at intervals of DIV- in the axis units for the relevant axis.  If this value is found not to be sensible automatic ticking etc., will be performed.  The condition for DIV- to be used is that it is less than one-half and not less than one-hundredth of the relevant axis range.  It may be specified for only one axis by setting the other DIV- non-positive.

.jcgEE
To return to automatic division determination on both axes
.jcgTT

	AUTD

.jcgEE
There is also provision for controlling the intensity step for the intermediate logarithmic axis ticks.

.jcgTT

	LOGTIK(RSTP)
 
	will result in a step down in intensity of RSTP for the intermediate ticks.  Note that RSTP is a real value in the range 0.0 to 1.0 .  The default value is 0.2

.jcgEE
The user may also control the criteria used for determining whether log cycles should be ticked.  Section 1 (of Chapter 4) indicated that if less than two cycles appeared along an axis, then values of the logarithm would be plotted, while if five or more cycles were contained on an axis, no intermediate ticks would appear.  To change these values:

.jcgTT

	LOGLIM(ZMIN,ZMAX)
 
	where ZMIN and ZMAX are the real values of these criteria.  ZMIN being the minimum number of cycles for cycle values etc., to appear, ZMAX the number of cycles at and above which intermediate ticking will not appear.

.jcgEE
When automatic mode is selected, each graph has individually determined axis ranges (on either or both as specified AUTOX, AUTOY etc.).  It is often the case that while automatic range determination may be used for the first graph, it may be wished to plot subsequent graphs against the same axis ranges.  This may be forced by:

.jcgTT

	SAMEX	which fixes the X-range as that currently held
e.g.  after a call to a graphical range that X range is retained (as though the relevant call to XAXIS had been made) for all following graphs, and automatic X-range determination is turned off.
  
	SAMEY	acting on the Y range
 
	SAMEXY	acting on both X and Y ranges

.jcgEE
By default axis values are plotted in a real format (i.e.  including the decimal point).  It is possible, when the range permits, for integer values to be plotted by linear axes or edges.

.jcgTT

	IXAX	specifies that future valuing of linear X-axes should, when possible, be in integer format
 
	IYAX	acts similarly for subsequent linear Y-axes

.jcgEE
Real values may be restored for all subsequent valuing by:

.jcgTT

	RXAX	for real values on X-axes
 
	RYAX	for real values on Y-axes

.jcgEE
Common scale factors may well be included for integer values axes where necessary, and it should be appreciated that ranges such as (10.0,10.9) are incapable of being valued integrally.  Also, the user should note that the X and Y values passed to GRAPH etc., should still be real numbers.

.jcgCHAPTER Alternative Co-ordinate Systems
In addition to the rectangular co-ordinate systems described above, DIMFILM provides the means to plot against polar axis systems, i.e.  radial plots.
The area occupied by a polar plot is the same portion of the window as used for cartesian plots.  In the case of polar plots, however, the total area is not used, the scaling and positioning of the axis system being performed to maximise the area used.
The calls are closely analogous to those previously described for rectangular co-ordinate systems, and the priorities for ordering of calling sequences as given in Section 1 still hold.
The radial axis type may be specified by:

.jcgTT

	LINR	to set linear radial axis (this is default)
 
	LOGR	to set logarithmic radial axis

.jcgEE
The units of angular measure for angles to the radial plotting routines belong to AGroup2 (therefore being radians by default).  The section on Angular Measure within the part on Basic Plotting gives further information and describes ways of changing the default.
Axis ranges may be supplied by the user:

.jcgTT

	RRANGE(RMIN,RMAX)
 
	will set the radial range to be RMIN to RMAX, where RMAX is greater than RMIN which is greater than or equal to 0.0
 
	TRANGE(THETA1,THETA2)
 
	will set the angular range from THETA1 to THETA2, both angles being AGroup2 (default radians) and should each be in the range [0.0,2pi][radians].

.jcgEE
If either of these calls is made the appropriate axis range is fixed until reset.  By default, automatic range determination is provided.  This may be reselected at any time:

.jcgTT

	AUTOR	sets automatic radial range determination
 
	AUTOT	sets automatic angular range determination
 
	AUTORT	sets automatic range determination for both axes

.jcgEE
Having determined axis types, ranges as required:

.jcgTT

	POLAR(R,THETA,N)
 
	will plot the N co-ordinate pairs from R, THETA (both REAL arrays of minimum dimension N), where R holds the radial values, and THETA holds the angular values (AGroup2, default radians).

.jcgEE
The graph may be completed by

.jcgTT

	POLDEF(TITLE,RLAB)
 
	where TITLE and RLAB are CHARACTER arrays (of appropriate length) holding captions to be passed to SYMTXT
 
	 TITLE	is the title to appear at the base of the plot
 
	 RLAB	is the label to appear below the plot

.jcgEE
The polar boundary will be included with radii at 90 degrees, each radius will be ticked and valued, and angular values will be plotted around the circumference.
Titling etc., may be performed through LTITLE, UTITLE, LXLAB, UXLAB, LYLAB, RYLAB as for rectangular plots.  Due to the varied boundary shapes and positions that may apply to radial plots it is not sensible to provide any rigid labelling format.  Generally, the -XLABEL should be satisfactory for describing the radial axis, and -YLABEL for the angular values.
Ticking and valuing may be independently controlled.  In the following description it should be borne in mind that in the general case the extremities of a plot will not be coincident (only in the exceptional case of the angular range 2pi [=360 degrees] will this be so), and between the extremities (i.e.  going from THETA1 to THETA2, the angular range limiters) one or more principal radii may be included (i.e.  those at integral multiples of pi/2 radians, viz.  0, pi/2, pi, 3pi/2, 2pi [equivalent to 0., 90., 180., 270.  degrees]).

.jcgTT

	POLOUT	will produce the bounding outline of the polar plot area - i.e.  the arcs of minimum and maximum radius, and the radii at the bounding angles will be plotted.
  
	POLFR	will produce the bounding outline (as POLOUT) and also plot the included principal radii.
  
	RXVAL	will plot the radial values at the extreme radii.
  
	RVAL	will plot the radial values at the extreme radii and at included principal radii.
  
	RXTIK	will tick the radial values on the extreme radii.
  
	RTIK	will tick the radial values on the extreme radii and on included principal radii.

.jcgEE
It should be noted that, generally, the tick length is taken into account when valuing radii to avoid any overlap of tick and value.  The user may exercise some control over this by:

.jcgTT

	RADSEP(ANGLE)
 
	ANGLE is specified as AGroup2 (default radians).  It controls the appearance of ticks for principal radii.  If a principal radius is closer than ABS(ANGLE) to an extreme it will not be ticked.  For non-coincident radii of angular range extremities to be separately valued there is a minimum necessary angular separation.  If ANGLE >0.0, this separation is ANGLE.  For zero or negative ANGLE automatic computation taking account of value positioning and character size is made.  At less than the (fixed or computed) separation angle only the radius of least angle will be valued.  While for less than twice the separation angle, values will not be spaced by the tick size from the radius, i.e.  values will be adjacent to radii.  The default value of ANGLE is -0.1 (radians), i.e.  automatic computation of separation angle is made, but included principal radii closer than 0.1 radians to an extrema are not ticked.
  
	POLGRD	will grid the polar plot.

.jcgEE
The gridding of a polar plot comprises the plotting of radial lines and circular arcs at certain radii.  Due to the concentration of radii at the centre of a polar plot it is generally necessary to incorporate some thinning of radial lines as the centre is approached.
This is done by dividing the maximum radius, and each division having a separate angular increment between radial grid lines.  The circular arcs that appear are dictated by the ticking (and valuing) of the radii, consequently the division points must be adjusted to coincide with these arcs.  The number of divisions fixes the size of each division, and the tick point along a radius following nearest to each division is selected to bound a division.  However, a spacing less than .4 of the fixed division is ignored to prevent nonsensical thinning of radii.
By default 3 divisions are used with angular separation of radii being pi/2, pi/4, pi/12 (radians) [equivalent to 90, 45, 15 degrees].  These may be changed by the user by

.jcgTT

	TLEVS(XLEV,N)
 
	where N, INTEGER, is the number of levels to be used for the thinning of gridding radii - a maximum of 4 is permitted 1<N<4 and XLEV is a REAL array of dimension 4, with the first N elements holding the angular intervals between radii at each division (from 1 at the centre to N at the maximum radius).  The angles belong to AGroup2 (default radians).

.jcgEE
To cause angular values to be plotted along the arc of maximum radius,

.jcgTT

	TVAL

.jcgEE
The angles so plotted will always be in degrees, and will occur at the interval specified for the highest level set (i.e.  by default at pi/12 radians).
Ticking of the outer arc may be done at the angular intervals by

.jcgTT

	TTIK

.jcgEE
for linear intervals on the radii, overriding of the automatic division control is possible by

.jcgTT

	RDIV(D)
 
	when D, REAL, will be the interval between ticks etc., on the radii.  This is subject to the same conditions as the similar feature for cartesian plots.

.jcgEE
Automatic division may be restored by:

.jcgTT

	AUTORD

.jcgEE
Logarithmic axis ticking is controlled as for cartesian plots, and the call to LOGLIM (described in section 2) controls logarithmic limits for both types of plot.
Analagous with the calls for interpolation, point and function plotting against rectangular axes (as described in section 2) are calls for the similar purpose with polar plots.

.jcgTT

	POLPY3(R,THETA,N)

	for third degree polynomial interpolation.

	POLPY5(R,THETA,N)

	for fifth degree polynomial interpolation.

.jcgEE
R and THETA are REAL arrays (of dimension at least N) holding the N pairs of co-ordinates to be plotted.  N must exceed the degree of the interpolation polynomial.  The number of interpolating steps between consecutive THETA values is controlled by INTERP (see section 2), and by default is 5.  THETA is of AGroup2 (default radians).
Plotting a symbol at each co-ordinate pair with no connecting line is accomplished by

.jcgTT

	POLPTS(R,THETA,N,NCHAR)
 
	where R, THETA and N are as before, and NCHAR (1<NCHAR<48) is the desired marker symbol from the Marker Font.  (N>2).

.jcgEE
To plot a polar function,

.jcgTT

	POLFN(FN)
 
	where FN is a REAL FUNCTION, supplied by the user, and which should be declared EXTERNAL in the calling program.  The function should have two REAL arguments and be referenced as
 
	 R=FN(THETA,DTHETA)
 
	where the value returned in the function is the radial value (i.e.  R) at angle THETA, and DTHETA, on return is the increment to be made in the angle for the next plotted point.  THETA and DTHETA are both in AGroup2 (default radians).

.jcgEE
The general details of this call and its operation are directly analagous to GRAPHF, the description of which is in section 2, and to which the user is referred.
Analagous to SAMEX, SAMEY, SAMEXY are the references

.jcgTT

	SAMER	which fixes the R range at the current range

	SAMET	fixing the angular range

	SAMERT	fixing both the radial and angular ranges

.jcgEE
A different form of plot concludes this section.  This is the "pie chart" plot.  In this, data is apportioned a sector of a circle in direct proportion to its fraction of the total.  As with all graphical plots, the piechart occupies a portion of the current window.  Within this space the chart is centred.

.jcgTT

	PIECHT(R,CAP,PERCNT,N,IPERS)
 
	 R	is the radius of the chart, in current users units, and this must not exceed half of 83% (the graph area) of the minimum pane dimension.
  
	  N	is the number of data items to be plotted.
  
	  CAP	is a CHARACTER array of dimension N, containing the N captions of the data items.  When percentages are to be plotted for each data item, this will be appended to each caption.
  
	  IPERS	indicates the form of data input, and whether percentages are to be plotted.
  
		If IPERS is negative, the actual data value of each item is input through PERCNT, in which case there will be exactly N sectors.  When IPERS is positive, the actual percentages associated with each are input through PERCNT.  In this case, a check is made by totalling the percentages 1 to N, and if a total in excess of 100.1 is found an error is recorded and the call ignored.  Conversely, a total less than 99.9 will result in a blank sector appearing to force the total to 100.
  
		When the absolute value of IPERS is 1 no percentage will accompany the data names on the plot, while an absolute value of 2 causes percentages to be plotted.
  
	  PERCNT	is a REAL array of dimension N, holds the percentages or values (as determined by IPERS) associated with each item.

.jcgEE




.jcgCHAPTER Graphing in depth

This section contains details of a handful of routines that will probably be accessed only infrequently by the user.  They do, however, offer the means for the more ambitious to obtain superior graphical plots.  Unless specifically stated, the following facilities refer only to plots against rectangular axes, i.e.  those discussed in sections 1 and 2.
Although DIMFILM is able to provide ticking of the various bounds and axes, as described in II 1.4, it has no prior knowledge of whether axes will in fact be drawn.  Where axes are included, a tick at the axis point will result in a heavier density or a colour "change" where axis and tick coincide.  Conversely, if the axis tick were omitted and the axis not drawn then a seemingly nonsensical gap in the ticking would appear.  By default ticking is suppressed at the axis as it is felt that generally an axis will be incorporated if it falls within range.  To reverse this, so that ticking occurs at the axis point the following routine may be called :

.jcgTT

	AXTIK

.jcgEE

The default condition may be restored by :

.jcgTT

	NOAXT

.jcgEE
It is obviously the user who must consider whether or not his axis will be contained in the plot.
The ticking of bounding edges is directed inwards.  A set of routines exist to place outward pointing ticks on the bounding edges:

.jcgTT

	LXOPT	for outward ticking of the lower edge
 
	UXOPT	for outward ticking of the upper edge
 
	LUXOPT	for outward ticking of both upper and lower edges
 
	LYOPT	for outward ticking of the left edge
 
	RYOPT	for outward ticking of the right edge
 
	LRYOPT	for outward ticking of both left and right edges

.jcgEE
It is also possible to plot any combination of edges (rather than the complete frame of four edges, through GRFRAM - see II.1.4).  The ticking of the open ends of the plotted edges may also be controlled.

.jcgTT

	EDGES(LKJI,ITICK)
 
	 LKJI	is a four digit INTEGER, each digit being 0 or 1.  There is a 1:1 correspondence between the digits and the four edges, and a value 1 causes the relevant edge to be plotted, while for 0 it is not plotted.
  
	The correspondence is:
 
	I - lowest edge
 
	J - left hand edge
 
	K - uppermost edge
 
	L - right hand edge

 
	 ITICK	controls the ticking of the open ends of the plotted edges (i.e.  at ends of the plotted edges not meeting another plotted edge).  The values ITICK may have are :
 
	+1 - inward ticks
 
	-1 - outward ticks
 
	+2 - in/out double ticks
 
	 0 - no ticks

.jcgEE

For example CALL EDGES(0011,2) would produce the lower and left edges with double ticks.
It may sometimes be more convenient to know the actual plotting co-ordinates (in the users overall frame system) of a point known in terms of currently used graphing axes.  This is necessary when one wishes to overplot text on a graph, or, possibly, to blank out a section of the graph (where it is known that no relevant data will occur) for future use as a legend box.
To obtain the actual plot co-ordinates (XA,YA) of a point with current graph co-ordinates (XG,YG) , call the following:

.jcgTT

	GRTOAC(XG,YG,XA,YA)

.jcgEE



Note: the desired coordinates (XA,YA) are actual coordinates in terms of the users (world) coordinates (e.g.  as determined through a reference to BOUNDS).  They take no account of any rotation or temporary origin.  As such they are suitable for use as blanking/clipping parameters, and should only be used for plotting when rotation and temporary origin are both zero.
There is provision for movement from the current position to a point referred to by its graph coordinate (XG,YG); this may be either a positional or drawing move.

.jcgTT

	GRON(XG,YG)
 
	is equivalent to ON2; drawing will occur from the current plot position to the actual point with graph coordinates (XG,YG) at the current colour/intensity and in the current style (i.e.  CSType 1).
  
	GROFF(XG,YG)
 
	is equivalent to OFF2; the current plot position will be repositioned to the actual point with graph coordinates (XG,YG) without drawing any line.

.jcgEE

Note: in these cases the movement is to the actual point with graph coordinates (XG,YG).  This point will become the current plot position.  Effectively rotations and temporary origin are accounted for (although there is no rotation within the graphing area).
.jcgDISPLAY
 The sequence
     CALL GRTOAC(XG,YG,XA,YA)
     CALL ON2(XA,YA)
will not generally have the same result as
     CALL GRON(XG,YG)

.jcgENDD
When there is no rotation and no temporary origin the results will be identical, otherwise the coordinates (XA,YA), which are actual world coordinates, will be transformed by ON2 according to the existing rotation and temporary origin before the move is made.  It is emphasised that (XA,YA) are the actual coordinates relative to the user's bounds; they are not relative to the current plotting axes.
Directly analogous routines exist for polar plots.  These are

.jcgTT

	POLTOA(R,THETA,XA,YA)
 
	which will convert the given coordinates (R,THETA) on the polar plot to actual coordinates (XA,YA).
  
	POLON(R,THETA)
 
	to draw a line (CSType 1) from the current plot position to polar point (R,THETA).
  
	POLOFF(R,THETA)
 
	to reposition the current plot position to polar point (R,THETA).

.jcgEE

The notes pertaining to the equivalent cartesian routines apply equally to those for polar coordinates.




 Û        ð 'Z µ-[ [ ÿ·ÿÿÿ'    ÛNW-  ÿ¯MÀÿÿÿAFGZÿ¯Ûÿÿÿ          E_      %   E_   7   )   E_    `      E_  Q °   ‹H!U