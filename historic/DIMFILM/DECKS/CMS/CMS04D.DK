*DECK CMS04D F
      SUBROUTINE DFX04D(NEWBYT)
C
C   ROUTINES TO HANDLE DATASET FOR DICOMED NATIVE CODE
C
C   CMS VERSION           -  JOHN GILBERT  MAY 1990
C
C   ENTRY POINTS:
C
C----------------------------------------------------------------------
C
C     DFX04D(NEWBYT)
C     (NOTE: THIS IS THE MAIN ENTRY TO INTERNAL DRIVER CODE)
C
C    SETS THE BYTE LIMIT - MAXBYT  (SEE DFX04B)
C
C  CALLING SEQUENCE IS:
C       CALL DFX04D(MAXBYT)
C
C                   MAXBYT - BYTE LIMIT
C
C
C   THE FUNCTIONALITY OF ENTRY DFX04D IS:
C
C      - RESETS MAXBYT TO NEWBYT (PROVIDED NEWBYT > 0)
C        (NOTE: OUTLIM MUST BE CHANGED IN DFXD04 IF NECESSARY)
C
C
C----------------------------------------------------------------------
C
C     DFX04A(INFORM,OUTLIM,EBCHDR,ASCHDR,IERR)
C
C      DYNAMICALLY ALLOCATES AND OPENS THE DIMFILM PLOT-FILE
C
C  CALLING SEQUENCE IS:
C          CALL DFX04A(INFORM,OUTLIM,EBCHDR,ASCHDR,IERR)
C
C               INFORM - FOUR BYTE FORM NUMBER
C               OUTLIM- MAX NUMBER OF RECORDS WHICH CAN BE WRITTEN
C                       THIS MAY BE NECESSARY TO OVERCOME ANY
C                       SYSTEM DEFAULTS
C                       IT SHOULD BE USED WHEN FIEL FIRST DECLARED
C                       (ESSENTIAL WHEN ROUTING TO SYSTEM QUEUES
C                        - AS FOR MVS - TO OVERRIDE DEFAULT
C                        LIMIT ON QUEUED FILE SIZE)
C                       PRESENTLY IGNORED FOR CMS
C                       (NOTE: THE INBUILT LIMIT IN DFXDXX ASSUMES
C                        RECORDS OF 1024 BYTES, FOR CMS WOULD
C                        NEED TO REFLECT ACTUAL RECORD SIZE OF 204)
C               EBCHDR,ASCHDR - FIRST 2 RECORDS TO BE WRITTEN
C                  THESE CONTAIN ACCOUNTING INFORMATION ETC.
C                  BOTH RECORDS ARE 160 DATA BYTES LONG
C                    EBCHDR IS IN EBCDIC
C                    ASCHDR IS SAME INFORMATION IN ASCII
C                  4 CHECKSUM BYTES ARE ADDED TO EACH HEADER (=164)
C               IERR  - RETURNS 4 BYTE FAILURE CODE ( =0 IF OK)
C
C      ASYNCHRONOUS I/O IS PERFORMED USING DIAGNOSE A8
C      A CLASS OF 'G' IS SPECIFIED FOR VECTOR DATA,
C      AND 'I' FOR RASTER.  THE FORM IS SET TO INDICATE THE FILM MODE.
C      AN OPTIONAL TAG FIELD MAY BE APPENDED WITH FURTHER INFORMATION
C      (E.G. ESTIMATED PLOT TIME)
C
C      DUE TO THE WAY IN WHICH VIRTUAL DEVICES ARE DEFINED IT IS
C      NECESSARY TO DEFINE THE DEVICE AS '3800' - THIS LIMITS
C      THE RECORD LENGTH TO 204
C      THIS LENGTH MUST BE MAINTAINED IN THE CMS DRIVER
C      BUFFER MANAGEMENT
C
C
C        ANY I/O ERROR IS REPORTED IN THE JOB LOG
C        AND AN EXTERNAL ROUTINE DFXMSA IS CALLED WITH
C        THE ERROR CODE AS ITS ONLY PARAMETER
C
C        THE ACCOUNTING VARIABLES ARE ALSO INITIALISED
C
C   THE FUNCTIONALITY OF ENTRY DFX04A IS:
C
C      - OPEN DATASET FOR DICOMED CODE
C      - SAVE FORMS CODE AND LINE LIMIT FOR LATER
C      - CALCULATE HASH WORD FROM EBCDIC HEADER
C      - WRITE OUT EBCDIC HEADER THEN ASCII HEADER, WITH
C        HASH WORD ADDED TO EACH
C      - CLEAR BYTE ACCUMULATOR
C
C----------------------------------------------------------------------
C
C     DFX04B(RBUFF,BUFFPT,DTYPE)
C
C                WRITES A RECORD TO THE PLOT-FILE
C
C  CALLING SEQUENCE IS:
C       CALL DFX04B(RBUFF,BUFFPT,DTYPE)
C
C                   RBUFF - ARRAY CONTAINING DATA
C                   BUFFPT - NUMBER OF 16 BIT INSTRUCTIONS
C                           MUST BE .LE. 100
C                    (IE. BUFFER LENGTH = 2*BUFFPT BYTES)
C                   DTYPE - DICOMED RECORD TYPE - INTEGER*4
C                          (ONLY LAST BYTE USED)   0  1  2  4
C                                                 CN  R  G  B
C
C    THE NUMBER OF BYTES WRITTEN IS ALSO ACCUMULATED IN THE
C    VARIABLE NOBYTE. IF THE NUMBER OF BYTES WRITTEN EXCEEDS
C    MAXBYT,THE EXTERNAL ROUTINE DFX01E IS CALLED WITH 2
C    PARAMETERS (EP1,MAXBYT). THIS TERMINATING ROUTINE MAY CALL
C    THIS ROUTINE AGAIN AND MUST THEREFORE STOP AFTERWARDS
C
C   THE FUNCTIONALITY OF ENTRY DFX04B IS:
C
C      - ADD 3 BYTE HASH AND 1 BYTE TYPE TO END OF RECORD
C        IN RBUFF
C      - WRITE OUT RECORD
C      - INCREMENT BYTE ACCUMULATOR (TAKE ACCOUNT OF HASH LENGTH)
C      - CHECK OUTPUT FILE LENGTH AND ENTER TERMINATION ROUTINE
C        IF NECESSARY
C      - ZERO BUFFER POINTER
C      - FOR DATA BLOCKS (NOT CONTROL) CLEAR BUFFER TO ZERO
C
C----------------------------------------------------------------------
C
C     DFX04C(RAST,IERR,NOBYTE)
C            CLOSES PLOT-FILE AND CHANGES SYSOUT CLASS TO 'G' OR 'I'
C            (FILE WILL VANISH IF THIS ROUTINE IS NOT CALLED -
C             EG. IF JOB ABORTS BEFORE REACHING THIS ROUTINE)
C   CALLING SEQUENCE IS:
C          CALL DFX04C(RAST,IERR,NOBYTE)
C
C                      RAST - RASTER MODE FLAG ,LOGICAL*4
C                               IF TRUE OVERIDE SYSOUT CLASS TO I
C                      IERR  - RETURNS FAILURE CODE ( = 0 IF OK)
C                      NOBYTE - NUMBER OF BYTES WRITTEN
C
C
C   THE FUNCTIONALITY OF ENTRY DFX04C IS:
C
C      - DISPOSE DATASET TO APPROPRIATE SYSOUT QUEUE (VECTOR
C        OR RASTER DEPENDING ON RAST)
C      - RETURN ACCUMULATED BYTE COUNT
C
C-----------------------------------------------------------------
      IMPLICIT INTEGER (A-Z)
C
C    NBH = NUMBER OF BYTES IN HEADER (THIS SHOULD BE A MULTIPLE
C          OF 8 FOR HASHING TO WORK)
C
      PARAMETER (NBH=160)
      CHARACTER  INFORM*4
      CHARACTER  EBCHDR*164,ASCHDR*164
C    **LENGTHS OF EBCHDR/ASCHDR MUST AGREE WITH THOSE IN**
C    **MAIN BODY OF DRIVER**
      CHARACTER*8 FORM
      CHARACTER*1 CLASS
      CHARACTER*17 FILEID
      INTEGER HBYTES,MAXBYT,BYTES
      LOGICAL LENERR,RAST
      PARAMETER (HBYTES=4)
C    HASH BYTES = 4
      INTEGER*4 HASHEQ,ITYPEQ
      CHARACTER*4 HSHTYP,CTYPEQ
      INTEGER*2 CK16(2)
      EQUIVALENCE (HASHEQ,HSHTYP),(HASHEQ,CK16)
      EQUIVALENCE (ITYPEQ,CTYPEQ)
C    EQUIVALENCE USED FOR HASHING
C    (IBM EXTENSION PERMITS EQUIVALENCE BETWEEN CHAR AND NON-CHAR)
C    MAY REFERENCE AS INTEGER*4 (32-BIT), INTEGER*2 (16-BIT),
C    OR CHARACTER*4
      INTEGER*2  RBUFF(*)
      CHARACTER SHBLK1*24,SHBLK2*136
*CALL,DFXPAB
*CALL,DFXCBA
*CALL,DFXCBD
*CALL,CMSCUT
      LOGICAL USETPE,FTCHAN
      SAVE
      DATA       USETPE/.FALSE./ , FTCHAN/.FALSE./
      DATA SHBLK1/' '/,SHBLK2/' '/
      DATA       MAXREC/16777000/
      DATA       MAXBYT/102400000/
C    MAXBYT - ALLOWED MAXIMUM BYTES TO QUEUE
C-----------------------------------------------------------------
      IF (NEWBYT.GT.0) MAXBYT = NEWBYT
      RETURN
C-----------------------------------------------------------------
      ENTRY DFX04A(INFORM,OUTLIM,EBCHDR,ASCHDR,IERR)
      USETPE = .FALSE.
      FTCHAN = .FALSE.
      IERR=0
C
C... SEE IF USETPE HAS BEEN CALLED
C
      IF (UTFLAG(NWS).GT.0) THEN
        IF (UTFLAG(NWS).EQ.11) THEN
C    HAVE !FT
          READ(UTVSN(NWS),'(3X,I2)') DN
          FTCHAN=.TRUE.
        ELSE
C
C... CONSTRUCT SHORT BLOCKS FOR USE BY USETAPE
C
          SHBLK1(1:1)=CHAR(28)
          SHBLK1(2:2)=CHAR(29)
          SHBLK1(3:3)=CHAR(30)
          SHBLK1(4:8)='B  1 '
          SHBLK1(9:16)=ASCHDR(51:58)
C
          SHBLK2( 1: 10)=ASCHDR( 41: 50)
          SHBLK2(11: 40)=ASCHDR(51:80)
          SHBLK2(41: 70)=ASCHDR( 11:40)
          SHBLK2(91:130)=ASCHDR( 81:120)
C      *CMS PRESENTLY DOES NOT SUPPORT TAPES*
C       THEREFORE FT IS ALWAYS PASSED AND DN
C       IS ACQUIRED AS A UNIT NUMBER
C       IF VSNS ARE IMPLEMENTED MUST PASS
C       SCRATCH FILE NAME (E.G. DFXD04) TO DFX01K
C       UNTIL THEN UNITS NUMBERS USED
          READ(UTVSN(NWS),'(3X,I2)') DN
          CALL DFX01K(DN,SHBLK1,SHBLK2,IERR)
          USETPE=.TRUE.
          RETURN
        ENDIF
      ELSE
        UTFLAG(NWS) = -1
C    SAVE FORM CODE
        FORM = INFORM
C    SAVE/USE OUTLIM IF NECESSARY
      ENDIF
C
C
C   CALCULATE HASH WORD FROM EBCDIC HEADER INFORMATION
C
      HSHTYP = EBCHDR(5:8)
      CHKSUM = HASHEQ
      I = 13
  100 HSHTYP = EBCHDR(I:I+3)
      CHKSUM = IEOR(CHKSUM,HASHEQ)
      I = I + 8
      IF (I.LE.NBH) GO TO 100
      CHKSUM = IAND(CHKSUM,NOT(15))
      HASHEQ = CHKSUM
C
C   MERGE HASH INTO EBCDIC HEADER
C   (N.B.  HEADER MUST ALLOW FOR ADDITIONAL 4 BYTES)
C
 
      EBCHDR(NBH+1:NBH+3) = HSHTYP(1:3)
      ASCHDR(NBH+1:NBH+3) = HSHTYP(1:3)
C   CREATE FILEID FOR CMS SYSTEM
      FILEID = ' '
      DO 2 I=26,35
      IF (EBCHDR(I:I).NE.' ') GO TO 3
    2 CONTINUE
      GO TO 4
    3 J = MIN(35,I+7)
      FILEID(1:8) = EBCHDR(1:8)
    4 FILEID(10:10+J-I) = EBCHDR(I:J)
      IF (FTCHAN) THEN
C   OUTPUT TO FILE
          WRITE(DN) EBCHDR(1:NBH+HBYTES)
          WRITE(DN) ASCHDR(1:NBH+HBYTES)
      ELSE
C   STANDARD OUTPUT TO STACKER VIA DIAGNOSE A8
C
C   FIRST ASSIGN VIRTUAL DEVICE
C
C-------------------------------------
C    TURN OFF MESSAGES IF DESIRED
C    HOWEVER IF MULTIPLE DRIVERS ARE RUN COULD GET PROBLEMS
C    WHEN TERMINATING AND RESTORING
C    PROBABLY BEST TO LEAVE AS SET BY/FOR USER
C         CALL DFXMSC('CP SET IMSG OFF',15,IERR)
C-------------------------------------
C
C    VIRTUAL ADDRESS 083 HEX = 131 DECIMAL FOR DFXD04/04D
C
C-------------------------------------
          CALL DFXMSC('CP   DEF 3800 AS 083',20,IERR)
C
C   NOW OUTPUT HEADER RECORDS
C
          CALL DFXMSD(131,'WRITE',EBCHDR,NBH+HBYTES,IRC,ISTAT)
          IF (IRC.NE.0) GO TO 1
          CALL DFXMSD(131,'WRITE',ASCHDR,NBH+HBYTES,IRC,ISTAT)
1         IF (IRC.NE.0) THEN
C
C   IRC IS RETURN CODE
C       0 - OK, 1 - EOF, 2 - I/O FAILED, 3 - I/O NOT DONE,
C       4 - PARAMETER ERROR
C   ISTAT IS SUPPLEMENTARY VALUE
C   FOR DIMFILM ERROR REPORT MERGE INTO IERR
C        (IERR = IRC .OR. SHIFTLEFT(ISTAT,4)
                  IERR = IOR(IRC,ISHFT(ISTAT,4))
                  CALL DFXMSA(IERR)
           ENDIF
      ENDIF
C   SET VARIOUS PARAMETERS
      LENERR = .FALSE.
      BYTES = 2*(NBH + HBYTES)
      NREC=2
      RETURN
C-----------------------------------------------------------------
C
C
      ENTRY DFX04B(RBUFF,BUFFPT,DTYPE)
C
C        OUTPUT BUFFPT 16-BIT WORDS FROM RBUFF, FLAG AS DTYPE
C
      IF (USETPE) THEN
        CALL DFX01L(RBUFF,BUFFPT,DTYPE)
      ENDIF
C
C        PACK CHKSUM AND DTYPE INTO NEXT FOUR BYTES OF RBUFF
C        NOTE: CHKSUM IS STORED LEFT JUSTIFIED
C
C
C            ---------  ---------
C            | C | C |  | C | D |
C            ---------  ---------
C  RBUFF      BUFFPT+1   BUFFPT+2
C
      ITYPEQ = DTYPE
      HSHTYP(4:4) = CTYPEQ(4:4)
      RBUFF(BUFFPT+1) = CK16(1)
      RBUFF(BUFFPT+2) = CK16(2)
      BUFFPT = BUFFPT + 2
C
C   NOTE: THE FOREGOING ASSUMES HBYTES=4
C
      IF (USETPE) GO TO 102
      IF (FTCHAN) THEN
C   OUTPUT TO FILE
          WRITE(DN) (RBUFF(I),I=1,BUFFPT)
      ELSE
C   STANDARD OUTPUT TO STACKER VIA DIAGNOSE A8
C
          CALL DFXMSD(131,'WRITE',RBUFF,2*BUFFPT,IRC,ISTAT)
          IF (IRC.NE.0) THEN
C
C   IRC IS RETURN CODE
C       0 - OK, 1 - EOF, 2 - I/O FAILED, 3 - I/O NOT DONE,
C       4 - PARAMETER ERROR
C   ISTAT IS SUPPLEMENTARY VALUE
C   FOR DIMFILM ERROR REPORT MERGE INTO IERR
C        (IERR = IRC .OR. SHIFTLEFT(ISTAT,4)
                  IERR = IOR(IRC,ISHFT(ISTAT,4))
                  CALL DFXMSA(IERR)
C   AND GO TERMINATE VIA DFX01E (ERROR -1)
                  CALL DFX01E(1,-1)
           ENDIF
      ENDIF
      NREC=NREC+1
      BYTES = BYTES + 2*BUFFPT
C   BUFFPT ALREADY ADJUSTED TO ALLOW FOR HBYTES
      IF (BYTES.GT.MAXBYT) THEN
                  IF (.NOT.LENERR) THEN
                             LENERR = .TRUE.
                             CALL DFX01E(1,MAXBYT)
                  ENDIF
      ENDIF
  102 IF (DTYPE.NE.0) THEN
                  DO 101 I=1,BUFFPT
  101             RBUFF(I) = 0
      ENDIF
      BUFFPT=0
      RETURN
C-----------------------------------------------------------------
      ENTRY DFX04C(RAST,IERR,NOBYTE)
      NOBYTE = BYTES
      IF (USETPE) THEN
        CALL DFX01M(NOBYTE,SHBLK1,SHBLK2,IERR)
        GO TO 999
      ELSE IF (FTCHAN) THEN
        REWIND DN
        GO TO 999
      ELSE
C
C    SET UP CLASS
C
           CLASS = 'G'
           IF (RAST) CLASS = 'I'
           CALL DFXMSC('CP SP 083 TO DICOFILM RDR CLASS '//
     1          CLASS//' FORM '//FORM//' NAME '//FILEID,70,IERR)
           CALL DFXMSC('CP TAG 083 DIMFILM TAG FIELD',28,IERR)
C-------------------------------------
C    RESTORE MESSAGES IF THEY HAVE BEEN TURNED OFF
C    HOWEVER IF MULTIPLE DRIVERS ARE RUN COULD GET PROBLEMS
C    PROBABLY BEST TO LEAVE AS SET BY/FOR USER
C     CALL CMSCMD('CP SET IMSG ON',14)
C-------------------------------------
           CALL DFXMSC('CP SP 083 CLOSE',15,IERR)
           CALL DFXMSC('CP DETACH 083',13,IERR)
C
           IF (IERR.NE.0) CALL DFXMSA(IERR)
      ENDIF
C    AT TERMINATION MUST CANCEL USETAPE - IF SUBSEQUENT
C    OPEN OF DEVICE USER MUST RESPECIFY USETAPE
C    (NECESSARY TO AVOID OVERWRITING TAPE/FILE)
  999 UTFLAG(NWS) = 0
      UTVSN(NWS) = '0'
      USETPE = .FALSE.
      FTCHAN = .FALSE.
      RETURN
      END
