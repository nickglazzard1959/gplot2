*DECK CMSD25 F
      SUBROUTINE DFXD25(IF,XARG,YARG,ZARG,NARG)
C    S6100 DEVICE DRIVER FOR SIGMA 6100 SERIES TERMINALS
C    UTILISING SIGMA 6100 SERIES 7-BIT PROTOCOL
C    CMS REQUIRES 200+4 BYTE BUFFER
C
C    DRIVER VERSION IS OF FORM NN.N
C
      CHARACTER*4 DVERSN
      PARAMETER (DVERSN=' 0.1')
      REAL XARG(*),YARG(*),ZARG(*)
      INTEGER NARG(*)
      PARAMETER (XDCMAX=1447.,YDCMAX=1023.)
C    USES DFX25A,B,C FOR I/O
*CALL,DFXPAB
*CALL,DFXCBA
*CALL,DFXCBD
*CALL,DFXCBF
*CALL,DFXCAC
*CALL,DFXCAD
*CALL,DFXC04
*CALL,DFXC05
*CALL,DFXC17
*CALL,DFXC24
*CALL,DFXCBE
*CALL,DFXCP0
*CALL,MVSK01
*CALL,DFXC00
C    SIZBUF IS OUTPUT BUFFER SIZE IN BYTES
C    MAXBUF IS MAXIMUM AVAILABLE 7 BIT INSTRUCTIONS
C    BUFFPT POINTS TO NEXT AVAILABLE 7 BIT INSTRUCTION
C      NOTE - 0 POINTS TO FIRST INSTRUCTION (BUFFER ARRAY STARTS AT 0)
C    BUFF IS DATA BUFFER, AS ARRAY STARTING AT ZERO
C    LOPFA IS USED TO INDICATE (IN CONJUNCTION WITH WSDSE) LAST OP
C    BEING FRAME ADVANCE - IT IS ONLY SET FALSE BY BUFFER OUTPUT THAT
C    DOES NOT SET WSDSE AS FALSE
      LOGICAL LOPFA
      INTEGER SIZBUF,MAXBUF,BUFFPT
      INTEGER MW,SS,MWLAST,SSLAST
      PARAMETER (SIZBUF=204,MAXBUF=(SIZBUF-4)/2,MAXCNT=14)
      PARAMETER (LENBUF=(SIZBUF/2)-1)
      INTEGER*2 BUFF(0:LENBUF)
      SAVE
      INTEGER*2 BYTE2(2),BYTE22
      INTEGER BYTE4
      EQUIVALENCE (BYTE4,BYTE2),(BYTE2(2),BYTE22)
C    VS FORTRAN DOES NOT PERMIT INTEGER*2 ARGUMENTS IN IOR AND ISHFT
C    CONSEQUENTLY EQUIVALENCING IS USED TO GET VALUES INTO RBUFF
C    (WHICH IS INTEGER*2) - THEREBY AVOIDING SIGN EXTENSION
C    ALSO AVOIDS COMPILATION TIME EVALUATION OF I*2 = I*4 WITH
C    OVER/UNDERFLOW AND SUBSTITUTION OF MAXIMUM POSITIVE/NEGATIVE
C    VALUE (ERROR 1788(W)).
C   WSCL IS PRE-CLIPPING RECTANGLE IN DC (E.G. FOR PIXEL ARRAYS)
C   WSBL IS PRE-BLANKING RECTANGLE IN DC (E.G. FOR PIXEL ARRAYS)
      REAL WSCL(4),WSBL(4)
C   CELL ARRAY IS STORED LOCALLY WHEN FIRST USED
C   XRAST,YRAST HOLD   0 - START/CURRENT SCAN LINE
C                      1 - LOWER LIMITS OF CELL ARRAY IN DC UNITS
C                      2 - UPPER LIMITS OF CELL ARRAY IN DC UNITS
C                      3 - END OF SCAN LINES
      REAL XRAST(0:3),YRAST(0:3)
C   CELOUT IS SET TRUE IF CELL AREA IS WHOLLY INVISIBLE
C   (FOR LINE MODE IS SET ON INITIAL ENTRY AND USED ON SUBSEQUENT ONES)
C    BLANK IS SET TRUE IF LCAP(2) IS TRUE AND BLANKING IS POSSIBLE
C    LRUN IS LOCAL FLAG FOR ACTUAL RUN LENGTH OR EVERY ELEMENT OUTPUT
      LOGICAL CELOUT,BLANK,LRUN
C    ISR IS SHIFTS FOR CMS PIXEL DATA IN SCAN
      INTEGER ISR(4),LCC(2)
      REAL Z3(3)
      LOGICAL LCOL,RASTEX
C
C    LOOK UP TABLE VALUES STORED IN COMPRESSED FORMAT
C    0-255 ENTRIES    FOR R,G,B,B/W
      PARAMETER (MAXLUT=255)
      INTEGER S61LUT(4,0:63)
C    SET DEVICE DEFAULT ROTATION  0-COMIC, 1- CINE
      INTEGER DEFROT
      PARAMETER (DEFROT=0)
      CHARACTER*160 RECORD
      SAVE
C    FUNCTION TO ROUND UP POSITIVE REALS INTO AN INTEGER
      IRNDUP(RX) = INT(RX+1) - INT(FLOAT(INT(RX+1))-RX)
C------------------------------------------------------------------
C
C    ULCC FILM STACKER (CMS) HEADER - VERSION DFILMCMS  0a
C
C    LENGTH 160 BYTES
C
C                              ............26 JUNE 1990
C
C    1-10        HEADER LEVEL:DFILMCMS0a
C   11-40        PLOT SOFTWARE INFORMATION
C         11-17     PRODUCT NAME
C            19     V
C         20-24     VERSION AS NN.NA (NO LEADING BLANKS)
C         26-35     DRIVER NAME (RIGHT JUSTIFIED)
C            36     :
C         37-40     DRIVER VERSION AS NN.N OR N.NA
C                          (LEADING BLANK PERMITTED)
C   41-50        ACCOUNT NUMBER OR JOB NAME
C   51-60        JES (OR OTHER) SYSTEM JOB IDENTIFIER
C   61-70        TIME OF START OF JOB ( HH:MM:SS )
C   71-80        DATE OF START OF JOB ( DD/MM/YY )
C   81-100       MACHINE TYPE
C  101-120       OPERATING SYSTEM
C  121-140       USER COMMENT FIELD (DEFAULT FROM JOB STATEMENT)
C  141-150       INPUT SITE NAME (BLANK IF UNKNOWN)
C  151-160       OUTPUT SITE NAME (BLANK IF UNKNOWN)
C
C------------------------------------------------------------------
      DATA RECORD(1:10)/'DFILMCMS0a'/
      DATA RECORD(11:40)/'DIMFILM V*****  S6000-D25:****'/
      DATA RECORD(41:160)/' '/
      X = XARG(1)
      Y = YARG(1)
      Z = ZARG(1)
      N = NARG(1)
      IF (IF.LE.0) GO TO 1000
      IF (IF.EQ.4) GO TO 1
      IF (IF.LT.4) GO TO 3
      IF (IF.EQ.10) GO TO 10
      IF (IF.GT.100) GO TO 100
C    IGNORE ALL OTHER ENTRIES
      GO TO 9999
C
C    IF = 1 POINT PLOT, IF = 2 OFF MOVE
    3 XD = XDCO + X*DSCALE
      YD = YDCO + Y*DSCALE
      PPD = VPAPPD(0)
      IF (IF.EQ.2) GO TO 4
      IF (N.EQ.0) GO TO 4
      PPD = VPAPPD(1)
      SS = MAX(1,MIN(INT(SFSPOT(ICOLPT(IRGBN))+.5),15))
      IF (SS.NE.SSLAST) THEN
                      BYTE4 = IOR(OPSS,SS)
                      RBUFF(BUFFPT) = BYTE22
                      BUFFPT = BUFFPT + 1
                      IF (BUFFPT.EQ.MAXBUF)
     1                CALL DFX01B(RBUFF,BUFFPT,DTYPE)
                      SSLAST = SS
      ENDIF
      GO TO 2
C    IF = 4 ON MOVE
    1 XD = XDCO + X*DSCALE
      YD = YDCO + Y*DSCALE
      PPD = VPAPPD(2)
    2 IF (.NOT.DEVCOL(NWS)) GO TO 4
      II = ICOLPT(IRGBN)
      MW = MAX(1,MIN(INT(SFLIN(II)+.5),15))
C   ACCOUNT FOR POSSIBILITY OF LOOK UP TABLE
      NC = NLUT(II)
      IF (NC.LT.0) THEN
                      Z = ZINT(II)*ZRGB(II)
                      IZ = IAND(INT(Z*255.+.5),M8)
      ELSE
                      IF (NC.GT.MAXLUT) NC = 1
C    INVALID LUT POINTER ACCESSES FOREGROUND
                      IW = NC/4
                      IZ = IAND(ISHFT(D48LUT(4,IW),-8*(3-(NC-IW*4))),M8)
      ENDIF
C    IF TRANSITION FROM OFF TO ON MUST POSITION
      IF (RGB0.AND.IZ.NE.0) THEN
      DOICS = (CURHVI.NE.HVIV)
      IF (DOICS) THEN
            CURHVI = HVIV
            ICSSET = .TRUE.
            ICSMSK = IOR(ICSMSK,MHVI)
            ICSVAL = IOR(IAND(ICSVAL,NOT(MHVI)),ISHFT(CURHVI,5))
C    SET VECTOR HVI
                   IF (BUFFPT+3.GE.MAXBUF)
     1             CALL DFX01B(RBUFF,BUFFPT,DTYPE)
                   BYTE4 = IOR(OP0,ECS6)
                   RBUFF(BUFFPT) = BYTE22
                   BYTE4 = IOR(MCUICS,MHVI)
                   RBUFF(BUFFPT+1) = BYTE22
                   RBUFF(BUFFPT+2) = ISHFT(CURHVI,5)
                   BUFFPT = BUFFPT + 3
      ENDIF
                          IF ((BUFFPT+3).GE.MAXBUF)
     1                        CALL DFX01B(RBUFF,BUFFPT,DTYPE)
                          BYTE4 = IOR(OP2,VPAPPD(0))
                          RBUFF(BUFFPT) = BYTE22
                          RBUFF(BUFFPT+1) = INT(XDLAST+.5)
                          RBUFF(BUFFPT+2) = INT(YDLAST+.5)
                          BUFFPT = BUFFPT + 3
      ENDIF
      RGB0 = IZ.EQ.0
      IF (.NOT.RGB0) THEN
                BYTE4 = IOR(OP6,IZ)
                RBUFF(BUFFPT) = BYTE22
                BUFFPT = BUFFPT + 1
                IF (BUFFPT.EQ.MAXBUF) CALL DFX01B(RBUFF,BUFFPT,DTYPE)
C    IF BEAM ON MUST SET LINE MULTI-WIDTH IF RELEVANT
                IF (MW.NE.MWLAST) THEN
                     BYTE4 = IOR(OPMW,MW)
                     RBUFF(BUFFPT) = BYTE22
                     BUFFPT = BUFFPT + 1
                     IF (BUFFPT.EQ.MAXBUF)
     1               CALL DFX01B(RBUFF,BUFFPT,DTYPE)
                     MWLAST = MW
                ENDIF
      ENDIF
      DEVCOL(NWS) = .FALSE.
    4 IF (MODE.NE.VECTOR) THEN
C                   SELECT VECTOR MODE
                              MODE = VECTOR
                              BYTE4 = IOR(OP0,MODE)
                              RBUFF(BUFFPT) = BYTE22
                              BUFFPT = BUFFPT + 1
                              IF (BUFFPT.EQ.MAXBUF)
     1                        CALL DFX01B(RBUFF,BUFFPT,DTYPE)
      ENDIF
      DOICS = (CURHVI.NE.HVIV)
      IF (DOICS) THEN
            CURHVI = HVIV
            ICSSET = .TRUE.
            ICSMSK = IOR(ICSMSK,MHVI)
            ICSVAL = IOR(IAND(ICSVAL,NOT(MHVI)),ISHFT(CURHVI,5))
C    SET VECTOR HVI
                   IF (BUFFPT+3.GE.MAXBUF)
     1             CALL DFX01B(RBUFF,BUFFPT,DTYPE)
                   BYTE4 = IOR(OP0,ECS6)
                   RBUFF(BUFFPT) = BYTE22
                   BYTE4 = IOR(MCUICS,MHVI)
                   RBUFF(BUFFPT+1) = BYTE22
                   RBUFF(BUFFPT+2) = ISHFT(CURHVI,5)
                   BUFFPT = BUFFPT + 3
      ENDIF
      IF (RGB0) GO TO 10004
      IF ((BUFFPT+3).GE.MAXBUF)
     1            CALL DFX01B(RBUFF,BUFFPT,DTYPE)
      BYTE4 = IOR(OP2,PPD)
      RBUFF(BUFFPT) = BYTE22
      RBUFF(BUFFPT+1) = INT(XD+.5)
      RBUFF(BUFFPT+2) = INT(YD+.5)
      BUFFPT = BUFFPT + 3
10004 XDLAST = XD
      YDLAST = YD
      IF (PPD.EQ.VPAPPD(0)) GO TO 9999
C    DISPLAY SURFACE NON-EMPTY
 9998 WSDSE(NWS) = .FALSE.
 9999 IFLAST = IF
      RETURN
10032 RASTEX = .TRUE.
      GO TO 9999
C                PIXEL CODE
   10 CONTINUE
C    NPAR = 0 IS CELL ARRAY OPTION
C    NPAR > 0 IS LINE CELL  OPTION
      IF ((NPAR.GT.1).AND.(IFLAST.EQ.10).AND..NOT.RASTWN) THEN
C    IF CONTINUATION ENTRY FOR LINE CELL CHECK IF TOTALLY VALID
        IF (RASTEX) GO TO 9999
C    OR SEE IF OUT OF VALID RANGE
        IF (NPAR.GT.NRAST2) GO TO 10032
C    OR NOT YET INTO VALID RANGE
        IF (NPAR.LT.NRAST1) GO TO 9999
      ELSE
        IF (NPAR.GT.1) SYRAST0 = YRAST(0)
C    SAVE OLD Y-COORDINATE - FOR REPOSITIONING
        IF (RASTWN) THEN
        RASTEX = .FALSE.
C    CONVERT CLIP AREA TO WS DC
        WSCL(1) = XDCO + NDCL(1)*DSCALE
        WSCL(2) = XDCO + NDCL(2)*DSCALE
        WSCL(3) = YDCO + NDCL(3)*DSCALE
        WSCL(4) = YDCO + NDCL(4)*DSCALE
        IF (LPAR(2)) THEN
C    CONVERT BLANKING AREA TO WS DC (IF APPLICABLE AND NOT SEGMENT)
             WSBL(1) = XDCO + NDBL(1)*DSCALE
             WSBL(2) = XDCO + NDBL(2)*DSCALE
             WSBL(3) = YDCO + NDBL(3)*DSCALE
             WSBL(4) = YDCO + NDBL(4)*DSCALE
        ENDIF
C    CONVERT CELL ARRAY AREA TO WS DC
C    (NO TRANSFORMATION CURRENTLY PERMITTED)
        XRAST(1) = XDCO + XPAR(1)*DSCALE
        XRAST(2) = XDCO + XPAR(2)*DSCALE
        YRAST(1) = YDCO + YPAR(1)*DSCALE
        YRAST(2) = YDCO + YPAR(2)*DSCALE
C    NOW GET SCAN IN WS DC (CURRENTLY NO TRANSFORMATION)
C
C
C    ALLOW FOR PRECLIPPING IN GETTING START/END POSITIONS
C    DO HORIZONTAL SCANS FIRST
        CELOUT = .TRUE.
C    COMBINE WITH CHECK ON VALIDITY AFTER CLIPPING
        IF (XRAST(1).LE.XRAST(2)) THEN
C    LEFT TO RIGHT
             ISCAN = 0
             XRAST(0) = MAX(XRAST(1),WSCL(1))
             XRAST(3) = MIN(XRAST(2),WSCL(2))
C    FORCE XRAST(0) TO NEXT ADDRESSABLE (VECTOR) POINT (L TO R)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING
             IX0 = IRNDUP(XRAST(0))
             XRAST(0) = IX0
             IF (XRAST(0).GT.XRAST(3)) GO TO 10032
             X1 = XRAST(0)
             X2 = XRAST(3)
        ELSE
C    RIGHT TO LEFT
             ISCAN = 1
             XRAST(0) = MIN(XRAST(1),WSCL(2))
             XRAST(3) = MAX(XRAST(2),WSCL(1))
C    FORCE XRAST(0) TO LAST ADDRESSABLE (VECTOR) POINT (R TO L)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING (FROM R)
             IX0 = XRAST(0)
             XRAST(0) = IX0
             IF (XRAST(3).GT.XRAST(0)) GO TO 10032
             X1 = XRAST(3)
             X2 = XRAST(0)
        ENDIF
C    THEN DO VERTICAL SCAN
        IF (YRAST(1).LE.YRAST(2)) THEN
C    TOP TO BOTTOM
             YRAST(0) = MIN(YRAST(2),WSCL(4))
             YRAST(3) = MAX(YRAST(1),WSCL(3))
C    FORCE YRAST(0) TO LAST ADDRESSABLE (VECTOR) POINT (T TO B)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING (FROM T)
             IY0 = YRAST(0)
             YRAST(0) = IY0
             IF (YRAST(3).GT.YRAST(0)) GO TO 10032
             Y1 = YRAST(3)
             Y2 = YRAST(0)
        ELSE
C    BOTTOM TO TOP
             ISCAN = ISCAN + 2
             YRAST(0) = MAX(YRAST(2),WSCL(3))
             YRAST(3) = MIN(YRAST(1),WSCL(4))
C    FORCE YRAST(0) TO NEXT ADDRESSABLE (VECTOR) POINT (B TO T)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING
             IY0 = IRNDUP(YRAST(0))
             YRAST(0) = IY0
             IF (YRAST(0).GT.YRAST(3)) GO TO 10032
             Y1 = YRAST(0)
             Y2 = YRAST(3)
        ENDIF
C    X1 = MIN(XRAST(0),XRAST(3))
C    X2 = MAX(XRAST(0),XRAST(3))
C    Y1 = MIN(YRAST(0),YRAST(3))
C    Y2 = MAX(YRAST(0),YRAST(3))
C    NOW CHECK VALIDITY OF AREA AGAINST BLANKING (IF ANY)
        BLANK = LPAR(2)
        IF (LPAR(2)) THEN
          IF ((X1.GE.WSBL(1)).AND.(X2.LE.WSBL(2)).AND.
     1    (Y1.GE.WSBL(3)).AND.(Y2.LE.WSBL(4))) GO TO 10032
C    NOT TOTALLY OCCLUDED, SO CHECK FOR ANY POSSIBLE BLANKING
          IF ((X1.GT.WSBL(2)).OR.(X2.LT.WSBL(1)).OR.
     1    (Y1.GT.WSBL(4)).OR.(Y2.LT.WSBL(3))) BLANK = .FALSE.
        ENDIF
        CELOUT = .FALSE.
C***********SET SCAN DIRECTION***********
        IF (NPAR.GT.0) THEN
C    FOR SETUP GET VALID LINE RANGE
             DYRAST = (YRAST(1)-YRAST(2))/FLOAT(IPAR(6))
             NRAST1 = INT((YRAST(0)-YRAST(2))/DYRAST) + 1
             NRAST2 = INT((YRAST(3)-YRAST(2))/DYRAST) + 1
        ENDIF
C
        ENDIF
        DOMODE = (MODE.NE.RASTER)
        HVIR= HVI(ISCAN,DROT)
        DOICS = (CURHVI.NE.HVIR)
        IF (DOICS) THEN
            CURHVI = HVIR
            ICSSET = .TRUE.
            ICSMSK = IOR(ICSMSK,MHVI)
            ICSVAL = IOR(IAND(ICSVAL,NOT(MHVI)),ISHFT(CURHVI,5))
        ENDIF
        IXR = IX0
        IYR = IY0
        IF (NPAR.GT.1) THEN
           IF (RASTWN) THEN
C   IF A NEW WINDOW THEN ONLY RESET POSITION IF THIS
C   LINE IS VISIBLE - ELSE LEAVE POSITION AS THAT OF
C   FIRST UNCLIPPED LINE
               IF (NPAR.GE.NRAST1) THEN
                 IYR = SYRAST0
                 YRAST(0) = SYRAST0
               ENDIF
           ELSE
               IYR = SYRAST0
               YRAST(0) = SYRAST0
C    SET Y-POSITION AND RESTORE POSITION REACHED
           ENDIF
        ENDIF
C   CLEAR RASTWN FLAG
        RASTWN = .FALSE.
        IF (HVIV.NE.HVIR) THEN
C    MUST GET COODINATES IN NEW ICS REFERENCE SYSTEM
C
C STEP 1: IGNORE INTERCHANGE AND REDUCE TO H,V NORMAL FOR VECTOR SYSTEM
C
C       NEGATE H-REVERSE
           IF (IAND(ISHFT(HVIV,-2),1).EQ.1) IXR = 32767 - IX0
C       NEGATE V-REVERSE
           IF (IAND(ISHFT(HVIV,-1),1).EQ.1) IYR = 32767 - IY0
C
C       IF VECTOR AND RASTER HAVE SAME INTERCHANGE CAN SKIP SWITCH
C
           IF (IAND(HVIV,1).NE.IAND(HVIR,1)) THEN
C STEP 2: PERFORM INTERCHANGE (LEAVING H,V NORMAL FOR RASTER SYSTEM)
                   IXS = IXR
                   IXR = 32767 - IYR
                   IYR = 32767 - IXS
           ENDIF
C
C STEP 3: NOW IN RASTER SYSTEM, BUT H,V NORMAL SO PERFORM ANY REVERSE
C
C       PERFORM H-REVERSE
           IF (IAND(ISHFT(HVIR,-2),1).EQ.1) IXR = 32767 - IXR
C       PERFORM V-REVERSE
           IF (IAND(ISHFT(HVIR,-1),1).EQ.1) IYR = 32767 - IYR
C
        ENDIF
C
C    IF PIXSIZ REQUIRES SPECIFICATION AND HAVE ALREADY GENERATED
C    RASTER OPS NO NEED TO DO RESET FOR B/W DEVICE (SINGLE STREAM)
C
        IF (DOMODE) THEN
C                   SELECT RASTER MODE
                          MODE = RASTER
                          BYTE4 = IOR(OP0,MODE)
                          RBUFF(BUFFPT) = BYTE22
                          BUFFPT = BUFFPT + 1
                          IF (BUFFPT.EQ.MAXBUF)
     1                    CALL DFX01B(RBUFF,BUFFPT,DTYPE)
        ENDIF
        IF (DOICS) THEN
C    SET RASTER HVI - NOTING THIS MUST BE BEFORE POSITIONING
                   IF (BUFFPT+3.GE.MAXBUF)
     1             CALL DFX01B(RBUFF,BUFFPT,DTYPE)
                   BYTE4 = IOR(OP0,ECS6)
                   RBUFF(BUFFPT) = BYTE22
                   BYTE4 = IOR(MCUICS,MHVI)
                   RBUFF(BUFFPT+1) = BYTE22
                   RBUFF(BUFFPT+2) = ISHFT(HVIR,5)
                   BUFFPT = BUFFPT + 3
        ENDIF
C    FORCE POSITION TO START OF SCAN
C       NOTE - USING COORDINATES IN RASTER HVI SYSTEM
        IF ((BUFFPT+3).GE.MAXBUF)
     1                    CALL DFX01B(RBUFF,BUFFPT,DTYPE)
        BYTE4 = IOR(OP2,VPAPPD(0))
        RBUFF(BUFFPT) = BYTE22
        BYTE4 = IAND(IXR,M15)
        RBUFF(BUFFPT+1) = BYTE22
        BYTE4 = IAND(IYR,M15)
        RBUFF(BUFFPT+2) = BYTE22
        BUFFPT = BUFFPT + 3
C    NOW DO OP5 INSTRUCTION IF NECESSARY
        IF (PIXSIZ) THEN
               IF ((BUFFPT+3).GE.MAXBUF)
     1                  CALL DFX01B(RBUFF,BUFFPT,DTYPE)
               BYTE4 = IOR(40960,IOR(ISHFT(IHES,6),IHPS))
               RBUFF(BUFFPT) = BYTE22
               BYTE4 = IOR(ISHFT(IVES,6),IVPS)
               RBUFF(BUFFPT+1) = BYTE22
               BYTE4 = IOR(ISHFT(IHPE,4),IVPE)
               RBUFF(BUFFPT+2) = BYTE22
               BUFFPT = BUFFPT + 3
        ENDIF
        IF (NPAR.GT.0) THEN
C    IF TOTALLY OUTSIDE RANGE EXIT WITH FLAG SETR
             IF (NPAR.GT.NRAST2) GO TO 10032
C    IF NOT YET IN RANGE EXIT
             IF (NPAR.LT.NRAST1) GO TO 9999
        ENDIF
      ENDIF
      PIXSIZ = .FALSE.
C    NOW GET LINE BY LINE RASTER SCAN
      HRAST = HESDC
      VRAST = VESDC
      XRAST0 = XRAST(0)
      YRAST0 = YRAST(0)
      XRAST1 = XRAST(1)
      YRAST1 = YRAST(1)
      XRAST2 = XRAST(2)
      YRAST2 = YRAST(2)
      XRAST3 = XRAST(3)
      YRAST3 = YRAST(3)
C    (NOTE - XRAST0,YRAST0 NEED NOT BE IDENTICAL WITH XRAST1,YRAST1
C          - CLIPPING MAY REQUIRE SUBAREA ONLY TO BE DISPLAYED)
 
      LCOL = .FALSE.
C    FOR B/W DEVICE OUTPUT RASTER ALWAYS MONOCHROME
C
C    FLAG AS INITIAL SET UP
      IVSC = 0
C
10020 CALLDFX01F(XARG,YARG,ZARG,NARG,IPAR(1),IPAR(2),D48LUT,MAXLUT,LCOL,
     1    BLANK,WSBL)
C    SAVE NEXT SCAN LINE POSITION
      YRAST(0) = YRAST0
C    SKIP IF INVALID RETURN
      IF (IVSC.LE.0) GO TO 9999
C         HERE FOR RASTER OPERATIONS
C    PERFORM OPS FOR EACH FILTER
      II = 4
      RGB0 = .TRUE.
C    CHECK RUN LENGTH
      LRUN = RUN
      IF (.NOT.LRUN) THEN
C    NOT GLOBAL RUN LENGTH SO DO QUICK CHECK
C    IF SAVE MORE THAN HALF SCAN LENGTH BY COMPRESSION THEN GO AND
C    DO RUN LENGTH IMMEDIATELY
          NRLIM = (IHSC+1)/2
          NR = 0
          NLC = -1
          DO 10013 J=1,IHSC
          LC = IAND(ISHFT(SCAN(J),-ISR(II)),M8)
          IF (LC.EQ.NLC) THEN
                NR = NR + 1
                IF (NR.GE.NRLIM) THEN
                    LRUN = .TRUE.
                    GO TO 10014
                ENDIF
          ELSE
                NLC = LC
          ENDIF
10013     CONTINUE
      ENDIF
10014     CONTINUE
C    CLEAR ARRAY LSCAN TO ZERO
      DO 10015 J=1,2052
10015 LSCAN(J) = 0
C    SET OP CODE 1
      BYTE4 = OP1
      LSCAN(1) = BYTE22
      IF (LRUN) THEN
C    IF RUN-LENGTH FOR THIS COLOUR THEN
C    SET FUNCTION CODE 7
          BYTE4 = FN7
          LSCAN(2) = BYTE22
C    COMPRESS INTO LSCAN
          IW = 3
C    IW IS CURRENT WORD IN LSCAN
          KOUNT = 0
C    KEEP COUNT OF 16-BIT ELEMENTS BUILT
          NLC = IAND(ISHFT(SCAN(1),-ISR(II)),M8)
          NR = 0
          DO 10016 J=1,IHSC
          LC = IAND(ISHFT(SCAN(J),-ISR(II)),M8)
          IF (RUN) THEN
             NR1 = RSCAN(J)
          ELSE
             NR1 = 1
          ENDIF
          IF (LC.EQ.NLC) THEN
             NR = NR + NR1
          ELSE
             IF (NR.GE.256) THEN
                   NN = NR/256
                   DO 10017 K=1,NN
C               RUN-LENGTH ZERO IS SPECIAL CASE OF 256
                   LSCAN(IW) = NLC
                   KOUNT = KOUNT + 1
                   IW = IW + 1
                   NR = NR - 256
10017              CONTINUE
             ENDIF
             IF (NR.GT.0) THEN
               BYTE4 = IOR(ISHFT(NR,8),NLC)
               LSCAN(IW) = BYTE22
               KOUNT = KOUNT + 1
               IW = IW + 1
             ENDIF
             NLC = LC
             NR = NR1
          ENDIF
10016     CONTINUE
C    DO OUTSTANDING PIXELS
          IF (LC.EQ.0) THEN
C        IF ZERO DO NOT SCAN (UNLESS TOTALLY ZERO LINE WHEN DO 1 ZERO
C        (MAY WISH TO INSTATE SCAN IF ZERO EXPOSURE ENABLED?)
                   IF (KOUNT.EQ.0) THEN
                         KOUNT = 1
                         BYTE4 = ISHFT(1,8)
                         LSCAN(IW) = BYTE22
                         IW = IW + 1
                   ENDIF
           ELSE
                   IF (NR.GE.256) THEN
                         NN = NR/256
                         DO 10018 K=1,NN
C                    RUN-LENGTH ZERO IS SPECIAL CASE OF 256
                         LSCAN(IW) = NLC
                         KOUNT = KOUNT + 1
                         IW = IW + 1
                         NR = NR - 256
10018                    CONTINUE
                   ENDIF
                   IF (NR.GT.0) THEN
                          BYTE4 = IOR(ISHFT(NR,8),NLC)
                          LSCAN(IW) = BYTE22
                          KOUNT = KOUNT + 1
                          IW = IW + 1
                   ENDIF
          ENDIF
      ELSE
C    NOT RUN LENGTH ENCODED
C    SET FUNCTION CODE 1
          BYTE4 = FN1
          LSCAN(2) = BYTE22
          IW = 3
          IS = 1
C    (IW IS CURRENT WORD IN LSCAN, IS IS CURRENT BYTE POINTER))
          KOUNT = 0
C    KEEP COUNT OF 8-BIT ELEMENTS BUILT (KOUNT IS LAST ENCOUNTERED
C                                        NON-ZERO ELEMENT)
          DO 10019 J=1,IHSC
          LC = IAND(ISHFT(SCAN(J),-ISR(II)),M8)
          IF (LC.NE.0) KOUNT = J
          LCC(IS) = LC
          BYTE4 = LSCAN(IW)
          BYTE4 = IOR(BYTE4,ISHFT(LC,IS))
          LSCAN(IW) = BYTE22
          IS = IS +1
          IF (IS.EQ.3) THEN
                      BYTE4 = IOR(LCC(2),ISHFT(LCC(1),8))
                      LSCAN(IW) = BYTE22
                      IW = IW + 1
                      IS = 1
          ENDIF
10019     CONTINUE
C     ENSURE LAST ELEMENT FLUSHED
          IF (IS.NE.1) THEN
                      BYTE4 = ISHFT(LCC(1),8)
                      LSCAN(IW) = BYTE22
C     INCREMENT IW SO ALWAYS POINTS AHEAD
                      IW = IW + 1
          ENDIF
C     ENSURE AT LEAST 1 ELEMENT
C        - IF TRAILING ZEROS REQUIRED SET KOUNT = IHSC
          KOUNT = MAX(1,KOUNT)
      ENDIF
C    ADD IN KOUNT
      BYTE4 = LSCAN(2)
      BYTE4 = IOR(BYTE4,KOUNT)
      LSCAN(2) = BYTE22
10021 CONTINUE
C
C    GET WORD COUNT TO TRANSFER
      IWC = IW - 1
C    NOW READY TO TRANSFER DATA TO OUTPUT BUFFER
C
      DO 10022 IREP=1,IVSC
      DO 10022 J=1,IWC
      RBUFF(BUFFPT) = LSCAN(J)
      BUFFPT = BUFFPT + 1
      IF (BUFFPT.EQ.MAXBUF)CALL DFX01B(RBUFF,BUFFPT,DTYPE)
10022 CONTINUE
C
C    SET RASTER FLAG
C
      RAST = .TRUE.
      WSDSE(NWS) = .FALSE.
C
C    NOW CHECK IF CELL ARRAY COMPLETE
C
      IF (NPAR.EQ.0) THEN
C        SET IVSC FOR CONTINUATION ENTRY
            IVSC = -1
            IF (ISCAN.LE.1) THEN
C          TOP TO BOTTOM
                  IF (YRAST0.GE.YRAST3) GO TO 10020
            ELSE
C          BOTTOM TO TOP
                  IF (YRAST0.LE.YRAST3) GO TO 10020
            ENDIF
      ENDIF
      GO TO 9998
  100 IF (IF.GT.200) GO TO 200
C     HERE FOR 101-199
C
      IF (IF.EQ.101) THEN
C
C    101 IS GLOBAL LUT ENTRY (BLOCK)
C
         J1 = MAX(0,NARG(1))
         J2 = MIN(NARG(2),MAXLUT)
         IF (J1.LE.J2) THEN
              DO 10034 I=J1,J2
              IW = I/4
              IBS = 8*(3 - (I - IW*4))
              DO 10035 J=1,3
              Z3(J) = RGBLUT(J,I)
              IZ = INT(Z3(J)*255.+.5)
10035         D48LUT(J,IW) = IOR(D48LUT(J,IW),ISHFT(IAND(IZ,M8),IBS))
              Z = DFX139(Z3(1),Z3(2),Z3(3))
              IZ = INT(Z*255.+.5)
10034         D48LUT(4,IW) = IOR(D48LUT(4,IW),ISHFT(IAND(IZ,M8),IBS))
              DEVCOL(NWS) = .TRUE.
         ENDIF
      ELSE IF (IF.EQ.102) THEN
C
C    102 IS LUT ENTRY (BLOCK) FROM ARGUMENTS
C
         J1 = MAX(0,NARG(1))
         J2 = MIN(NARG(2),MAXLUT)
         IF (J1.LE.J2) THEN
              DO 10036 I=J1,J2
              IW = I/4
              IBS = 8*(3 - (I - IW*4))
              Z3(1) = XARG(I)
              Z3(2) = YARG(I)
              Z3(3) = ZARG(I)
              DO 10037 J=1,3
              IZ = INT(Z3(J)*255.+.5)
10037         D48LUT(J,IW) = IOR(D48LUT(J,IW),ISHFT(IAND(IZ,M8),IBS))
              Z = DFX139(Z3(1),Z3(2),Z3(3))
              IZ = INT(Z*255.+.5)
10036         D48LUT(4,IW) = IOR(D48LUT(4,IW),ISHFT(IAND(IZ,M8),IBS))
              DEVCOL(NWS) = .TRUE.
         ENDIF
      ENDIF
      GO TO 9999
  200 IF (IF.NE.204) GO TO 9999
C     HERE FOR 204
C
  204 XD = X + XDCOR0
      YD = Y + YDCOR0
      IF (N.EQ.0) THEN
                      PPD = VPAPPD(0)
                      GO TO 4
                  ELSE
                      PPD = VPAPPD(2)
                      GO TO 2
      ENDIF
 1000 II = -IF
C       -1000 OR LOWER ARE SPECIAL ACTIONS
      IF (II.GE.1000) GO TO 2000
      GO TO (1001,1002,1003,1004),II
C    OPEN PLOT FILE
C**************************************
C
C     IF RECORD USED MUST USE NEW ULCC CMS VERSION
C
C     PROBABLY IRRELEVANT FOR INTERACTIVE SIGMA JOB
C     BUT IF BATCH?????
C
C*************************************
 1001 CALL DFXMS3(RECORD(41:48))
      CALL DFXMS4(RECORD(51:58))
      CALL DFXMS2(RECORD(62:69))
      CALL DFXMS1(RECORD(72:79))
      CALL DFXMS8(RECORD(81:100))
      CALL DFXMS5(RECORD(101:120))
      CALL DFXMS9(RECORD(121:140))
C    INPUT SITE FIXED AS ULCC
      RECORD(141:150) = 'ULCC'
C    PLUG DIMFILM VERSION/LEVEL
      RECORD(20:24) = VERSN
C    PLUG DEVICE DRIVER VERSION
      RECORD(37:40) = DVERSN
      DO 10008 I=0,LENBUF
10008 RBUFF(I) = 0
      FRAMES = 0
      J = -1
      DO 10000 I=1,160,2
      J = J + 1
      RBUFF(J) = 0
      NC1 = MAX(0,DFXM01(RECORD(I:I))) + 31
      NC2 = MAX(0,DFXM01(RECORD(I+1:I+1))) + 31
      BYTE4 = IOR(ISHFT(NC1,8),NC2)
10000 RBUFF(J) = BYTE22
      CALL DFX01A(FORMID,500000,RECORD,RBUFF,IFAIL)
C    SET 4-BYTE FORM ID, LINE LIMIT, GET ERROR CONDITION
      IF (IFAIL.EQ.0) GO TO 10001
C    GKS ERROR 21 24 26 POSSIBLE
      GKSERR = 26
      GO TO 9999
10001 RAST = .FALSE.
C     SET LUT AT OPEN TO DIMFILM DEFAULT LUT
C
C     CLEAR LUT
      DO 10033 J=0,63
      DO 10033 I=1,4
10033 D48LUT(I,J) = 0
C
      JJ = MIN(MAXLUT,LUTSIZ-1)
      DO 10023 I=0,JJ
      IW = I/4
      IBS = 8*(3 - (I - IW*4))
      DO 10024 J=1,3
      Z3(J) = RGBLUT(J,I)
      IF (I.EQ.0) Z3(J) = 0.0
      IF (I.EQ.1) Z3(J) = 1.0
C    AT OPENING 0,1 ARE DEVICE DEFAULT BACKGROUND/FOREGROUND ALWAYS
C    FOR DICOMED = BLACK, WHITE RESPECTIVELY
      IZ = INT(Z3(J)*255.+.5)
10024 D48LUT(J,IW) = IOR(D48LUT(J,IW),ISHFT(IAND(IZ,M8),IBS))
      Z = DFX139(Z3(1),Z3(2),Z3(3))
      IZ = INT(Z*255.+.5)
10023 D48LUT(4,IW) = IOR(D48LUT(4,IW),ISHFT(IAND(IZ,M8),IBS))
      PIXSIZ = .TRUE.
C    FORCE PIXEL DEFINITION, DEFAULT IS 2048X2048 WITH 2X2 ELEMENTS
C
C    HORIZONTAL/VERTICAL POINTS/ELEMENT = 2
C    HORIZONTAL/VERTICAL ELEMENT SPACING = 16 (=2 WITH 3 BINARY POINTS)
C    HORIZONTAL/VERTICAL POINT SPACING = 8 (=1 WITH 3 BINARY POINTS)
C
C    SPACING IN TERMS OF 4K RASTER DEVICE (N.B. VECTOR:RASTER RATIO 8:1)
C
      IHPE = 2
      IVPE = 2
      IHES = 16
      IHPS = 8
      IVES = 16
      IVPS = 8
      HESDC = IHES
      VESDC = IVES
C    ROTATION MODE IS COMIC FOR D35 BY DEFAULT
      DROT = DEFROT
      XDCOR0 = XDCORG
      YDCOR0 = YDCORG
      HVIV = HVI(2,DROT)
      CURHVI = HVIV
C    AT OPEN CLEAR ICS FLAGS
      ICSSET = .FALSE.
      ICSMSK = 0
      ICSVAL = 0
      BUFFPT = 0
      WSMDCS(1,NWS) = XDCMAX
      WSMDCS(2,NWS) = YDCMAX
      WSCAT(NWS) = 2
      WSDM(NWS) = 3
C    SET WS ID - SPECIFIC TO DEVICE
      WSID(NWS) = 01
      WSNAME(NWS) = 'D35'
C    SET UP DEFAULT WS TRANSFORMATION
      CWSWIN(1,NWS) = 0.0
      CWSWIN(2,NWS) = 1.0
      CWSWIN(3,NWS) = 0.0
      CWSWIN(4,NWS) = 1.0
      CWSVP(1,NWS) = 0.0
      CWSVP(2,NWS) = XDCMAX
      CWSVP(3,NWS) = 0.0
      CWSVP(4,NWS) = YDCMAX
      ASSIGN 1004 TO JUMP
      GO TO 10005
C    CLOSE DEVICE
 1002 IF (WSDSE(NWS).AND.LOPFA) GO TO 10002
      BYTE4 = IOR(OP0,FILMAD)
      RBUFF(BUFFPT) = BYTE22
      BUFFPT = BUFFPT + 1
      CALL DFX01B(RBUFF,BUFFPT,DTYPE)
      BYTE4 = FB18
      FLAG12 = BYTE22
      BYTE4 = FA
      CMNEM = BYTE22
      FRAMES = FRAMES + 1
      CPT = MAXCNT
      CALL DFX01B(CNTL,CPT,CTYPE)
      WSDSE(NWS) = .TRUE.
      LOPFA = .TRUE.
10002 BYTE4 = FB116
      FLAG12 = BYTE22
      BYTE4 = EJ
      CMNEM = BYTE22
      CPT = MAXCNT
      CALL DFX01B(CNTL,CPT,CTYPE)
      CALL DFX01C(RAST,IFAIL,NOBYTE)
      CFRAM = 'S'
      IF (FRAMES.EQ.1) CFRAM = ' '
      WRITE(ERRREC,10009) FRAMES,CFRAM
10009 FORMAT('**DIMFILM  -  DEVICE D35 TERMINATED  - ',I6,' FRAME',A)
      CALL DFX003(ERRREC(1))
      NB = NOBYTE
      CBYTE = ' BYTES'
      IF (NB.GE.1000000) THEN
                          NB = (NB-1)/1024 + 1
                          CBYTE = 'K BYTES'
      ENDIF
      IF (NB.GE.1000000) THEN
                          NB = (NB-1)/1024 + 1
                          CBYTE = 'M BYTES'
      ENDIF
      IF (NB.EQ.1) CBYTE(7:7) = ' '
      WRITE(ERRREC,10010) NB,CBYTE
10010 FORMAT('              QUEUED DATASET LENGTH  - ',I6,A)
      CALL DFX003(ERRREC(1))
      CALL DFX003('              CMS JOB IDENTIFIER - '//RECORD(51:58)) CMSD1007
      GKSERR = IFAIL
      GO TO 9999
C    FRAME ADVANCE
 1003 BYTE4 = IOR(OP0,FILMAD)
      RBUFF(BUFFPT) = BYTE22
      BUFFPT = BUFFPT + 1
      CALL DFX01B(RBUFF,BUFFPT,DTYPE)
      BYTE4 = FB18
      FLAG12 = BYTE22
      BYTE4 = FA
      CMNEM = BYTE22
      FRAMES = FRAMES + 1
      CPT = MAXCNT
      CALL DFX01B(CNTL,CPT,CTYPE)
      ASSIGN 9999 TO JUMP
10005 WSDSE(NWS) = .TRUE.
      LOPFA = .TRUE.
C    VECTOR/RASTER MODE UNSET AT BEGINNING OF EACH FRAME
10025 MODE = UNSET
C    AT FRAME ADVANCE/RESET MUST SEND ICS STATUS
                   BYTE4 = IOR(OP0,ECS6)
                   RBUFF(BUFFPT) = BYTE22
                   BYTE4 = IOR(MORICS,ICSMSK)
C              (MASK AGAINST ORIGINAL ICS - N.B. MORICS ACTUALLY ZERO)
                   RBUFF(BUFFPT+1) = BYTE22
                   BUFFPT = BUFFPT + 2
                   IF (ICSMSK.NE.0) THEN
C               HERE IF NOT RESETTING TO ORIGINAL
C
C               NOTE - ADDITIONAL OUTPUT WORD HERE
                          RBUFF(BUFFPT) = ICSVAL
                          BUFFPT = BUFFPT + 1
                   ENDIF
C    SET HERE TO FORCE LINE MULTI-WIDTH AND SPOT SIZE SELECTION VIA DDC
      MWLAST = -1
      SSLAST = -1
      RGB0 = .TRUE.
      DEVCOL(NWS) = .TRUE.
C    SHOULD ALSO SET BEAM POSITION, SPOT SIZE, LINE THICKNESS
C    BEAM POSITION IS SET BY DIMFILM AT FRAME ADVANCE
C    COLOUR IS FORCED AT F/A IN DFX000 VIA DEVCOL, MWLAST AND SSLAST
      GO TO JUMP,(1004,9999)
C    RESET DEVICE TRANSFORMATION
 1004 DSCALE = AMAX1((CWSVP(2,NWS)-CWSVP(1,NWS))
     1                       /(CWSWIN(2,NWS)-CWSWIN(1,NWS)),
     2    (CWSVP(4,NWS)-CWSVP(3,NWS))/(CWSWIN(4,NWS)-CWSWIN(3,NWS)))
      XDCO = CWSVP(1,NWS) - CWSWIN(1,NWS)*DSCALE + XDCOR0
      YDCO = CWSVP(3,NWS) - CWSWIN(3,NWS)*DSCALE + YDCOR0
C    THESE TRANSFORM VALUES YIELD D48 VALUES
      GO TO 9999
C    DEVICE SPECIFIC CODES COMMENCE AT -2001
 2000 II = II - 2000
      GO TO (2001,2002,2003,2004,2005,2006,2007),II
C
C    OPCODE -2001      FORCE FULL RESET ACTION
C
C     SET RETURN PATH - NO TRANSFORMATION RESET
 2001 ASSIGN 9999 TO JUMP
10028 IF (BUFFPT.NE.0) CALL DFX01B(RBUFF,BUFFPT,DTYPE)
      BYTE4 = FB14
      FLAG12 = BYTE22
      BYTE4 = RS
      CMNEM = BYTE22
      CPT = MAXCNT
      CALL DFX01B(CNTL,CPT,CTYPE)
C    GO DO BUFFER INITIALISATIONS AND RETURN
C    (NOTE ENTRY 2001 RESULTS IN DIRECT RETURN, ALTERNATE PATHS
C     EXIST FOR ENTRIES VIA 10028 E.G. FROM DEVICE ROTATION,
C     PIXEL SIZE SPECIFICATION OP)
      GO TO 10025
C
C    OPCODE -2002      FORCE PARTIAL RESET ACTION
C
 2002 MODE = UNSET
      MWLAST = -1
      SSLAST = -1
      RGB0 = .TRUE.
      PIXSIZ = .TRUE.
C
C    OPCODE -2003      SELECT DEVICE ROTATION
C
 2003 IF (DROT.EQ.N) GO TO 9999
C    ONLY ACCEPT VALID CALL AFTER OPEN OF THIS WS
      IF (N.NE.0.OR.N.NE.1) GO TO 9999
C    RESET ALL CWSWIN/VP THEN SET FOR SPECIFIC ROTATION
      CWSWIN(1,NWS) = 0.0
      CWSWIN(2,NWS) = 1.0
      CWSWIN(3,NWS) = 0.0
      CWSWIN(4,NWS) = 1.0
      CWSVP(1,NWS) = 0.0
      CWSVP(3,NWS) = 0.0
C    FOLLOWING CODE DEPENDENT ON DEFAULT FOR THIS DEVICE
      DROT = N
      HVIV = HVI(2,DROT)
      CURHVI = HVIV
      IF (DROT.EQ.DEFROT) THEN
                 WSMDCS(1,NWS) = XDCMAX
                 WSMDCS(2,NWS) = YDCMAX
                 XDCOR0 = XDCORG
                 YDCOR0 = YDCORG
      ELSE
                 WSMDCS(1,NWS) = YDCMAX
                 WSMDCS(2,NWS) = XDCMAX
                 XDCOR0 = YDCORG
                 YDCOR0 = 32767 - (XDCORG + XDCMAX)
      ENDIF
      CWSVP(2,NWS) = WSMDCS(1,NWS)
      CWSVP(4,NWS) = WSMDCS(2,NWS)
C    ENSURE RESET OF DEVICE TRANSFORMATION AFTER RESET ACTION
      ASSIGN 1004 TO JUMP
      GO TO 10028
C
C    OPCODE -2004      DIRECT DEVICE CODE TRANSFER
C
C    FORCE NPAR WORDS FROM NARG TO DEVICE
 2004 DO 10026 J=1,NPAR
      RBUFF(BUFFPT) = NARG(J)
      BUFFPT = BUFFPT + 1
      IF (BUFFPT.EQ.MAXBUF) CALL DFX01B(RBUFF,BUFFPT,DTYPE)
10026 CONTINUE
      GO TO 9999
C
C    OPCODE -2005      PIXEL SIZE/SPACING SPECIFICATION
C
 2005 IHPE = IPAR(1)
      IVPE = IPAR(2)
      IHES = IPAR(3)
      IHPS = IPAR(4)
      IVES = IPAR(5)
      IVPS = IPAR(6)
C    UNITS FOR HORIZONTAL/VERTICAL ELEMENT SPACING IN TERMS OF 4K
C    RASTER DEVICE (I.E. VECTOR:RASTER RATIO 8:1)
C    IHES,IVES HAVE 3 BINARY FRACTIONAL PLACES
C        - SO H/VESCDC ARE IDENTICAL TO IH/VES
      HESDC = IHES
      VESDC = IVES
      PIXSIZ = .TRUE.
      GO TO 9999
C
C    OPCODE -2006      INITIATE PRIME MODE THEN ADVANCE FRAME
C
 2006 RBUFF(BUFFPT) = 4
      BUFFPT = BUFFPT + 1
      IF (BUFFPT.EQ.MAXBUF)CALL DFX01B(RBUFF,BUFFPT,DTYPE)
      PIXSIZ = .TRUE.
      GO TO 1003
C
C    OPCODE -2007      SET/CLEAR SPECIFIED ICS FIELDS
C
C                 NARG(1) IS BIT MASK (RIGHT ADJUSTED) FOR
C                         16-BIT ICS - SET BITS WILL BE SET
C                         WITH VALUE OF CORRESPONDING BIT
C                         IN NARG(2)
C                 NARG(2) IS ICS-VALUES FOR BITS FLAGGED IN
C                         MASK WORD NARG(1)
C
C
 2007 ICSMSK = IOR(ICSMSK,NARG(1))
      ICSVAL = IOR(IAND(ICSVAL,NOT(NARG(1))),IAND(NARG(1),NARG(2)))
      ICSSET = .TRUE.
      ASSIGN 9999 TO JUMP
      GO TO 10025
      END
