*DECK CVX02D F
      SUBROUTINE DFX02D(NEWBYT)
C
C   ROUTINES TO HANDLE DATASET FOR DICOMED NATIVE CODE
C
C   CONVEX VERSION           -  JOHN GILBERT  SEPTEMBER 1991
C
C   THIS VERSION IS ABLE TO INTERFACE TO ROUTINES FOR
C   EITHER C OR FORTRAN I=O
C
C   ENTRY POINTS:
C
C----------------------------------------------------------------------
C
C     DFX02D(NEWBYT)
C     (NOTE: THIS IS THE MAIN ENTRY TO INTERNAL DRIVER CODE)
C
C    SETS THE BYTE LIMIT - MAXBYT  (SEE DFX02B)
C
C  CALLING SEQUENCE IS:
C       CALL DFX02D(MAXBYT)
C
C                   MAXBYT - BYTE LIMIT
C
C
C   THE FUNCTIONALITY OF ENTRY DFX02D IS:
C
C      - RESETS MAXBYT TO NEWBYT (PROVIDED NEWBYT > 0)
C        (NOTE: OUTLIM MUST BE CHANGED IN DFXD02 IF NECESSARY)
C
C
C----------------------------------------------------------------------
C
C     DFX02A(INFORM,OUTLIM,ASCHDR,IERR)
C
C      DYNAMICALLY ALLOCATES AND OPENS THE DIMFILM PLOT-FILE
C
C  CALLING SEQUENCE IS:
C          CALL DFX02A(INFORM,OUTLIM,ASCHDR,IERR)
C
C               INFORM - FOUR BYTE FORM NUMBER
C               OUTLIM- MAX NUMBER OF RECORDS WHICH CAN BE WRITTEN
C                       THIS MAY BE NECESSARY TO OVERCOME ANY
C                       SYSTEM DEFAULTS
C                       IT SHOULD BE USED WHEN FIEL FIRST DECLARED
C                       (ESSENTIAL WHEN ROUTING TO SYSTEM QUEUES
C                        - AS FOR MVS - TO OVERRIDE DEFAULT
C                        LIMIT ON QUEUED FILE SIZE)
C                       PRESENTLY IGNORED FOR CONVEX
C                       (NOTE: THE INBUILT LIMIT IN DFXDXX ASSUMES
C                        RECORDS OF 1024 BYTES)
C               ASCHDR - FIRST RECORD TO BE WRITTEN
C                  THIS CONTAINS ACCOUNTING INFORMATION ETC.
C                  THE RECORD IS 160 DATA BYTES LONG
C                  4 CHECKSUM BYTES ARE ADDED TO EACH HEADER (=164)
C               IERR  - RETURNS 4 BYTE FAILURE CODE ( =0 IF OK)
C
C
C
C
C        ANY I/O ERROR IS REPORTED IN THE JOB LOG
C        AND AN EXTERNAL ROUTINE DFXMSA IS CALLED WITH
C        THE ERROR CODE AS ITS ONLY PARAMETER
C
C        THE ACCOUNTING VARIABLES ARE ALSO INITIALISED
C
C   THE FUNCTIONALITY OF ENTRY DFX02A IS:
C
C      - OPEN DATASET FOR DICOMED CODE
C      - SAVE FORMS CODE AND LINE LIMIT FOR LATER
C      - CALCULATE HASH WORD FROM ASCII HEADER
C      - WRITE OUT HEADER, WITH HASH WORD ADDED
C      - CLEAR BYTE ACCUMULATOR
C
C----------------------------------------------------------------------
C
C     DFX02B(RBUFF,BUFFPT,DTYPE)
C
C                WRITES A RECORD TO THE PLOT-FILE
C
C  CALLING SEQUENCE IS:
C       CALL DFX02B(RBUFF,BUFFPT,DTYPE)
C
C                   RBUFF - ARRAY CONTAINING DATA
C                   BUFFPT - NUMBER OF 16 BIT INSTRUCTIONS
C                           MUST BE .LE. 100
C                    (IE. BUFFER LENGTH = 2*BUFFPT BYTES)
C                   DTYPE - DICOMED RECORD TYPE - INTEGER*4
C                          (ONLY LAST BYTE USED)   0  1  2  4
C                                                 CN  R  G  B
C
C    THE NUMBER OF BYTES WRITTEN IS ALSO ACCUMULATED IN THE
C    VARIABLE NOBYTE. IF THE NUMBER OF BYTES WRITTEN EXCEEDS
C    MAXBYT,THE EXTERNAL ROUTINE DFX01E IS CALLED WITH 2
C    PARAMETERS (EP1,MAXBYT). THIS TERMINATING ROUTINE MAY CALL
C    THIS ROUTINE AGAIN AND MUST THEREFORE STOP AFTERWARDS
C
C   THE FUNCTIONALITY OF ENTRY DFX02B IS:
C
C      - ADD 3 BYTE HASH AND 1 BYTE TYPE TO END OF RECORD
C        IN RBUFF
C      - WRITE OUT RECORD
C      - INCREMENT BYTE ACCUMULATOR (TAKE ACCOUNT OF HASH LENGTH)
C      - CHECK OUTPUT FILE LENGTH AND ENTER TERMINATION ROUTINE
C        IF NECESSARY
C      - ZERO BUFFER POINTER
C      - FOR DATA BLOCKS (NOT CONTROL) CLEAR BUFFER TO ZERO
C
C----------------------------------------------------------------------
C
C     DFX02C(RAST,IERR,NOBYTE)
C            CLOSES PLOT-FILE AND CHANGES MOVES TO VECTOR/RASTER QUEUE
C            (FILE WILL VANISH IF THIS ROUTINE IS NOT CALLED -
C             EG. IF JOB ABORTS BEFORE REACHING THIS ROUTINE)
C   CALLING SEQUENCE IS:
C          CALL DFX02C(RAST,IERR,NOBYTE)
C
C                      RAST - RASTER MODE FLAG ,LOGICAL
C                      IERR  - RETURNS FAILURE CODE ( = 0 IF OK)
C                      NOBYTE - NUMBER OF BYTES WRITTEN
C
C
C   THE FUNCTIONALITY OF ENTRY DFX02C IS:
C
C      - DISPOSE DATASET TO APPROPRIATE QUEUE (VECTOR
C        OR RASTER DEPENDING ON RAST)
C      - RETURN ACCUMULATED BYTE COUNT
C
C-----------------------------------------------------------------
      IMPLICIT INTEGER (A-Z)
*CALL,CVXCVX
C
C    NBH = NUMBER OF BYTES IN HEADER, NBW = EQUIVALENT 2-BYTE WORDS
C
      PARAMETER (NBH=160)
      INTEGER*4 NBW
      PARAMETER (NBW=NBH/2)
      CHARACTER  INFORM*4
      CHARACTER*164 ASCHDR,INHDR
      INTEGER*2 ASCEQ(82)
      EQUIVALENCE (ASCHDR,ASCEQ)
C   EQUIVALENCE TO FACILITATE CHECKSUMMING + I-O
C    (CONVEX PERMITS EQUIVALENCE BETWEEN CHAR AND NON-CHAR)
C    **LENGTH OF ASCHDR MUST AGREE WITH THAT IN**
C    **MAIN BODY OF DRIVER**
      CHARACTER*8 FORM
      CHARACTER*1 CLASS
      CHARACTER*50 FILEID
      CHARACTER*100 FILNAM,FILNM2
      CHARACTER*1 C1
      INTEGER*4 IC1,BUFFPT,DTYPE
      INTEGER*4 HBYTES,HWORDS
      INTEGER MAXBYT,BYTES
      LOGICAL LENERR,RAST
      PARAMETER (HBYTES=4)
      PARAMETER (HWORDS=HBYTES/2)
C    HASH BYTES = 4
      INTEGER*2 CHK1,CHK2,CHKSUM,CMPBYT,MSKTOP,MSKBOT,DTYP2
      INTEGER*2  RBUFF(*)
      INTEGER*4 IUNIT(LFTYPE)
C    IUNIT MUST HAVE SUFFICIENT SPACE ALLOCATED TO INCORPORATE
C    A C FILE TYPE; IUNIT(1) MAY BE SET TO FORTRAN UNIT NUMBER
C    TO ENABLE THE DRIVER TO BE SERVICED BY EITHER C OR FORTRAN I-O
      CHARACTER SHBLK1*24,SHBLK2*136
      INTEGER*4 IUNIQ
      CHARACTER*50 DIR
      CHARACTER*6 CUNIQ
*CALL,DFXPAB
*CALL,DFXCBA
*CALL,DFXCBD
*CALL,CVXCUT
      INTEGER*4 RENAME,CHMOD
      LOGICAL USETPE,FTCHAN
      SAVE
      DATA MSKTOP/'177400'O/
      DATA MSKBOT/'377'O/
      DATA       USETPE/.FALSE./ , FTCHAN/.FALSE./
      DATA SHBLK1/' '/,SHBLK2/' '/
      DATA       MAXREC/16777000/
      DATA       MAXBYT/102400000/
C    MAXBYT - ALLOWED MAXIMUM BYTES TO QUEUE
C-----------------------------------------------------------------
      IF (NEWBYT.GT.0) MAXBYT = NEWBYT
      RETURN
C-----------------------------------------------------------------
      ENTRY DFX02A(INFORM,OUTLIM,INHDR,IERR)
C
C    TO ENABLE EQUIVALENCE MUST COPY INHDR TO ASCHDR
C
      ASCHDR = INHDR
C
C
C------------------------------------------------------------------
C
C    ULCC FILM STACKER (CONVEX) HEADER - VERSION DFILMCVX  0a
C
C    LENGTH 160 BYTES
C
C                              ............26 JUNE 1990
C
C    1-10        HEADER LEVEL:DFILMCVX0a
C   11-40        PLOT SOFTWARE INFORMATION
C         11-17     PRODUCT NAME
C            19     V
C         20-24     VERSION AS NN.NA (NO LEADING BLANKS)
C         26-35     DRIVER NAME (RIGHT JUSTIFIED)
C            36     :
C         37-40     DRIVER VERSION AS NN.N OR N.NA
C                          (LEADING BLANK PERMITTED)
C   41-50        ACCOUNT NUMBER OR JOB NAME
C   51-60        JES (OR OTHER) SYSTEM JOB IDENTIFIER
C   61-70        TIME OF START OF JOB ( HH:MM:SS )
C   71-80        DATE OF START OF JOB ( DD/MM/YY )
C   81-100       MACHINE TYPE
C  101-120       OPERATING SYSTEM
C  121-140       USER COMMENT FIELD (DEFAULT FROM JOB STATEMENT)
C  141-150       INPUT SITE NAME (BLANK IF UNKNOWN)
C  151-160       OUTPUT SITE NAME (BLANK IF UNKNOWN)
C
C------------------------------------------------------------------
C
C
      USETPE = .FALSE.
      FTCHAN = .FALSE.
      IERR=0
C
C... SEE IF USETPE HAS BEEN CALLED
C
      IF (UTFLAG(NWS).GT.0) THEN
        IF (UTFLAG(NWS).EQ.11) THEN
C    HAVE !FT
          READ(UTVSN(NWS),'(3X,I2)') DN
          FTCHAN=.TRUE.
        ELSE
C
C... CONSTRUCT SHORT BLOCKS FOR USE BY USETAPE
C
          SHBLK1(1:1)=CHAR(28)
          SHBLK1(2:2)=CHAR(29)
          SHBLK1(3:3)=CHAR(30)
          SHBLK1(4:8)='B  1 '
          SHBLK1(9:16)=ASCHDR(51:58)
C
          SHBLK2( 1: 10)=ASCHDR( 41: 50)
          SHBLK2(11: 40)=ASCHDR(51:80)
          SHBLK2(41: 70)=ASCHDR( 11:40)
          SHBLK2(91:130)=ASCHDR( 81:120)
C      *CONVEX PRESENTLY DOES NOT SUPPORT TAPES*
C       THEREFORE FT IS ALWAYS PASSED AND DN
C       IS ACQUIRED AS A UNIT NUMBER
C       IF VSNS ARE IMPLEMENTED MUST PASS
C       SCRATCH FILE NAME (E.G. DFXD02) TO DFX01K
C       UNTIL THEN UNITS NUMBERS USED
          READ(UTVSN(NWS),'(3X,I2)') DN
          CALL DFX01K(DN,SHBLK1,SHBLK2,IERR)
          USETPE=.TRUE.
          RETURN
        ENDIF
      ELSE
        UTFLAG(NWS) = -1
C    SAVE FORM CODE
        FORM = INFORM
C    SAVE/USE OUTLIM IF NECESSARY
      ENDIF
C
      IF (.NOT.FTCHAN) THEN
C   CREATE UNIQUE FILEID FOR CONVEX SYSTEM
C   THIS IS FORMED AS   <account>_d02.nnnnnn
C
C    nnnnnn IS RETURNED BY DFX01Y WHICH ALSO PROVIDES
C    THE TOP LEVEL DIRECTORY
C
      CALL DFX01Y(DIR,IUNIQ,CUNIQ)
C    THE RETURNED FILM SPOOL ID IS USED AS SYSTEM IDENTIFICATION
C    IN STACKER HEADER - 51-60 - AS fid nnnnnn
      ASCHDR(51:60) = 'fid '//CUNIQ
      INHDR(51:60) = ASCHDR(51:60)
      ENDIF
C
C   CALCULATE CHECKSUM FROM ASCII HEADER INFORMATION
C
C   THE 4-BYTES APPENDED TO EACH RECORD COMPRISE:
C
C        BYTES 1-2   ---  2-BYTES UNIQUE CHECKSUM FROM DATA IN BLOCK
C        BYTE  3     ---  1-BYTE COMPARISON; COMPUTED IN FIRST
C                         BLOCK AND CARRIED FORWARD THROUGH ALL
C                         SUBSEQUENT BLOCKS
C        BYTE 4      ---  DATA TYPE FLAG
C
      CALL DFX01Q(ASCEQ,NBW,CHKSUM)
C    CHKSUM IS COMPUTED 2-BYTE CHECKSUM FROM HEADER
C    CMPBYT IS SAVED 1-BYTE CONSISTENCY CHECKSUM CARRIED
C    FORWARD ACROSS RECORDS
      CHK1 = IAND(CHKSUM,MSKTOP)
      CHK2 = ISHFT(CHKSUM,8)
      CMPBYT = IEOR(CHK1,CHK2)
      CMPBYT = IAND(CMPBYT,MSKTOP)
C
C   MERGE HASH INTO ASCII HEADER
C   (N.B.  HEADER MUST ALLOW FOR ADDITIONAL 4 BYTES)
C
      ASCEQ(NBW+1) = CHKSUM
      ASCEQ(NBW+2) = CMPBYT
      IF (FTCHAN) THEN
C   OUTPUT TO FILE
          WRITE(DN) ASCHDR(1:NBH+HBYTES)
      ELSE
C   STANDARD OUTPUT TO STACKER VIA SPOOL DISK
C
      LENDIR = INDEX(DIR,' ') - 1
      FILEID = ASCHDR(41:50)
      LENFIL = INDEX(FILEID,' ') - 1
      DO 1 I=1,LENFIL
      C1 = FILEID(I:I)
C   FORCE TO LOWER CASE
      IC1 = ICHAR(C1)
      IF ((IC1.GE.65).AND.(IC1.LE.90)) THEN
            IC1 = IC1 + 32
            C1 = CHAR(IC1)
            FILEID(I:I) = C1
      ENDIF
    1 CONTINUE
C    NOW ADD TO FILEID
C
      FILEID(LENFIL+1:) = '_d02.'//CUNIQ
      LENFIL = INDEX(FILEID,' ') - 1
C
C    FORM FULL FILENAME BY CONCATENATING DIRECTORY AND FILEID
C
      FILNAM = DIR(1:LENDIR)//'/'//FILEID(1:LENFIL)
      LENNAM = LENDIR + LENFIL
C
C
C   NOW ASSIGN AND OPEN FILE
C
C   DERIVE FORTRAN UNIT NUMBER AS LFBASE + NWS
C
      IUNIT(1) = LFBASE + NWS
C
      CALL DFX01T(IUNIT,FILNAM,IERR)
      IF (IERR.NE.0) THEN
           CALL DFXMSA(IERR)
           RETURN
      ENDIF
C
C    AND CHANGE PERMISSIONS FOR STACKER TO ACCESS
C
      IERR = CHMOD(FILNAM,'755')
C
      IF (IERR.NE.0) THEN
           CALL DFXMSA(IERR)
           RETURN
      ENDIF
C
C    AND OUTPUT HEADER RECORDS
C
      CALL DFX01W(IUNIT,ASCEQ,NBW+HWORDS,IERR)
          IF (IERR.NE.0) THEN
C
C   IRC IS RETURN CODE - NON-ZERO ===> REPORT
                  CALL DFXMSA(IERR)
C   AND GO TERMINATE VIA DFX01E (ERROR -1)
                  CALL DFX01E(1,-1)
           ENDIF
      ENDIF
C   SET VARIOUS PARAMETERS
      LENERR = .FALSE.
      BYTES = NBH + HBYTES
      NREC = 1
      RETURN
C-----------------------------------------------------------------
C
C
      ENTRY DFX02B(RBUFF,BUFFPT,DTYPE)
C
C        OUTPUT BUFFPT 16-BIT WORDS FROM RBUFF, FLAG AS DTYPE
C
      IF (USETPE) THEN
        CALL DFX01L(RBUFF,BUFFPT,DTYPE)
      ENDIF
C
C        PACK CHKSUM AND DTYPE INTO NEXT FOUR BYTES OF RBUFF
C        NOTE: CHKSUM IS STORED LEFT JUSTIFIED
C
C
C            ---------  ---------
C            | C | C |  | C | D |
C            ---------  ---------
C  RBUFF      BUFFPT+1   BUFFPT+2
C
      CALL DFX01Q(RBUFF,BUFFPT,CHKSUM)
C    CHKSUM IS COMPUTED 2-BYTE CHECKSUM
C    CMPBYT IS SAVED 1-BYTE CONSISTENCY CHECKSUM CARRIED
C    FORWARD ACROSS RECORDS
C
      DTYP2 = IAND(DTYPE,MSKBOT)
      RBUFF(BUFFPT+1) = CHKSUM
      RBUFF(BUFFPT+2) = IOR(CMPBYT,DTYP2)
      BUFFPT = BUFFPT + 2
C
C   NOTE: THE FOREGOING ASSUMES HBYTES=4
C
      IF (USETPE) GO TO 102
      IF (FTCHAN) THEN
C   OUTPUT TO FILE
          WRITE(DN) (RBUFF(I),I=1,BUFFPT)
      ELSE
C   STANDARD OUTPUT TO STACKER
C
          CALL DFX01W(IUNIT,RBUFF,BUFFPT,IERR)
          IF (IERR.NE.0) THEN
C
                  CALL DFXMSA(IERR)
C   AND GO TERMINATE VIA DFX01E (ERROR -1)
                  CALL DFX01E(1,-1)
           ENDIF
      ENDIF
      NREC=NREC+1
      BYTES = BYTES + 2*BUFFPT
C   BUFFPT ALREADY ADJUSTED TO ALLOW FOR HBYTES
      IF (BYTES.GT.MAXBYT) THEN
                  IF (.NOT.LENERR) THEN
                             LENERR = .TRUE.
                             CALL DFX01E(1,MAXBYT)
                  ENDIF
      ENDIF
  102 IF (DTYPE.NE.0) THEN
                  DO 101 I=1,BUFFPT
  101             RBUFF(I) = 0
      ENDIF
      BUFFPT=0
      RETURN
C-----------------------------------------------------------------
      ENTRY DFX02C(RAST,IERR,NOBYTE)
      NOBYTE = BYTES
      IF (USETPE) THEN
        CALL DFX01M(NOBYTE,SHBLK1,SHBLK2,IERR)
        GO TO 999
      ELSE IF (FTCHAN) THEN
        REWIND DN
        GO TO 999
      ELSE
C    CLOSE FILE
           CALL DFX01S(IUNIT,'KEEP',IERR)
           IF (IERR.NE.0) THEN
                  CALL DFXMSA(IERR)
                  GO TO 999
           ENDIF
C
C    SET UP CLASS - ADD SUBDIRECTORY TO PATH
C    THEN MOVE FILE TO THIS DIRECTORY
C    THIS PREVENTS STACKER ACCESS TO FILE WHICH IS IN
C    PROCESS OF BEING GENERATED AND ENABLES CLASSIFICATION
C    AS RASTER OR VECTOR AT END OF PLOT
C
         CLASS = 'v'
         IF (RAST) CLASS = 'r'
C
C    FORM NEW FILENAME BY CONCATENATING DIRECTORY AND FILEID
C
         FILNM2 = DIR(1:LENDIR)//'/d'//CLASS//'16/'//FILEID(1:LENFIL)
         LENNM2 = LENDIR + LENFIL + 6
C
         IERR = RENAME(FILNAM,FILNM2)
C
         IF (IERR.NE.0) CALL DFXMSA(IERR)
C
C    AND CHANGE PERMISSIONS FOR STACKER TO ACCESS
C
         IERR = CHMOD(FILNM2,'755')
C
         IF (IERR.NE.0) CALL DFXMSA(IERR)
      ENDIF
C    AT TERMINATION MUST CANCEL USETAPE - IF SUBSEQUENT
C    OPEN OF DEVICE USER MUST RESPECIFY USETAPE
C    (NECESSARY TO AVOID OVERWRITING TAPE/FILE)
  999 UTFLAG(NWS) = 0
      UTVSN(NWS) = '0'
      USETPE = .FALSE.
      FTCHAN = .FALSE.
      RETURN
      END
