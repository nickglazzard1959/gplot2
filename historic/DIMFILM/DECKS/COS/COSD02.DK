*DECK COSD02 F
      SUBROUTINE DFXD02(IF,XARG,YARG,ZARG,NARG)
C    D16 DEVICE DRIVER FOR DICOMED 16MM BLACK AND WHITE CINE MODE
C    UTILISING DICOMED DDC - COS MACHINE VERSION
C
C    DRIVER VERSION IS OF FORM NN.N
C
      CHARACTER*4 DVERSN
      PARAMETER (DVERSN=' 0.1')
      REAL XARG(*),YARG(*),ZARG(*)
      INTEGER NARG(*)
      PARAMETER (XDCMAX=32767.,YDCMAX=23920.,XDCORG=0.,YDCORG=4424.)
      CHARACTER*4 FORMID
      PARAMETER (FORMID='D16 ')
C    USES DFX02A,B,C FOR I/O
*CALL,DFXPAB
*CALL,DFXCBA
*CALL,DFXCBD
*CALL,DFXCBF
*CALL,DFXCAC
*CALL,DFXCAD
*CALL,DFXC04
*CALL,DFXC05
*CALL,DFXC17
*CALL,DFXC24
*CALL,DFXCBE
*CALL,DFXCP0
*CALL,COSK01
*CALL,DFXC00
C    SIZBUF IS OUTPUT BUFFER SIZE IN BYTES, LAST 4 BYTES FOR
C    CHECKSUM (3 BYTES) AND DATA TYPE (1 BYTE)
C    MAXBUF IS MAXIMUM AVAILABLE 16 BIT INSTRUCTIONS
C    BUFFPT POINTS TO NEXT AVAILABLE 16 BIT INSTRUCTION
C      NOTE - 0 POINTS TO FIRST INSTRUCTION (BUFFER ARRAY STARTS AT 0)
C      FOR OUTPUT WILL BE NUMBER OF 16 BIT INSTRUCTION WORDS TO TRANSFER
C    RBUFF IS DATA BUFFER, AS ARRAY STARTING AT ZERO (ALLOWING FOR
C                                                     4 BYTE TRAILER)
C    DTYPE IS DATA TYPE 1 - BLACK AND WHITE DDC DATA
C    CTYPE IS DATA TYPE 0 - CONTROL BLOCK
C    RAST (LOGICAL) SET TRUE IF ANY RASTER DATA ENCOUNTERED, ELSE FALSE
C    CNTL IS CONTROL BLOCK, 32 BYTES IN LENGTH (MAXCNT+2 16-BIT WORDS)
C                           1-22  TEXT
C                                 (FOR CRAY 17-20 UNUSED,
C                                           21-22 FLAG 1 MNEMONIC)
C                           23    FLAG BYTE 1
C                                 VALUE = 1   SD (START DOUBLE FRAMING)
C                                       = 2   ED (END DOUBLE FRAMING)
C                                       = 4   RS (RESET)
C                                       = 8   FA (FRAME ADVANCE)
C                                       = 16  EJ (END-OF-JOB)
C                                 (ONE FLAG ONLY PER CONTROL BLOCK)
C                           24    FLAG BYTE 2
C                           25-28 REPEAT COUNT
C                           29-32 ALLOW FOR TRAILER
C    LOPFA IS USED TO INDICATE (IN CONJUNCTION WITH WSDSE) LAST OP
C    BEING FRAME ADVANCE - IT IS ONLY SET FALSE BY BUFFER OUTPUT THAT
C    DOES NOT SET WSDSE AS FALSE
      INTEGER Z00FF,ZFFFF
      PARAMETER (Z00FF=255,ZFFFF=65535)
      PARAMETER(M8=Z00FF,M16=ZFFFF)
      INTEGER Z7FFF
      PARAMETER (Z7FFF=32767)
      PARAMETER (M15=Z7FFF)
      LOGICAL LOPFA,RAST,DOMODE
      LOGICAL DEFERM,DEFERH
      INTEGER SIZBUF,MAXBUF,BUFFPT,DTYPE,CTYPE,REPCNT,MAXCNT,CPT
      INTEGER FRAMES,LENBUF
      INTEGER FRMINC
      CHARACTER*7 CBYTE
      CHARACTER*1 CFRAM
      INTEGER OP0,OP2,OP6,OP7,OPMW,OPSS
      INTEGER MW,SS,MWLAST,SSLAST
      INTEGER VPAPPD(0:3),PPD
      INTEGER FB11,FB12,FB14,FB18,FB116
      INTEGER MODE,VECTOR,RASTER,FILMAD,UNSET
      LOGICAL RGB0
      INTEGER Z0000,Z4000,ZC000,ZE000
      PARAMETER (Z0000=0,Z4000=16384,ZC000=49152,ZE000=57344)
      PARAMETER (OP0=Z0000,OP2=Z4000,OP6=ZC000,OP7=ZE000)
      INTEGER ZF010,ZF070
      PARAMETER (ZF010=61456,ZF070=61552)
      PARAMETER (OPMW=ZF010,OPSS=ZF070)
      INTEGER Z0100,Z0200,Z0400,Z0800
      PARAMETER (Z0100=256,Z0200=512,Z0400=1024,Z0800=2048)
      PARAMETER (FB11=Z0100,FB12=Z0200,FB14=Z0400,FB18=Z0800)
      INTEGER Z1000,Z1800
      PARAMETER (Z1000=4096,Z1800=6144)
      PARAMETER (FB116=Z1000)
C    SET 2 CHARACTER MNEMONIC TO PREFACE FB1 CODE
C    (NOTE TRAILING ZERO TO ALLOW SIMPLE OR INTO CRAY WORD)
      INTEGER SD,ED,RS,FA,EJ
      PARAMETER (SD=34261000000B,ED=30561000000B)
      PARAMETER (RS=33170400000B,FA=30660200000B)
      PARAMETER (EJ=30564200000B)
      PARAMETER (VECTOR=17,RASTER=16,FILMAD=7,UNSET=-100)
      INTEGER OP1,FN1,FN7,ECS5,ECS6
      INTEGER Z2000,Z3000,ZF000,ZE0
      PARAMETER (Z2000=8192,Z3000=12288,ZF000=61440,ZE0=224)
      PARAMETER (OP1=Z2000,FN1=Z3000,FN7=ZF000)
      PARAMETER (ECS5=5,ECS6=6,MORICS=0,MCUICS=Z2000)
      PARAMETER (MHVI=ZE0)
C    MORICS IS EXTENDED INSTRUCTION FOR MASK AGAINST ORIGINAL ICS
C    MCUICS IS EXTENDED INSTRUCTION FOR MASK AGAINST CURRENT ICS
C    MHVI IS BIT MASK FOR HVI FIELD (BITS 5-7)
      LOGICAL DOICS
      INTEGER CURHVI,HVIV,HVIR
C    ICSSET IS SET TRUE IF ANY ICS SET OPERATION IS PERFORMED
C    ICSMSK THEN HOLDS ACCUMULATED ICS SET BIT MASK, AND
C    ICSVAL IS CURRENT ICS SET BIT PATTERN
      LOGICAL ICSSET
      INTEGER ICSMSK,ICSVAL
      PARAMETER (DTYPE=1,CTYPE=0)
      PARAMETER (SIZBUF=1024,MAXBUF=(SIZBUF-4)/2,MAXCNT=14)
      PARAMETER (LENBUF=(SIZBUF/8)-1)
      INTEGER RBUFF(0:LENBUF),CNTL((MAXCNT+2)/4)
C                PIXEL SPECIFICATIONS
C    PIXSIZ IS FLAG IF PIXEL PARAMETERS HAVE BEEN RESET AND NEED
C    TRANSMISSION TO D48
      LOGICAL PIXSIZ
C    PIXEL DIMENSIONS ARE SET BY
C                    IHPE  -  HORIZONTAL POINTS PER ELEMENT
C                    IVPE  -  VERTICAL POINTS PER ELEMENT
C                    IHES  -  HORIZONTAL ELEMENT SPACING
C                    IHPS  -  HORIZONTAL POINT SPACING
C                    IVES  -  VERTICAL ELEMENT SPACING
C                    IVPS  -  VERTICAL POINT SPACING
      INTEGER IHPE,IVPE,IHES,IHPS,IVES,IVPS
C    PIXEL ELEMENT SPACING IS HELD ALSO AS
C                    HESDC -  HORIZONTAL ELEMENT SPACING IN DC UNITS
C                    VESDC -  VERTICAL ELEMENT SPACING IN DC UNITS
      REAL HESDC,VESDC
C    SCAN DIRECTION IS DETERMINED BY H-REV, V-REV, H-V INTERCHANGE
C    THESE DEPEND ON COMIC/CINE MODES AND SELECTED VIA ISCAN
C    COMIC = 0, CINE = 1 HELD IN DROT
      INTEGER ISCAN,HVI(0:3,0:1),DROT
C    SCAN DIRECTION AND VALUE AS SHOWN:
C
C
C                          X2Y1    X2Y1          X1Y2               X1Y2
C                    O........      ........O     .........    .........
C DROT               ..      .      .      ..     .      ..    ..      .
C   0  HVI - COMIC   . . 3   .      .   7 . .     .   1 . .    . . 5   .
C                    .  .    .      .    .  .     .    .  .    .  .    .
C      ISCAN         .   0   .      .   1   .     .   2   .    .   3   .
C                    .    .  .      .  .    .     .  .    .    .    .  .
C   1  HVI - CINE    .   6 . .      . . 2   .     . . 4   .    .   0 . .
C                    .      ..      ..      .     ..      .    .      ..
C                    .........      .........     O........    ........O
C                   X1Y2                  X1Y2          X2Y1  X2Y1
C
C                     L TO R         R TO L         L TO R       R TO L
C                     T TO B         T TO B         B TO T       B TO T
C
C                                     ALL HORIZONTAL SCANS
C
C             N.B.  VECTOR PLOTTING IS WITH ISCAN = 2
C
C                   ROTATION MODE DEFAULTS ACCORDING TO DEVICE
C
C   WSCL IS PRE-CLIPPING RECTANGLE IN DC (E.G. FOR PIXEL ARRAYS)
C   WSBL IS PRE-BLANKING RECTANGLE IN DC (E.G. FOR PIXEL ARRAYS)
      REAL WSCL(4),WSBL(4)
C   CELL ARRAY IS STORED LOCALLY WHEN FIRST USED
C   XRAST,YRAST HOLD   0 - START/CURRENT SCAN LINE
C                      1 - LOWER LIMITS OF CELL ARRAY IN DC UNITS
C                      2 - UPPER LIMITS OF CELL ARRAY IN DC UNITS
C                      3 - END OF SCAN LINES
      REAL XRAST(0:3),YRAST(0:3)
C   CELOUT IS SET TRUE IF CELL AREA IS WHOLLY INVISIBLE
C   (FOR LINE MODE IS SET ON INITIAL ENTRY AND USED ON SUBSEQUENT ONES)
C    BLANK IS SET TRUE IF LCAP(2) IS TRUE AND BLANKING IS POSSIBLE
C    LRUN IS LOCAL FLAG FOR ACTUAL RUN LENGTH OR EVERY ELEMENT OUTPUT
      LOGICAL CELOUT,BLANK,LRUN
C    ISR IS SHIFTS FOR CRAY PIXEL DATA IN SCAN
      INTEGER ISR(4)
      REAL Z3(3)
      LOGICAL LCOL,RASTEX
C
C    LOOK UP TABLE VALUES STORED IN COMPRESSED FORMAT
C    0-255 ENTRIES    FOR R,G,B,B/W
      PARAMETER (MAXLUT=255)
      INTEGER D48LUT(4,0:31)
C    SET DEVICE DEFAULT ROTATION  0-COMIC, 1- CINE
      INTEGER DEFROT
      PARAMETER (DEFROT=1)
CPURE    **SEE COMMENTS UNDER INITIALISATION**
CPURE.LOGICAL PUREDC
      LOGICAL USETPE
      CHARACTER*4 CUSE
      CHARACTER*240 RECORD
      SAVE
      DATA RECORD(1:90)/'1         XX        DPLOT'/
      DATA RECORD(91:120)/'DIMFILM V*****    D16-D02:****'/
      DATA RECORD(121:240)/'          XX'/
      DATA CNTL/1423116075334270740722B,
     1           403036555274366353323B,
     2           0,0/
      DATA VPAPPD/Z0000,Z0800,Z1000,Z1800/
      DATA HVI/3,7,1,5,6,2,4,0/
      DATA ISR/24,32,40,16/
C    FUNCTION TO ROUND UP POSITIVE REALS INTO AN INTEGER
      IRNDUP(RX) = INT(RX+1) - INT(FLOAT(INT(RX+1))-RX)
      X = XARG(1)
      Y = YARG(1)
      Z = ZARG(1)
      N = NARG(1)
      IF (IF.LE.0) GO TO 1000
      IF (IF.EQ.4) GO TO 1
      IF (IF.LT.4) GO TO 3
      IF (IF.EQ.10) GO TO 10
      IF (IF.GT.100) GO TO 100
C    IGNORE ALL OTHER ENTRIES
      GO TO 9999
C
C    IF = 1 POINT PLOT, IF = 2 OFF MOVE
    3 XD = XDCO + X*DSCALE
      YD = YDCO + Y*DSCALE
      PPD = VPAPPD(0)
      IF (IF.EQ.2) GO TO 4
      IF (N.EQ.0) GO TO 4
      PPD = VPAPPD(1)
      SS = MAX(1,MIN(INT(SFSPOT(ICOLPT(IRGBN))+.5),15))
      IF (SS.NE.SSLAST) THEN
                      INS = OPSS.OR.SS
                      IW = SHIFTR(BUFFPT,2)
                      IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                      BUFFPT = BUFFPT + 1
                      IF (BUFFPT.EQ.MAXBUF)
     1                CALL DFX02B(RBUFF,BUFFPT,DTYPE)
                      SSLAST = SS
      ENDIF
      GO TO 2
C    IF = 4 ON MOVE
    1 XD = XDCO + X*DSCALE
      YD = YDCO + Y*DSCALE
      PPD = VPAPPD(2)
    2 IF (.NOT.DEVCOL(NWS)) GO TO 4
      II = ICOLPT(IRGBN)
      NC = NLUT(II)
      MW = MAX(1,MIN(INT(SFLIN(II)+.5),15))
C   ACCOUNT FOR POSSIBILITY OF LOOK UP TABLE
      IF (NC.LT.0) THEN
                      Z = ZINT(II)*ZRGB(II)
                      IZ = INT(Z*255.+.5)
      ELSE
                      IF (NC.GT.MAXLUT) NC = 1
C    INVALID LUT POINTER ACCESSES FOREGROUND
                      IW = NC/8
                      IZ = SHIFTR(D48LUT(4,IW),8*(7-(NC-IW*8))).AND.M8
      ENDIF
C    IF TRANSITION FROM OFF TO ON MUST POSITION
      IF (RGB0.AND.IZ.NE.0) THEN
      DOICS = (CURHVI.NE.HVIV)
CPURE+IF PURE DDC AVOID ICS CALL
CPURE.IF (PUREDC) DOICS = .FALSE.
CPURE-
      IF (DOICS) THEN
            CURHVI = HVIV
            ICSSET = .TRUE.
            ICSMSK = ICSMSK.OR.MHVI
            ICSVAL = (ICSVAL.AND..NOT.MHVI).OR.SHIFTL(CURHVI,5)
C    SET VECTOR HVI
                   IF (BUFFPT+3.GE.MAXBUF)
     1             CALL DFX02B(RBUFF,BUFFPT,DTYPE)
                   INS = OP0.OR.ECS6
                   IW = SHIFTR(BUFFPT,2)
                   IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   INS = MCUICS.OR.MHVI
                   IW = SHIFTR(BUFFPT+1,2)
                   IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   INS = SHIFTL(CURHVI,5)
                   IW = SHIFTR(BUFFPT+2,2)
                   IB16 = SHIFTL((3-((BUFFPT+2).AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   BUFFPT = BUFFPT + 3
      ENDIF
                          IF ((BUFFPT+3).GE.MAXBUF)
     1                        CALL DFX02B(RBUFF,BUFFPT,DTYPE)
                          INS = OP2.OR.VPAPPD(0)
                          IW = SHIFTR(BUFFPT,2)
                          IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                          RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                          INS = INT(XDLAST+.5).AND.M15
                          IW = SHIFTR(BUFFPT+1,2)
                          IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
                          RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                          INS = INT(YDLAST+.5).AND.M15
                          IW = SHIFTR(BUFFPT+2,2)
                          IB16 = SHIFTL((3-((BUFFPT+2).AND.3)),4)
                          RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                          BUFFPT = BUFFPT + 3
      ENDIF
      RGB0 = IZ.EQ.0
      IF (.NOT.RGB0) THEN
                INS = OP6.OR.IZ
                IW = SHIFTR(BUFFPT,2)
                IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                BUFFPT = BUFFPT + 1
                IF (BUFFPT.EQ.MAXBUF) CALL DFX02B(RBUFF,BUFFPT,DTYPE)
C    IF BEAM ON MUST SET LINE MULTI-WIDTH IF RELEVANT
                IF (MW.NE.MWLAST) THEN
                     INS = OPMW.OR.MW
                     IW = SHIFTR(BUFFPT,2)
                     IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                     RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                     BUFFPT = BUFFPT + 1
                     IF (BUFFPT.EQ.MAXBUF)
     1               CALL DFX02B(RBUFF,BUFFPT,DTYPE)
                     MWLAST = MW
                ENDIF
      ENDIF
      DEVCOL(NWS) = .FALSE.
    4 IF (MODE.NE.VECTOR) THEN
C                   SELECT VECTOR MODE
                              MODE = VECTOR
                              INS = OP0.OR.MODE
                              IW = SHIFTR(BUFFPT,2)
                              IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                              RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                              BUFFPT = BUFFPT + 1
                              IF (BUFFPT.EQ.MAXBUF)
     1                        CALL DFX02B(RBUFF,BUFFPT,DTYPE)
      ENDIF
      DOICS = (CURHVI.NE.HVIV)
CPURE+IF PURE DDC AVOID ICS CALL
CPURE.IF (PUREDC) DOICS = .FALSE.
CPURE-
      IF (DOICS) THEN
            CURHVI = HVIV
            ICSSET = .TRUE.
            ICSMSK = ICSMSK.OR.MHVI
            ICSVAL = (ICSVAL.AND..NOT.MHVI).OR.SHIFTL(CURHVI,5)
C    SET VECTOR HVI
                   IF (BUFFPT+3.GE.MAXBUF)
     1             CALL DFX02B(RBUFF,BUFFPT,DTYPE)
                   INS = OP0.OR.ECS6
                   IW = SHIFTR(BUFFPT,2)
                   IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   INS = MCUICS.OR.MHVI
                   IW = SHIFTR(BUFFPT+1,2)
                   IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   INS = SHIFTL(CURHVI,5)
                   IW = SHIFTR(BUFFPT+2,2)
                   IB16 = SHIFTL((3-((BUFFPT+2).AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   BUFFPT = BUFFPT + 3
      ENDIF
      IF (RGB0) GO TO 10004
      IF ((BUFFPT+3).GE.MAXBUF)
     1            CALL DFX02B(RBUFF,BUFFPT,DTYPE)
      INS = OP2.OR.PPD
      IW = SHIFTR(BUFFPT,2)
      IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
      INS = INT(XD+.5).AND.M15
      IW = SHIFTR(BUFFPT+1,2)
      IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
      INS = INT(YD+.5).AND.M15
      IW = SHIFTR(BUFFPT+2,2)
      IB16 = SHIFTL((3-((BUFFPT+2).AND.3)),4)
      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
      BUFFPT = BUFFPT + 3
10004 XDLAST = XD
      YDLAST = YD
      IF (PPD.EQ.VPAPPD(0)) GO TO 9999
C    DISPLAY SURFACE NON-EMPTY
 9998 WSDSE(NWS) = .FALSE.
 9999 IFLAST = IF
      RETURN
10032 RASTEX = .TRUE.
      GO TO 9999
C                PIXEL CODE
   10 CONTINUE
C    NPAR = 0 IS CELL ARRAY OPTION
C    NPAR > 0 IS LINE CELL  OPTION
      IF ((NPAR.GT.1).AND.(IFLAST.EQ.10).AND..NOT.RASTWN) THEN
C    IF CONTINUATION ENTRY FOR LINE CELL CHECK IF TOTALLY VALID
        IF (RASTEX) GO TO 9999
C    OR SEE IF OUT OF VALID RANGE
        IF (NPAR.GT.NRAST2) GO TO 10032
C    OR NOT YET INTO VALID RANGE
        IF (NPAR.LT.NRAST1) GO TO 9999
      ELSE
        IF (NPAR.GT.1) SYRAST0 = YRAST(0)
C    SAVE OLD Y-COORDINATE - FOR REPOSITIONING
        IF (RASTWN) THEN
        RASTEX = .FALSE.
C    CONVERT CLIP AREA TO WS DC
        WSCL(1) = XDCO + NDCL(1)*DSCALE
        WSCL(2) = XDCO + NDCL(2)*DSCALE
        WSCL(3) = YDCO + NDCL(3)*DSCALE
        WSCL(4) = YDCO + NDCL(4)*DSCALE
        IF (LPAR(2)) THEN
C    CONVERT BLANKING AREA TO WS DC (IF APPLICABLE AND NOT SEGMENT)
             WSBL(1) = XDCO + NDBL(1)*DSCALE
             WSBL(2) = XDCO + NDBL(2)*DSCALE
             WSBL(3) = YDCO + NDBL(3)*DSCALE
             WSBL(4) = YDCO + NDBL(4)*DSCALE
        ENDIF
C    CONVERT CELL ARRAY AREA TO WS DC
C    (NO TRANSFORMATION CURRENTLY PERMITTED)
        XRAST(1) = XDCO + XPAR(1)*DSCALE
        XRAST(2) = XDCO + XPAR(2)*DSCALE
        YRAST(1) = YDCO + YPAR(1)*DSCALE
        YRAST(2) = YDCO + YPAR(2)*DSCALE
C    NOW GET SCAN IN WS DC (CURRENTLY NO TRANSFORMATION)
C
C
C    ALLOW FOR PRECLIPPING IN GETTING START/END POSITIONS
C    DO HORIZONTAL SCANS FIRST
        CELOUT = .TRUE.
C    COMBINE WITH CHECK ON VALIDITY AFTER CLIPPING
        IF (XRAST(1).LE.XRAST(2)) THEN
C    LEFT TO RIGHT
             ISCAN = 0
             XRAST(0) = MAX(XRAST(1),WSCL(1))
             XRAST(3) = MIN(XRAST(2),WSCL(2))
C    FORCE XRAST(0) TO NEXT ADDRESSABLE (VECTOR) POINT (L TO R)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING
             IX0 = IRNDUP(XRAST(0))
             XRAST(0) = IX0
             IF (XRAST(0).GT.XRAST(3)) GO TO 10032
             X1 = XRAST(0)
             X2 = XRAST(3)
        ELSE
C    RIGHT TO LEFT
             ISCAN = 1
             XRAST(0) = MIN(XRAST(1),WSCL(2))
             XRAST(3) = MAX(XRAST(2),WSCL(1))
C    FORCE XRAST(0) TO LAST ADDRESSABLE (VECTOR) POINT (R TO L)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING (FROM R)
             IX0 = XRAST(0)
             XRAST(0) = IX0
             IF (XRAST(3).GT.XRAST(0)) GO TO 10032
             X1 = XRAST(3)
             X2 = XRAST(0)
        ENDIF
C    THEN DO VERTICAL SCAN
        IF (YRAST(1).LE.YRAST(2)) THEN
C    TOP TO BOTTOM
             YRAST(0) = MIN(YRAST(2),WSCL(4))
             YRAST(3) = MAX(YRAST(1),WSCL(3))
C    FORCE YRAST(0) TO LAST ADDRESSABLE (VECTOR) POINT (T TO B)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING (FROM T)
             IY0 = YRAST(0)
             YRAST(0) = IY0
             IF (YRAST(3).GT.YRAST(0)) GO TO 10032
             Y1 = YRAST(3)
             Y2 = YRAST(0)
        ELSE
C    BOTTOM TO TOP
             ISCAN = ISCAN + 2
             YRAST(0) = MAX(YRAST(2),WSCL(3))
             YRAST(3) = MIN(YRAST(1),WSCL(4))
C    FORCE YRAST(0) TO NEXT ADDRESSABLE (VECTOR) POINT (B TO T)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING
             IY0 = IRNDUP(YRAST(0))
             YRAST(0) = IY0
             IF (YRAST(0).GT.YRAST(3)) GO TO 10032
             Y1 = YRAST(0)
             Y2 = YRAST(3)
        ENDIF
C    X1 = MIN(XRAST(0),XRAST(3))
C    X2 = MAX(XRAST(0),XRAST(3))
C    Y1 = MIN(YRAST(0),YRAST(3))
C    Y2 = MAX(YRAST(0),YRAST(3))
C    NOW CHECK VALIDITY OF AREA AGAINST BLANKING (IF ANY)
        BLANK = LPAR(2)
        IF (LPAR(2)) THEN
          IF ((X1.GE.WSBL(1)).AND.(X2.LE.WSBL(2)).AND.
     1    (Y1.GE.WSBL(3)).AND.(Y2.LE.WSBL(4))) GO TO 10032
C    NOT TOTALLY OCCLUDED, SO CHECK FOR ANY POSSIBLE BLANKING
          IF ((X1.GT.WSBL(2)).OR.(X2.LT.WSBL(1)).OR.
     1    (Y1.GT.WSBL(4)).OR.(Y2.LT.WSBL(3))) BLANK = .FALSE.
        ENDIF
        CELOUT = .FALSE.
C***********SET SCAN DIRECTION***********
        IF (NPAR.GT.0) THEN
C    FOR SETUP GET VALID LINE RANGE
             DYRAST = (YRAST(1)-YRAST(2))/FLOAT(IPAR(6))
             NRAST1 = INT((YRAST(0)-YRAST(2))/DYRAST) + 1
             NRAST2 = INT((YRAST(3)-YRAST(2))/DYRAST) + 1
        ENDIF
C
        ENDIF
        DOMODE = (MODE.NE.RASTER)
        HVIR= HVI(ISCAN,DROT)
        DOICS = (CURHVI.NE.HVIR)
CPURE+IF PURE DDC AVOID ICS CALL
CPURE.IF (PUREDC) DOICS = .FALSE.
CPURE-
        IF (DOICS) THEN
            CURHVI = HVIR
            ICSSET = .TRUE.
            ICSMSK = ICSMSK.OR.MHVI
            ICSVAL = (ICSVAL.AND..NOT.MHVI).OR.SHIFTL(CURHVI,5)
        ENDIF
        IXR = IX0
        IYR = IY0
        IF (NPAR.GT.1) THEN
           IF (RASTWN) THEN
C   IF A NEW WINDOW THEN ONLY RESET POSITION IF THIS
C   LINE IS VISIBLE - ELSE LEAVE POSITION AS THAT OF
C   FIRST UNCLIPPED LINE
               IF (NPAR.GE.NRAST1) THEN
                 IYR = SYRAST0
                 YRAST(0) = SYRAST0
               ENDIF
           ELSE
               IYR = SYRAST0
               YRAST(0) = SYRAST0
C    SET Y-POSITION AND RESTORE POSITION REACHED
           ENDIF
        ENDIF
C   CLEAR RASTWN FLAG
        RASTWN = .FALSE.
        IF (HVIV.NE.HVIR) THEN
C    MUST GET COODINATES IN NEW ICS REFERENCE SYSTEM
C
C STEP 1: IGNORE INTERCHANGE AND REDUCE TO H,V NORMAL FOR VECTOR SYSTEM
C
C       NEGATE H-REVERSE
           IF ((SHIFTR(HVIV,2).AND.1).EQ.1) IXR = 32767 - IX0
C       NEGATE V-REVERSE
           IF ((SHIFTR(HVIV,1).AND.1).EQ.1) IYR = 32767 - IY0
C
C       IF VECTOR AND RASTER HAVE SAME INTERCHANGE CAN SKIP SWITCH
C
           IF ((HVIV.AND.1).NE.(HVIR.AND.1)) THEN
C STEP 2: PERFORM INTERCHANGE (LEAVING H,V NORMAL FOR RASTER SYSTEM)
                   IXS = IXR
                   IXR = 32767 - IYR
                   IYR = 32767 - IXS
           ENDIF
C
C STEP 3: NOW IN RASTER SYSTEM, BUT H,V NORMAL SO PERFORM ANY REVERSE
C
C       PERFORM H-REVERSE
           IF ((SHIFTR(HVIR,2).AND.1).EQ.1) IXR = 32767 - IXR
C       PERFORM V-REVERSE
           IF ((SHIFTR(HVIR,1).AND.1).EQ.1) IYR = 32767 - IYR
C
        ENDIF
C
C    IF PIXSIZ REQUIRES SPECIFICATION AND HAVE ALREADY GENERATED
C    RASTER OPS NO NEED TO DO RESET FOR B/W DEVICE (SINGLE STREAM)
C
C
C    SET RASTER
        IF (DOMODE) THEN
C                   SELECT RASTER MODE
                          MODE = RASTER
                          INS = OP0.OR.MODE
                          IW = SHIFTR(BUFFPT,2)
                          IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                          RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                          BUFFPT = BUFFPT + 1
                          IF (BUFFPT.EQ.MAXBUF)
     1                    CALL DFX02B(RBUFF,BUFFPT,DTYPE)
        ENDIF
        IF (DOICS) THEN
C    SET RASTER HVI - NOTING THIS MUST BE BEFORE POSITIONING
                   IF (BUFFPT+3.GE.MAXBUF)
     1             CALL DFX02B(RBUFF,BUFFPT,DTYPE)
                   INS = OP0.OR.ECS6
                   IW = SHIFTR(BUFFPT,2)
                   IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   INS = MCUICS.OR.MHVI
                   IW = SHIFTR(BUFFPT+1,2)
                   IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   INS = SHIFTL(HVIR,5)
                   IW = SHIFTR(BUFFPT+2,2)
                   IB16 = SHIFTL((3-((BUFFPT+2).AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   BUFFPT = BUFFPT + 3
        ENDIF
C    FORCE POSITION TO START OF SCAN
C       NOTE - USING COORDINATES IN RASTER HVI SYSTEM
        IF ((BUFFPT+3).GE.MAXBUF)
     1                    CALL DFX02B(RBUFF,BUFFPT,DTYPE)
        INS = OP2.OR.VPAPPD(0)
        IW = SHIFTR(BUFFPT,2)
        IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
        RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
        INS = IXR.AND.M15
        IW = SHIFTR(BUFFPT+1,2)
        IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
        RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
        INS = IYR.AND.M15
        IW = SHIFTR(BUFFPT+2,2)
        IB16 = SHIFTL((3-((BUFFPT+2).AND.3)),4)
        RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
        BUFFPT = BUFFPT + 3
C    NOW DO OP5 INSTRUCTION IF NECESSARY
        IF (PIXSIZ) THEN
               IF ((BUFFPT+3).GE.MAXBUF)
     1                  CALL DFX02B(RBUFF,BUFFPT,DTYPE)
               INS = 40960.OR.SHIFTL(IHES,6).OR.IHPS
               IW = SHIFTR(BUFFPT,2)
               IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
               RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
               INS = SHIFTL(IVES,6).OR.IVPS
               IW = SHIFTR(BUFFPT+1,2)
               IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
               RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
               INS = SHIFTL(IHPE,4).OR.IVPE
               IW = SHIFTR(BUFFPT+2,2)
               IB16 = SHIFTL((3-((BUFFPT+2).AND.3)),4)
               RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
               BUFFPT = BUFFPT + 3
        ENDIF
        IF (NPAR.GT.0) THEN
C    IF TOTALLY OUTSIDE RANGE EXIT WITH FLAG SET
             IF (NPAR.GT.NRAST2) GO TO 10032
C    IF NOT YET IN RANGE EXIT
             IF (NPAR.LT.NRAST1) GO TO 9999
        ENDIF
      ENDIF
      PIXSIZ = .FALSE.
C    NOW GET LINE BY LINE RASTER SCAN
      HRAST = HESDC
      VRAST = VESDC
      XRAST0 = XRAST(0)
      YRAST0 = YRAST(0)
      XRAST1 = XRAST(1)
      YRAST1 = YRAST(1)
      XRAST2 = XRAST(2)
      YRAST2 = YRAST(2)
      XRAST3 = XRAST(3)
      YRAST3 = YRAST(3)
C    (NOTE - XRAST0,YRAST0 NEED NOT BE IDENTICAL WITH XRAST1,YRAST1
C          - CLIPPING MAY REQUIRE SUBAREA ONLY TO BE DISPLAYED)
 
      LCOL = .FALSE.
C    FOR B/W DEVICE OUTPUT RASTER ALWAYS MONOCHROME
C
C    FLAG AS INITIAL SET UP
      IVSC = 0
C
10020 CALLDFX01F(XARG,YARG,ZARG,NARG,IPAR(1),IPAR(2),D48LUT,MAXLUT,LCOL,
     1    BLANK,WSBL)
C    SAVE NEXT SCAN LINE POSITION
      YRAST(0) = YRAST0
C    SKIP IF INVALID RETURN
      IF (IVSC.LE.0) GO TO 9999
C         HERE FOR RASTER OPERATIONS
      II = 4
      RGB0 = .TRUE.
C    CHECK RUN LENGTH
      LRUN = RUN
      IF (.NOT.LRUN) THEN
C    NOT GLOBAL RUN LENGTH SO DO QUICK CHECK
C    IF SAVE MORE THAN HALF SCAN LENGTH BY COMPRESSION THEN GO AND
C    DO RUN LENGTH IMMEDIATELY
          NRLIM = (IHSC+1)/2
          NR = 0
          NLC = -1
          DO 10013 J=1,IHSC
          LC = SHIFTR(SCAN(J),ISR(II)).AND.M8
          IF (LC.EQ.NLC) THEN
                NR = NR + 1
                IF (NR.GE.NRLIM) THEN
                    LRUN = .TRUE.
                    GO TO 10014
                ENDIF
          ELSE
                NLC = LC
          ENDIF
10013     CONTINUE
      ENDIF
10014     CONTINUE
C    CLEAR ARRAY LSCAN TO ZERO
      DO 10015 J=1,513
10015 LSCAN(J) = 0
C    SET OP CODE 1
      LSCAN(1) = SHIFTL(OP1,48)
      IF (LRUN) THEN
C    IF RUN-LENGTH FOR THIS COLOUR THEN
C    SET FUNCTION CODE 7
          LSCAN(1) = LSCAN(1).OR.SHIFTL(FN7,32)
C    COMPRESS INTO LSCAN
          IW = 1
          IS = 24
C    (IW IS CURRENT WORD IN LSCAN, IS IS CURRENT SHIFT FOR BYTE)
          KOUNT = 0
C    KEEP COUNT OF 16-BIT ELEMENTS BUILT
          NLC = SHIFTR(SCAN(1),ISR(II)).AND.M8
          NR = 0
          DO 10016 J=1,IHSC
          LC = SHIFTR(SCAN(J),ISR(II)).AND.M8
          IF (RUN) THEN
             NR1 = SHIFTR(SCAN(J),48).AND.M16
          ELSE
             NR1 = 1
          ENDIF
          IF (LC.EQ.NLC) THEN
             NR = NR + NR1
          ELSE
             IF (NR.GE.256) THEN
                   NN = NR/256
                   DO 10017 K=1,NN
C               RUN-LENGTH ZERO IS SPECIAL CASE OF 256
                   LSCAN(IW) = LSCAN(IW).OR.SHIFTL(NLC,IS-8)
                   KOUNT = KOUNT + 1
                   IS = IS - 16
                   IF (IS.LT.0) THEN
                          IW = IW + 1
                          IS = 56
                   ENDIF
                   NR = NR - 256
10017              CONTINUE
             ENDIF
             IF (NR.GT.0) THEN
               LSCAN(IW)=LSCAN(IW).OR.SHIFTL(NR,IS).OR.SHIFTL(NLC,IS-8)
               KOUNT = KOUNT + 1
               IS = IS - 16
               IF (IS.LT.0) THEN
                   IW = IW + 1
                   IS = 56
               ENDIF
             ENDIF
             NLC = LC
             NR = NR1
          ENDIF
10016     CONTINUE
C    DO OUTSTANDING PIXELS
          IF (LC.EQ.0) THEN
C        IF ZERO DO NOT SCAN (UNLESS TOTALLY ZERO LINE WHEN DO 1 ZERO
C        (MAY WISH TO INSTATE SCAN IF ZERO EXPOSURE ENABLED?)
                   IF (KOUNT.EQ.0) THEN
                         KOUNT = 1
                         LSCAN(IW) = LSCAN(IW).OR.SHIFT(1,IS)
                   ENDIF
           ELSE
                   IF (NR.GE.256) THEN
                         NN = NR/256
                         DO 10018 K=1,NN
C                    RUN-LENGTH ZERO IS SPECIAL CASE OF 256
                         LSCAN(IW) = LSCAN(IW).OR.SHIFTL(NLC,IS-8)
                         KOUNT = KOUNT + 1
                         IS = IS - 16
                         IF (IS.LT.0) THEN
                               IW = IW + 1
                               IS = 56
                         ENDIF
                         NR = NR - 256
10018                    CONTINUE
                   ENDIF
                   IF (NR.GT.0) THEN
               LSCAN(IW)=LSCAN(IW).OR.SHIFTL(NR,IS).OR.SHIFTL(NLC,IS-8)
                          KOUNT = KOUNT + 1
                          IS = IS - 16
                          IF (IS.LT.0) THEN
                               IW = IW + 1
                               IS = 56
                          ENDIF
                   ENDIF
          ENDIF
      ELSE
C    NOT RUN LENGTH ENCODED
C    SET FUNCTION CODE 1
          LSCAN(1) = LSCAN(1).OR.SHIFTL(FN1,32)
          IW = 1
          IS = 24
C    (IW IS CURRENT WORD IN LSCAN, IS IS CURRENT SHIFT FOR BYTE)
          KOUNT = 0
C    KEEP COUNT OF 8-BIT ELEMENTS BUILT (KOUNT IS LAST ENCOUNTERED
C                                        NON-ZERO ELEMENT)
          DO 10019 J=1,IHSC
          LC = SHIFTR(SCAN(J),ISR(II)).AND.M8
          IF (LC.NE.0) KOUNT = J
          LSCAN(IW) = LSCAN(IW).OR.SHIFTL(LC,IS)
          IS = IS - 8
          IF (IS.LT.0) THEN
                      IW = IW + 1
                      IS = 56
          ENDIF
10019     CONTINUE
C     ENSURE AT LEAST 1 ELEMENT
C        - IF TRAILING ZEROS REQUIRED SET KOUNT = IHSC
          KOUNT = MAX(1,KOUNT)
      ENDIF
C    ADD IN KOUNT
      LSCAN(1) = LSCAN(1).OR.SHIFTL(KOUNT,32)
10021 CONTINUE
C
C    GET WORD COUNT TO TRANSFER
      IWC = IW
      IF (IS.EQ.56) IWC = IW - 1
C    NOW READY TO TRANSFER DATA TO OUTPUT BUFFER
C
C    FILL 64-BIT WORD WITH NO-OPS IF NECESSARY
      BUFFPT = SHIFTL(SHIFTR(3+BUFFPT,2),2)
      IF(BUFFPT+4.GT.MAXBUF)CALLDFX02B(RBUFF,BUFFPT,DTYPE)
      IW = SHIFTR(BUFFPT,2)
      DO 10022 IREP=1,IVSC
      DO 10022 J=1,IWC
      RBUFF(IW) = LSCAN(J)
      IW = IW + 1
      BUFFPT = BUFFPT + 4
      IF (BUFFPT+4.GT.MAXBUF) THEN
                    CALL DFX02B(RBUFF,BUFFPT,DTYPE)
                    IW = 0
      ENDIF
10022 CONTINUE
C
C    SET RASTER FLAG
C
      RAST = .TRUE.
      WSDSE(NWS) = .FALSE.
C
C    NOW CHECK IF CELL ARRAY COMPLETE
C
      IF (NPAR.EQ.0) THEN
C        SET IVSC FOR CONTINUATION ENTRY
            IVSC = -1
            IF (ISCAN.LE.1) THEN
C          TOP TO BOTTOM
                  IF (YRAST0.GE.YRAST3) GO TO 10020
            ELSE
C          BOTTOM TO TOP
                  IF (YRAST0.LE.YRAST3) GO TO 10020
            ENDIF
      ENDIF
      GO TO 9998
  100 IF (IF.GT.200) GO TO 200
C     HERE FOR 101-199
C
      IF (IF.EQ.101) THEN
C
C    101 IS GLOBAL LUT ENTRY (BLOCK)
C
         J1 = MAX(0,NARG(1))
         J2 = MIN(NARG(2),MAXLUT)
         IF (J1.LE.J2) THEN
              DO 10034 I=J1,J2
              IW = I/8
              IBS = 8*(7 - (I - IW*8))
              DO 10035 J=1,3
              Z3(J) = RGBLUT(J,I)
              IZ = INT(Z3(J)*255.+.5)
10035         D48LUT(J,IW) = (D48LUT(J,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              Z = DFX139(Z3(1),Z3(2),Z3(3))
              IZ = INT(Z*255.+.5)
10034         D48LUT(4,IW) = (D48LUT(4,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              DEVCOL(NWS) = .TRUE.
         ENDIF
      ELSE IF (IF.EQ.102) THEN
C
C    102 IS LUT ENTRY (BLOCK) FROM ARGUMENTS
C
         J1 = MAX(0,NARG(1))
         J2 = MIN(NARG(2),MAXLUT)
         IF (J1.LE.J2) THEN
              DO 10036 I=J1,J2
              IW = I/8
              IBS = 8*(7 - (I - IW*8))
              Z3(1) = XARG(I)
              Z3(2) = YARG(I)
              Z3(3) = ZARG(I)
              DO 10037 J=1,3
              IZ = INT(Z3(J)*255.+.5)
10037         D48LUT(J,IW) = (D48LUT(J,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              Z = DFX139(Z3(1),Z3(2),Z3(3))
              IZ = INT(Z*255.+.5)
10036         D48LUT(4,IW) = (D48LUT(4,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              DEVCOL(NWS) = .TRUE.
         ENDIF
      ENDIF
      GO TO 9999
  200 IF (IF.NE.204) GO TO 9999
C     HERE FOR 204
C
  204 XD = X + XDCOR0
      YD = Y + YDCOR0
      IF (N.EQ.0) THEN
                      PPD = VPAPPD(0)
                      GO TO 4
                  ELSE
                      PPD = VPAPPD(2)
                      GO TO 2
      ENDIF
 1000 II = -IF
C       -1000 OR LOWER ARE SPECIAL ACTIONS
      IF (II.GE.1000) GO TO 2000
      GO TO (1001,1002,1003,1004),II
C    OPEN PLOT FILE
 1001 CALL DFXMS3(RECORD(31:38))
      CALL DFXMS8(RECORD(51:70))
      CALL DFXMS5(RECORD(71:90))
      CALL DFXMS4(RECORD(151:158))
      CALL DFXMS2(RECORD(162:169))
      CALL DFXMS1(RECORD(172:179))
      CALL DFXMS9(RECORD(221:240))
C    PLUG DIMFILM VERSION/LEVEL
      RECORD(100:104) = VERSN
C    PLUG DEVICE DRIVER VERSION
      RECORD(117:120) = DVERSN
      DO 10008 I=0,LENBUF
10008 RBUFF(I) = 0
      FRAMES = 0
      FRMINC = 1
C    FLAG IF USETAPE USE
      USETPE = UTFLAG(NWS).GT.0
CPURE    **IF PURE DDC IS REQUIRED E.G. WITH USETAPE AND ?FT...**
CPURE    **THEN ALL STATEMENTS PRESENTLY COMMENTED OUT WITH    **
CPURE    **CPURE. COMMENTS SHOULD BE ACTIVATED.  IT IS THEN THE**
CPURE    **'CPURE.' COMMENTS SHOULD BE ACTIVATED.  THESE       **
CPURE    **STATEMENTS ARE BRACKETED BY CPURE+/-. IT IS THEN THE**
CPURE    **USER'S RESPONSIBILITY TO ENSURE VECTOR/RASTER DATA  **
CPURE    **DOES NOT REQUIRE OTHER THAN THE DEFAULT ICS SETTING **
CPURE    **THIS CODE MERELY PREVENTS AN ICS CHANGE BEING SENT  **
CPURE    **TO THE PLOTTER.  ADDITIONALLY, THE USER MUST MAKE NO**
CPURE    **DIRECT ACCESSES WITH NON-STANDARD DDC CODE.  THIS   **
CPURE    **FEATURE IS NOT GUARANTEED AND IS INTENDED ONLY FOR  **
CPURE    **DICOMED SYSTEM DEVELOPMENT.  IT IS NOT A SUPPORTED  **
CPURE    **FEATURE OF THE DIMFILM-DICOMED DRIVERS.             **
CPURE    **                            JOHN GILBERT   1988     **
CPURE+FLAG IF PURE DDC REQUIRED (I.E. USETPE WITH ?FT..)
CPURE.IF (USETPE) THEN
CPURE.    I = UTFLAG(NWS)
CPURE.    PUREDC = (I.EQ.13).OR.(I.EQ.3).OR.(I.EQ.4)
CPURE.ENDIF
CPURE-
      CALL DFX02A(FORMID,500000,RECORD,IFAIL)
C    SET 4-BYTE FORM ID, LINE LIMIT, GET ERROR CONDITION
      IF (IFAIL.EQ.0) GO TO 10001
C    GKS ERROR 21 24 26 POSSIBLE
      GKSERR = 26
      GO TO 9999
10001 RAST = .FALSE.
C     SET LUT AT OPEN TO DIMFILM DEFAULT LUT
C
C     CLEAR LUT
      DO 10033 J=0,31
      DO 10033 I=1,4
10033 D48LUT(I,J) = 0
C
      JJ = MIN(MAXLUT,LUTSIZ-1)
      DO 10023 I=0,JJ
      IW = I/8
      IBS = 8*(7 - (I - IW*8))
      DO 10024 J=1,3
      Z3(J) = RGBLUT(J,I)
      IF (I.EQ.0) Z3(J) = 0.0
      IF (I.EQ.1) Z3(J) = 1.0
C    AT OPENING 0,1 ARE DEVICE DEFAULT BACKGROUND/FOREGROUND ALWAYS
C    FOR DICOMED = BLACK, WHITE RESPECTIVELY
      IZ = INT(Z3(J)*255.+.5)
10024 D48LUT(J,IW) = D48LUT(J,IW).OR.SHIFTL((IZ.AND.M8),IBS)
      Z = DFX139(Z3(1),Z3(2),Z3(3))
      IZ = INT(Z*255.+.5)
10023 D48LUT(4,IW) = D48LUT(4,IW).OR.SHIFTL((IZ.AND.M8),IBS)
      PIXSIZ = .TRUE.
C    FORCE PIXEL DEFINITION, DEFAULT IS 2048X2048 WITH 2X2 ELEMENTS
C
C    HORIZONTAL/VERTICAL POINTS/ELEMENT = 2
C    HORIZONTAL/VERTICAL ELEMENT SPACING = 16 (=2 WITH 3 BINARY POINTS)
C    HORIZONTAL/VERTICAL POINT SPACING = 8 (=1 WITH 3 BINARY POINTS)
C
C    SPACING IN TERMS OF 4K RASTER DEVICE (N.B. VECTOR:RASTER RATIO 8:1)
C
      IHPE = 2
      IVPE = 2
      IHES = 16
      IHPS = 8
      IVES = 16
      IVPS = 8
      HESDC = IHES
      VESDC = IVES
C    ROTATION MODE IS CINE FOR D16 BY DEFAULT
      DROT = DEFROT
      XDCOR0 = XDCORG
      YDCOR0 = YDCORG
      HVIV = HVI(2,DROT)
      CURHVI = HVIV
C    SET DEFERRED MULTI-FRAME ACTION OFF
      DEFERM = .FALSE.
      DEFERH = .FALSE.
      MULTIR = 0
C    AT OPEN CLEAR ICS FLAGS
      ICSSET = .FALSE.
      ICSMSK = 0
      ICSVAL = 0
      BUFFPT = 0
      WSMDCS(1,NWS) = XDCMAX
      WSMDCS(2,NWS) = YDCMAX
      WSCAT(NWS) = 2
      WSDM(NWS) = 3
C    SET WS ID - SPECIFIC TO DEVICE
      WSID(NWS) = 02
      WSNAME(NWS) = 'D16'
C    SET UP DEFAULT WS TRANSFORMATION
      CWSWIN(1,NWS) = 0.0
      CWSWIN(2,NWS) = 1.0
      CWSWIN(3,NWS) = 0.0
      CWSWIN(4,NWS) = 1.0
      CWSVP(1,NWS) = 0.0
      CWSVP(2,NWS) = XDCMAX
      CWSVP(3,NWS) = 0.0
      CWSVP(4,NWS) = YDCMAX
      ASSIGN 1004 TO JUMP
      LOPFA = .FALSE.
C    NOTE: IMPLIED FRAME ADVANCE AT BEGIN OF JOB
C          THIS MAY NOT BE AS REQUIRED FOR DEFERRED
C          MULTI-FRAMING WHICH MUST FOLLOW AN ACTUAL
C          FA CONTROL BLOCK
      GO TO 10005
C    CLOSE DEVICE
 1002 IF (WSDSE(NWS).AND.LOPFA) GO TO 10002
      INS = OP0.OR.FILMAD
      IW = SHIFTR(BUFFPT,2)
      IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
      BUFFPT = BUFFPT + 1
      CALL DFX02B(RBUFF,BUFFPT,DTYPE)
      CNTL(3) = FA.OR.FB18
      FRAMES = FRAMES + FRMINC
      CPT = MAXCNT
      CALL DFX02B(CNTL,CPT,CTYPE)
      WSDSE(NWS) = .TRUE.
      LOPFA = .TRUE.
10002 IF (MULTIR.EQ.0.AND..NOT.DEFERM) GO TO 10040
C    MUST END MULTI-FRAMING IF ACTIVE
      DEFERM = .FALSE.
      DEFERH = .FALSE.
      MULTIR = 0
      FRMINC = MULTIR + 1
      CNTL(3) = ED.OR.FB12
      CPT = MAXCNT
      CNTL(4) = 0
      CALL DFX02B(CNTL,CPT,CTYPE)
      LOPFA = .FALSE.
10040 CNTL(3) = EJ.OR.FB116
      IF (FRAMES.EQ.0) THEN
               CALL DFX003('**DIMFILM  -  DEVICE D16 TERMINATED**')
               CALL DFX003('**NO DATA - NO FILM WILL BE GENERATED**')
               GKSERR = 0
               GO TO 9999
      ENDIF
      CPT = MAXCNT
      CALL DFX02B(CNTL,CPT,CTYPE)
      LOPFA = .FALSE.
C    GET SD PARAMETER FLAG
      CALL DFXMSS(ISD)
      CALL DFX02C(RAST,IFAIL,NOBYTE,ISD)
      CFRAM = 'S'
      IF (FRAMES.EQ.1) CFRAM = ' '
      WRITE(ERRREC,10009) FRAMES,CFRAM
10009 FORMAT('**DIMFILM  -  DEVICE D16 TERMINATED  - ',I6,' FRAME',A)
      CALL DFX003(ERRREC(1))
      NB = NOBYTE
      CBYTE = ' BYTES'
      IF (NB.GE.1000000) THEN
                          NB = (NB-1)/1024 + 1
                          CBYTE = 'K BYTES'
      ENDIF
      IF (NB.GE.1000000) THEN
                          NB = (NB-1)/1024 + 1
                          CBYTE = 'M BYTES'
      ENDIF
      IF (NB.EQ.1) CBYTE(7:7) = ' '
      IF (USETPE) THEN
          CUSE = ' SAV'
      ELSE
          CUSE = 'QUEU'
      ENDIF
      WRITE(ERRREC,10010) CUSE,NB,CBYTE
10010 FORMAT('              ',A4,'ED DATASET LENGTH  - ',I6,A)
      CALL DFX003(ERRREC(1))
C    IF NO ERROR SEND SD-RELATED MESSAGES
      IF (IFAIL.EQ.0) THEN
       IF (ISD.EQ.1) THEN
C    SD PARAMETER SPECIFIED
         CALL DFX003('**PLOT DATA SUCCESSFULLY TRANSFERRED')
       ELSE
C    NO SD PARAMETER
         CALL DFX003
     1   ('**UNABLE TO CONFIRM SUCCESSFUL PLOT DATA TRANSFER -')
         CALL DFX003
     1   ('  SD PARAMETER ON JOB STATEMENT STRONGLY RECOMMENDED')
       ENDIF
       IF (USETPE) THEN
         CALL DFX003
     1   ('*****USE TAPE FACILITY WAS USED*****')
         CALL DFX003
     1   ('******DATA WILL NOT BE PLOTTED******')
       ENDIF
      ENDIF
      GKSERR = IFAIL
      GO TO 9999
C    FRAME ADVANCE
 1003 INS = OP0.OR.FILMAD
      IW = SHIFTR(BUFFPT,2)
      IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
      BUFFPT = BUFFPT + 1
      CALL DFX02B(RBUFF,BUFFPT,DTYPE)
      CNTL(3) = FA.OR.FB18
      FRAMES = FRAMES + FRMINC
      CPT = MAXCNT
      CALL DFX02B(CNTL,CPT,CTYPE)
      LOPFA = .TRUE.
      ASSIGN 9999 TO JUMP
      IF (.NOT.DEFERM) GO TO 10005
      DEFERM = .FALSE.
      IF (MULTIR.EQ.0) THEN
           CNTL(3) = ED.OR.FB12
      ELSE
           CNTL(3) = SD.OR.FB11
      ENDIF
      CPT = MAXCNT
      CNTL(4) = SHIFTL((MULTIR.AND.M16),32)
C    MAXIMUM REPEAT COUNT 64K!!!
      CALL DFX02B(CNTL,CPT,CTYPE)
      FRMINC = MULTIR + 1
      LOPFA = .FALSE.
      CNTL(4) = 0
      IF (DEFERH) THEN
          DEFERM = .TRUE.
          DEFERH = .FALSE.
          MULTIR = MDEFER
      ENDIF
10005 WSDSE(NWS) = .TRUE.
C    VECTOR/RASTER MODE UNSET AT BEGINNING OF EACH FRAME
10025 MODE = UNSET
C    AT FRAME ADVANCE/RESET MUST SEND ICS STATUS
C    (POSSIBLY REDUNDANT ON B/W - UNLESS SEGMENTS - BUT DO ANYWAY)
CPURE+IF PURE DDC AVOID ICS CALL
CPURE.      IF (PUREDC) GO TO 8000
CPURE-
                   INS = OP0.OR.ECS6
                   IW = SHIFTR(BUFFPT,2)
                   IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   INS = MORICS.OR.ICSMSK
C              (MASK AGAINST ORIGINAL ICS - N.B. MORICS ACTUALLY ZERO)
                   IW = SHIFTR(BUFFPT+1,2)
                   IB16 = SHIFTL((3-((BUFFPT+1).AND.3)),4)
                   RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                   BUFFPT = BUFFPT + 2
                   IF (ICSMSK.NE.0) THEN
C               HERE IF NOT RESETTING TO ORIGINAL
C
C               NOTE - ADDITIONAL OUTPUT WORD HERE
                          INS = ICSVAL
                          IW = SHIFTR(BUFFPT,2)
                          IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
                          RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
                          BUFFPT = BUFFPT + 1
                   ENDIF
CPURE+
C8000 CONTINUE
CPURE-
C    SET HERE TO FORCE LINE MULTI-WIDTH AND SPOT SIZE SELECTION VIA DDC
      MWLAST = -1
      SSLAST = -1
      RGB0 = .TRUE.
      DEVCOL(NWS) = .TRUE.
C    SHOULD ALSO SET BEAM POSITION, SPOT SIZE, LINE THICKNESS
C    BEAM POSITION IS SET BY DIMFILM AT FRAME ADVANCE
C    COLOUR IS FORCED AT F/A IN DFX000 VIA DEVCOL, MWLAST AND SSLAST
      GO TO JUMP,(1004,9999)
C    RESET DEVICE TRANSFORMATION
 1004 DSCALE = AMAX1((CWSVP(2,NWS)-CWSVP(1,NWS))
     1                       /(CWSWIN(2,NWS)-CWSWIN(1,NWS)),
     2    (CWSVP(4,NWS)-CWSVP(3,NWS))/(CWSWIN(4,NWS)-CWSWIN(3,NWS)))
      XDCO = CWSVP(1,NWS) - CWSWIN(1,NWS)*DSCALE + XDCOR0
      YDCO = CWSVP(3,NWS) - CWSWIN(3,NWS)*DSCALE + YDCOR0
C    THESE TRANSFORM VALUES YIELD D48 VALUES
      GO TO 9999
C    DEVICE SPECIFIC CODES COMMENCE AT -2001
 2000 II = II - 2000
      GO TO (2001,2002,2003,2004,2005,2006,2007,2008),II
C
C    OPCODE -2001      FORCE FULL RESET ACTION
C
C     SET RETURN PATH - NO TRANSFORMATION RESET
 2001 ASSIGN 9999 TO JUMP
10028 IF (BUFFPT.NE.0) CALL DFX02B(RBUFF,BUFFPT,DTYPE)
      CNTL(3) = RS.OR.FB14
      CPT = MAXCNT
      CALL DFX02B(CNTL,CPT,CTYPE)
      LOPFA = .FALSE.
C    GO DO BUFFER INITIALISATIONS AND RETURN
C    (NOTE ENTRY 2001 RESULTS IN DIRECT RETURN, ALTERNATE PATHS
C     EXIST FOR ENTRIES VIA 10028 E.G. FROM DEVICE ROTATION,
C     PIXEL SIZE SPECIFICATION OP)
      GO TO 10025
C
C    OPCODE -2002      FORCE PARTIAL RESET ACTION
C
 2002 MODE = UNSET
      MWLAST = -1
      SSLAST = -1
      RGB0 = .TRUE.
      PIXSIZ = .TRUE.
C
C    OPCODE -2003      SELECT DEVICE ROTATION
C
 2003 IF (DROT.EQ.N) GO TO 9999
C    ONLY ACCEPT VALID CALL AFTER OPEN OF THIS WS
      IF ((N.NE.0).AND.(N.NE.1)) GO TO 9999
C    RESET ALL CWSWIN/VP THEN SET FOR SPECIFIC ROTATION
      CWSWIN(1,NWS) = 0.0
      CWSWIN(2,NWS) = 1.0
      CWSWIN(3,NWS) = 0.0
      CWSWIN(4,NWS) = 1.0
      CWSVP(1,NWS) = 0.0
      CWSVP(3,NWS) = 0.0
C    FOLLOWING CODE DEPENDENT ON DEFAULT FOR THIS DEVICE
      DROT = N
      HVIV = HVI(2,DROT)
      IF (DROT.EQ.DEFROT) THEN
                 WSMDCS(1,NWS) = XDCMAX
                 WSMDCS(2,NWS) = YDCMAX
                 XDCOR0 = XDCORG
                 YDCOR0 = YDCORG
      ELSE
                 WSMDCS(1,NWS) = YDCMAX
                 WSMDCS(2,NWS) = XDCMAX
                 XDCOR0 = YDCORG
                 YDCOR0 = 32767 - (XDCORG + XDCMAX)
      ENDIF
      CWSVP(2,NWS) = WSMDCS(1,NWS)
      CWSVP(4,NWS) = WSMDCS(2,NWS)
C    ENSURE RESET OF DEVICE TRANSFORMATION AFTER RESET ACTION
      ASSIGN 1004 TO JUMP
      GO TO 10028
C
C    OPCODE -2004      DIRECT DEVICE CODE TRANSFER
C
C    FORCE NPAR WORDS FROM NARG TO DEVICE ACCORDING TO N
 2004 DO 10026 J=1,NPAR
      INS = NARG(J)
      IW = SHIFTR(BUFFPT,2)
      IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
      BUFFPT = BUFFPT + 1
      IF (BUFFPT.EQ.MAXBUF)CALLDFX02B(RBUFF,BUFFPT,DTYPE)
10026 CONTINUE
      GO TO 9999
C
C    OPCODE -2005      PIXEL SIZE/SPACING SPECIFICATION
C
 2005 IHPE = IPAR(1)
      IVPE = IPAR(2)
      IHES = IPAR(3)
      IHPS = IPAR(4)
      IVES = IPAR(5)
      IVPS = IPAR(6)
C    UNITS FOR HORIZONTAL/VERTICAL ELEMENT SPACING IN TERMS OF 4K
C    RASTER DEVICE (I.E. VECTOR:RASTER RATIO 8:1)
C    IHES,IVES HAVE 3 BINARY FRACTIONAL PLACES
C        - SO H/VESCDC ARE IDENTICAL TO IH/VES
      HESDC = IHES
      VESDC = IVES
      PIXSIZ = .TRUE.
      GO TO 9999
C
C    OPCODE -2006      INITIATE PRIME MODE THEN ADVANCE FRAME
C
 2006 INS = 4
      IW = SHIFTR(BUFFPT,2)
      IB16 = SHIFTL((3-(BUFFPT.AND.3)),4)
      RBUFF(IW) = RBUFF(IW).OR.SHIFTL(INS,IB16)
      BUFFPT = BUFFPT + 1
      IF (BUFFPT.EQ.MAXBUF)CALLDFX02B(RBUFF,BUFFPT,DTYPE)
      PIXSIZ = .TRUE.
      GO TO 1003
C
C    OPCODE -2007      SET/CLEAR SPECIFIED ICS FIELDS
C
C                 NARG(1) IS BIT MASK (RIGHT ADJUSTED) FOR
C                         16-BIT ICS - SET BITS WILL BE SET
C                         WITH VALUE OF CORRESPONDING BIT
C                         IN NARG(2)
C                 NARG(2) IS ICS-VALUES FOR BITS FLAGGED IN
C                         MASK WORD NARG(1)
C
C
 2007 ICSMSK = ICSMSK.OR.NARG(1)
      ICSVAL = (ICSVAL.AND..NOT.NARG(1)).OR.(NARG(1).AND.NARG(2))
      ICSSET = .TRUE.
      ASSIGN 9999 TO JUMP
      GO TO 10025
C
C    OPCODE -2008      START/END MULTI-FRAMING
C                      -VE = HOLD ACTION (16MM ONLY)
C
C     SET REPEAT COUNT AND SET FLAG FOR DEFERRED ACTION
C     MULTI-FRAMING WILL BE ACTIVATED AT NEXT ACTUAL FRAME ADVANCE
 2008 IF (N.LT.0) THEN
C    SETTING DEFERRED HOLD
C    IF FIRST HOLD THEN SAVE ANY MULTI-FRAMING
C    AND FLAG DEFERRED HOLD, AND MULTI-FRAMING STATUS
          IF (.NOT.DEFERH) MDEFER = MULTIR
C    MUST AMEND COUNT FOR STACKER, WHERE IT IS REPEAT COUNT
C    ADDITIONAL TO ORIGINAL FRAME
          MULTIR = -N - 1
          DEFERH = .TRUE.
      ELSE
C    SET DEFERRED MULTI-FRAMING
C    IF DEFERRED HOLD, THEN COUNT IS USED TO RESTORE MULTI-FRAMING
C    OTHERWISE IT IS NEW MULTI-FRAME COUNT
          IF (DEFERH) THEN
              MDEFER = N
          ELSE
              MULTIR = N
          ENDIF
      ENDIF
      DEFERM = .TRUE.
      GO TO 9999
      END
