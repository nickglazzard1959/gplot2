*DECK COS02D F
      SUBROUTINE DFX02D(NEWBYT)
C
C   ROUTINES TO HANDLE DATASET FOR DICOMED NATIVE CODE
C
C   EXTENDED FOR UNICOS   -  JOHN GILBERT  MAY 1990
C
C   ENTRY POINTS:
C
C
C     DFX02D(NEWBYT)
C
C      - RESETS MAXBYT TO NEWBYT (PROVIDED NEWBYT > 0)
C        (NOTE: OUTLIM MUST BE CHANGED IN DFXD02 IF NECESSARY)
C
C
C     DFX02A(FORM,OUTLIM,ASHEDR,IERR)
C
C      - OPEN DATASET FOR DICOMED CODE
C      - SAVE FORMS CODE AND LINE LIMIT FOR LATER
C      - CREATE EBCDIC VERSION OF HEADER RECORD
C      - CALCULATE HASH WORD FROM EBCDIC HEADER
C      - WRITE OUT EBCDIC HEADER THEN ASCII HEADER, WITH
C        HASH WORD ADDED TO EACH
C      - CLEAR BYTE ACCUMULATOR
C
C     DFX02B(RBUFF,BUFFPT,DTYPE)
C
C      - ADD 3 BYTE HASH AND 1 BYTE DTYPE TO END OF RECORD
C        IN RBUFF
C      - WRITE OUT RECORD
C      - INCREMENT BYTE ACCUMULATOR (TAKE ACCOUNT OF HASH LENGTH)
C      - CHECK OUTPUT FILE LENGTH AND ENTER TERMINATION ROUTINE
C        IF NECESSARY
C      - ZERO BUFFER POINTER
C      - FOR DATA BLOCKS (NOT CONTROL) CLEAR BUFFER TO ZERO
C
C     DFX02C(RAST,IERR,NOBYTE,SD)
C
C      - DISPOSE DATASET TO APPROPRIATE SYSOUT QUEUE (VECTOR
C        OR RASTER DEPENDING ON RAST)
C      - RETURN ACCUMULATED BYTE COUNT
C      - DISPOSE AS WAIT/NOWAIT ACCORDING TO PRESENCE/ABSENCE OF SD
C        PARAMETER ON JOB STATEMENT  (ULCC COS ONLY)
C
C-----------------------------------------------------------------
      IMPLICIT INTEGER (A-Z)
      PARAMETER (NBH=240 , NWH=(NBH-1)/8+1)
      CHARACTER  FORM*4,ASHEDR*(*),JCL*90,JCLFMT*100
      INTEGER HBYTES,MAXBYT,BYTES
      LOGICAL LENERR,RAST
      PARAMETER (HBYTES=4)
C    HASH BYTES = 4
      DIMENSION  EBHEDR(NWH)
      DIMENSION  RBUFF(510),UBC(0:3)
      CHARACTER SHBLK1*24,SHBLK2*136
*CALL,DFXPAB
*CALL,DFXCBA
*CALL,DFXCBD
*CALL,COSCUT
      LOGICAL USETPE,FTCHAN
      SAVE
      DATA       USETPE/.FALSE./ , FTCHAN/.FALSE./
*IF DEF,UNICOS
      DATA       DN/'dfxd02'L/
*ELSE
*/  MUST BE COS
      DATA       DN/'$DFXD02'L/
*ENDIF
      DATA       JCLFMT/
     +'(''SYSOUT=(G,,'',A,''),DEST=LOCAL,DCB=(RECFM=U,LRECL=1024,BLKSIZE
     +=1024),OUTLIM='',I8.8)'/
      DATA SHBLK1/' '/,SHBLK2/' '/
      DATA       JCL/
     +'SYSOUT=(G,,    ),DEST=LOCAL,DCB=(RECFM=U,LRECL=1024,BLKSIZE=1024)
     +,OUTLIM='/
      DATA       UBC /32,16,0,48/
      DATA       MAXREC/16777000/
      DATA       MAXBYT/102400000/
C    MAXBYT - ALLOWED MAXIMUM BYTES TO QUEUE
C-----------------------------------------------------------------
      IF (NEWBYT.GT.0) MAXBYT = NEWBYT
      RETURN
C-----------------------------------------------------------------
      ENTRY DFX02A(FORM,OUTLIM,ASHEDR,IERR)
      USETPE = .FALSE.
      FTCHAN = .FALSE.
*IF DEF,UNICOS
C    NOTE: FILE IDENTIFIER USED MUST AGREE WITH DN DEFINITION
      IERR = ISHELL('assign -a $TMPDIR/.dfxd02 dfxd02')
*ELSE
*/  MUST BE COS
      CALL ASSIGN (IERR,
     +             'DN'L    , DN      ,
     +             'DC'L    , 'SC'L   ,
     +             'BFI'L   , 'OFF'L   )
*ENDIF
      IF (IERR.NE.0) THEN
        CALL DFXMSA(IERR)
        RETURN
      ENDIF
C
C... SEE IF USETPE HAS BEEN CALLED
C
      IF (UTFLAG(NWS).GT.0) THEN
        IF (UTFLAG(NWS).EQ.11) THEN
C    HAVE !FT
          READ(UTVSN(NWS),'(3X,I2)') DN
          FTCHAN=.TRUE.
        ELSE
C
C... CONSTRUCT SHORT BLOCKS FOR USE BY USETAPE
C
          SHBLK1(1:1)=CHAR(28)
          SHBLK1(2:2)=CHAR(29)
          SHBLK1(3:3)=CHAR(30)
          SHBLK1(4:8)='B  1 '
          SHBLK1(9:16)=ASHEDR(151:158)
C
          SHBLK2( 1: 10)=ASHEDR( 31: 40)
          SHBLK2(11: 40)=ASHEDR(151:180)
          SHBLK2(41: 70)=ASHEDR( 91:120)
          SHBLK2(91:130)=ASHEDR( 51: 90)
          CALL DFX01K(DN,SHBLK1,SHBLK2,IERR)
          USETPE=.TRUE.
          RETURN
        ENDIF
      ELSE
        UTFLAG(NWS) = -1
        DO 50  I=4,1,-1
  50    IF(FORM(I:I).NE.' ') GOTO 51
  51    NFORM=I
        WRITE(JCL,JCLFMT) FORM(1:NFORM),OUTLIM
      ENDIF
C
C   CREATE EBCDIC VERSION OF HEADER RECORD
C
      CALL DFXM02(ASHEDR,EBHEDR)
C
C   CALCULATE HASH WORD FROM EBCDIC HEADER INFORMATION
C
      CHKSUM=EBHEDR(1)
      DO 100 I=2,NWH
  100 CHKSUM=CHKSUM.XOR.EBHEDR(I)
      CHKSUM=SHIFTL(CHKSUM,32).AND.MASK(24)
C
      CALL WRITEP(DN,EBHEDR,NWH)
      CALL WRITE (DN,CHKSUM,1,32)
      CALL WRITEP(DN,ASHEDR,NWH)
      CALL WRITE (DN,CHKSUM,1,32)
      LENERR = .FALSE.
      BYTES = 2*(240 + HBYTES)
      NREC=2
      IERR=0
      RETURN
C-----------------------------------------------------------------
C
C
      ENTRY DFX02B(RBUFF,BUFFPT,DTYPE)
C
C        NWORD  : WORD IN WHICH TO BEGIN PACKING HASH AND DTYPE
C        NPARCEL: NUMBER OF 16-BIT DICOMED INSTRUCTIONS IN
C                 BUFF(NWORD)   0 - 3
C
      IF (USETPE) THEN
        CALL DFX01L(RBUFF,BUFFPT,DTYPE)
      ENDIF
      NWORD=(BUFFPT/4)+1
      NPARCEL=MOD(BUFFPT,4)
C
C        PACK CHKSUM AND DTYPE INTO HIGH FOUR BYTES OF TEMP
C        NOTE: CHKSUM IS STORED LEFT JUSTIFIED
C
C        ADD THIS ONTO RBUFF(NWORD). IF NPARCEL=3 THE LOWER
C        2 BYTES OF TEMP WILL GO INTO THE NEXT WORD OF RBUFF
C
C         ----------------- -----------------
C         |P:P|P:P|P:P|C:C| |C:D|0:0|0:0|0:0|
C         ----------------- -----------------
C  RBUFF      NWORD             NWORD+1
C
      TEMP=CHKSUM.OR.SHIFTL(DTYPE,32)
      RBUFF(NWORD)=(RBUFF(NWORD).AND.MASK(NPARCEL*16))
     +              .OR.SHIFTR(TEMP,NPARCEL*16)
      IF (NPARCEL.EQ.3)  THEN
        NWORD=NWORD+1
        RBUFF(NWORD)=SHIFTL(TEMP,16)
      ENDIF
C
      IF (USETPE) GO TO 102
      CALL WRITE(DN,RBUFF,NWORD,UBC(NPARCEL))
      NREC=NREC+1
      BYTES = BYTES + 2*BUFFPT + HBYTES
      IF (BYTES.GT.MAXBYT) THEN
                  IF (.NOT.LENERR) THEN
                             LENERR = .TRUE.
                             CALL DFX01E(2,MAXBYT)
                  ENDIF
      ENDIF
  102 IF (DTYPE.NE.0) THEN
                  DO 101 I=1,NWORD
  101             RBUFF(I) = 0
      ENDIF
      BUFFPT=0
      RETURN
C-----------------------------------------------------------------
      ENTRY DFX02C(RAST,IERR,NOBYTE,SD)
      IF (SD.EQ.1) THEN
C    IF SD = 1 SD PARAMETER ON JOB STATEMENT SO ISSUE DISPOSE WITH WAIT
               WAIT = 'WAIT'L
      ELSE
C    NO SD PARAMETER - NOWAIT ON DISPOSE
               WAIT = 'NOWAIT'L
      ENDIF
      NOBYTE = BYTES
      IF (USETPE) THEN
        CALL DFX01M(NOBYTE,SHBLK1,SHBLK2,WAIT,IERR)
        GO TO 999
      ELSE IF (FTCHAN) THEN
        REWIND DN
        GO TO 999
      ELSE
           IF (RAST) JCL(9:9)='I'
*IF DEF,UNICOS
      CLOSE(DN)
      JCL(90:90) = ''''
      IERR = ISHELL
     1       ('dispose $TMPDIR/.dfxd02 -dPT -mM1 -fBB -S -t'''//JCL)
      IERR0 = ISHELL('assign dfxd02')
      IERR0 = ISHELL('rm $TMPDIR/.dfxd02 2>/dev/null')
*ELSE
*/  MUST BE COS
           JCL(90:90)=CHAR(0)
           CALL DISPOSE (IERR,
     +              'DN'L    , DN      ,
     +              'DC'L    , 'PT'L   ,
     +              'MF'L    , 'VS'L   ,
     +              'DF'L    , 'BB'L   ,
     +              'TEXT'L  , JCL     ,
     +              WAIT                 )
*ENDIF
           IF (IERR.NE.0) CALL DFXMSA(IERR)
      ENDIF
C    AT TERMINATION MUST CANCEL USETAPE - IF SUBSEQUENT
C    OPEN OF DEVICE USER MUST RESPECIFY USETAPE
C    (NECESSARY TO AVOID OVERWRITING TAPE/FILE)
  999 UTFLAG(NWS) = 0
      UTVSN(NWS) = '0'
      USETPE = .FALSE.
      FTCHAN = .FALSE.
      RETURN
      END
