*DECK COSZ00 F
      SUBROUTINE DFXZ00(ARG1,ARG2,ARG3,ARG4,ARG5,ARG6,LARG1,CARG1)
C    D35C DIRECT DEVICE DRIVER FOR DICOMED 35MM COLOUR MODE
C    UTILISING DICOMED DDC - COS MACHINE VERSION
C
C    NOTE:  THIS VERSION PERFORMS NO TRANSFORMATIONS OR CHECKING.
C           IT SHOULD BE USED ONLY FROM RESPONSIBLE HIGH LEVEL
C           PRODUCTS.   PLOT OUTPUT IS TO THE NORMAL DICOMED
C           QUEUES.
C
C
C
C    ********************************************************
C    *                                                      *
C    *    DEVICE MUST BE INITIALISED BY D48D<35C/35/16C/16> *
C    *      - INTO MAIN ENTRY DFXZ00                        *
C    *    INPUT PARAMETERS:                                 *
C    *                                                      *
C    *      ARG1 - X-COORD MAXIMUM IN DEVICE UNITS          *
C    *      ARG2 - Y-COORD MAXIMUM IN DEVICE UNITS          *
C    *      ARG3 - X OFFSET IN DEVICE UNITS                 *
C    *      ARG4 - Y OFFSET IN DEVICE UNITS                 *
C    *      ARG5 - DEVICE INITIAL ROTATION                  *
C    *              0 = COMIC                               *
C    *              1 = CINE                                *
C    *      ARG6 - DEVICE INITIAL ISCAN                     *
C    *              NOTE - ARG5+6 GIVE INITIAL HVI          *
C    *      LARG1- DEVICE COLOUR                            *
C    *              .TRUE. = COLOUR                         *
C    *              .FALSE. = MONO                          *
C    *      CARG1- DEVICE MNEMONIC (4 CHARACTERS USED)      *
C    *                                                      *
C    *                                                      *
C    *    THIS ALSO SETS UP EXTERNAL REFERENCES FOR LOW     *
C    *    LEVEL DRIVER-SYSTEM COMMUNICATION ROUTINES.       *
C    *                                                      *
C    *    ALL PLOTTING MUST BE DONE BY D48... ENTRIES.      *
C    *                                                      *
C    *    NOTE: NO MODE SWITCHES/RESERVED (ULCC) OPS        *
C    *          WILL BE ISSUED UNLESS SPECIFICALLY          *
C    *          REQUESTED.  OFFSETS WILL BE APPLIED         *
C    *          AS PER ULCC SETUP; HOWEVER, THESE MAY       *
C    *          BE AMENDED BY A REFERENCE TO D48OST.        *
C    *                                                      *
C    *                                                      *
C    *                                                      *
C    *                                                      *
C    *                COPYRIGHT 1988: JOHN C. GILBERT       *
C    *                                                      *
C    ********************************************************
C
C    DRIVER VERSION IS OF FORM NN.N
C
      IMPLICIT INTEGER (A-Z)
      LOGICAL LARG1,COLOUR
      CHARACTER*(*) CARG1
      CHARACTER*4 DVERSN
      PARAMETER (DVERSN=' 0.1')
      CHARACTER*4 FORMID
      PARAMETER (FORMID='D35C')
C    USES DFX04A,B,C FOR I/O
*CALL,DFXC05
*CALL,DFXCP0
*CALL,COSK01
C    SIZBUF IS OUTPUT BUFFER SIZE IN BYTES, LAST 4 BYTES FOR
C    CHECKSUM (3 BYTES) AND DATA TYPE (1 BYTE)
C    MAXBUF IS MAXIMUM AVAILABLE 16 BIT INSTRUCTIONS
C    BUFFPT POINTS TO NEXT AVAILABLE 16 BIT INSTRUCTION
C      NOTE - 0 POINTS TO FIRST INSTRUCTION (BUFFER ARRAY STARTS AT 0)
C      FOR OUTPUT WILL BE NUMBER OF 16 BIT INSTRUCTION WORDS TO TRANSFER
C    RBUFF IS DATA BUFFER, AS ARRAY STARTING AT ZERO (ALLOWING FOR
C                                                     4 BYTE TRAILER)
C    DTYPE IS DATA TYPE 1 - RED(1), 2 - GREEN(2), 3 - BLUE(4) DDC DATA
C    CTYPE IS DATA TYPE 0 - CONTROL BLOCK
C    RAST (LOGICAL) SET TRUE IF ANY RASTER DATA ENCOUNTERED, ELSE FALSE
C    CNTL IS CONTROL BLOCK, 32 BYTES IN LENGTH (MAXCNT+2 16-BIT WORDS)
C                           1-22  TEXT
C                                 (FOR CRAY 17-20 UNUSED,
C                                           21-22 FLAG 1 MNEMONIC)
C                           23    FLAG BYTE 1
C                                 VALUE = 1   SD (START DOUBLE FRAMING)
C                                       = 2   ED (END DOUBLE FRAMING)
C                                       = 4   RS (RESET)
C                                       = 8   FA (FRAME ADVANCE)
C                                       = 16  EJ (END-OF-JOB)
C                                 (ONE FLAG ONLY PER CONTROL BLOCK)
C                           24    FLAG BYTE 2
C                           25-28 REPEAT COUNT
C                           29-32 ALLOW FOR TRAILER
C    LOPFA IS USED TO INDICATE (IN CONJUNCTION WITH WSDSE) LAST OP
C    BEING FRAME ADVANCE - IT IS ONLY SET FALSE BY BUFFER OUTPUT THAT
C    DOES NOT SET WSDSE AS FALSE
      INTEGER Z00FF,ZFFFF
      PARAMETER (Z00FF=255,ZFFFF=65535)
      PARAMETER(M8=Z00FF,M16=ZFFFF)
      INTEGER Z7FFF
      PARAMETER (Z7FFF=32767)
      PARAMETER (M15=Z7FFF)
      LOGICAL LOPFA,RAST
      INTEGER SIZBUF,MAXBUF,BUFFPT(3),DTYPE(3),CTYPE,REPCNT,MAXCNT,CPT
      INTEGER FRAMES,LENBUF
      CHARACTER*7 CBYTE
      CHARACTER*1 CFRAM
      INTEGER RTYPE,GTYPE,BTYPE
      INTEGER OP0,OP2,OP6,OP7,OPMW,OPSS
      INTEGER MW,SS,MWLAST(3),SSLAST(3)
      INTEGER VPAPPD(0:3),PPD,FILTER(3),RFILT,GFILT,BFILT
      INTEGER FB11,FB12,FB14,FB18,FB116
      INTEGER MODE,VECTOR,RASTER,FILMAD,UNSET
      LOGICAL RGB0(3)
      INTEGER Z0000,Z4000,ZC000,ZE000
      PARAMETER (Z0000=0,Z4000=16384,ZC000=49152,ZE000=57344)
      PARAMETER (OP0=Z0000,OP2=Z4000,OP6=ZC000,OP7=ZE000)
      INTEGER ZF010,ZF070
      PARAMETER (ZF010=61456,ZF070=61552)
      PARAMETER (OPMW=ZF010,OPSS=ZF070)
      INTEGER Z0100,Z0200,Z0400,Z0800
      PARAMETER (Z0100=256,Z0200=512,Z0400=1024,Z0800=2048)
      PARAMETER (FB11=Z0100,FB12=Z0200,FB14=Z0400,FB18=Z0800)
      INTEGER Z1000,Z1800
      PARAMETER (Z1000=4096,Z1800=6144)
      PARAMETER (FB116=Z1000)
C    SET 2 CHARACTER MNEMONIC TO PREFACE FB1 CODE
C    (NOTE TRAILING ZERO TO ALLOW SIMPLE OR INTO CRAY WORD)
      INTEGER SD,ED,RS,FA,EJ
      PARAMETER (SD=34261000000B,ED=30561000000B)
      PARAMETER (RS=33170400000B,FA=30660200000B)
      PARAMETER (EJ=30564200000B)
      PARAMETER (VECTOR=17,RASTER=16,FILMAD=7,UNSET=-100)
      INTEGER OP1,FN1,FN7,ECS5,ECS6
      INTEGER Z2000,Z3000,ZF000,ZE0
      PARAMETER (Z2000=8192,Z3000=12288,ZF000=61440,ZE0=224)
      PARAMETER (OP1=Z2000,FN1=Z3000,FN7=ZF000)
      PARAMETER (ECS5=5,ECS6=6,MORICS=0,MCUICS=Z2000)
      PARAMETER (MHVI=ZE0)
C    MORICS IS EXTENDED INSTRUCTION FOR MASK AGAINST ORIGINAL ICS
C    MCUICS IS EXTENDED INSTRUCTION FOR MASK AGAINST CURRENT ICS
C    MHVI IS BIT MASK FOR HVI FIELD (BITS 5-7)
      LOGICAL DOICS,DOMODE,DOSPOT,DOLWID
      INTEGER CURHVI,HVIV,HVIR
C    ICSSET IS SET TRUE IF ANY ICS SET OPERATION IS PERFORMED
C    ICSMSK THEN HOLDS ACCUMULATED ICS SET BIT MASK, AND
C    ICSVAL IS CURRENT ICS SET BIT PATTERN
      LOGICAL ICSSET
      INTEGER ICSMSK,ICSVAL
      PARAMETER (RTYPE=1,GTYPE=2,BTYPE=4,CTYPE=0)
      PARAMETER (RFILT=Z0200,GFILT=Z0400,BFILT=Z0800)
      PARAMETER (SIZBUF=1024,MAXBUF=(SIZBUF-4)/2,MAXCNT=14)
      PARAMETER (LENBUF=(SIZBUF/8)-1)
      INTEGER RBUFF(0:LENBUF,3),CNTL((MAXCNT+2)/4)
C                PIXEL SPECIFICATIONS
C    PIXSIZ IS FLAG IF PIXEL PARAMETERS HAVE BEEN RESET AND NEED
C    TRANSMISSION TO D48
      LOGICAL PIXSIZ
C    PIXEL DIMENSIONS ARE SET BY
C                    IHPE  -  HORIZONTAL POINTS PER ELEMENT
C                    IVPE  -  VERTICAL POINTS PER ELEMENT
C                    IHES  -  HORIZONTAL ELEMENT SPACING
C                    IHPS  -  HORIZONTAL POINT SPACING
C                    IVES  -  VERTICAL ELEMENT SPACING
C                    IVPS  -  VERTICAL POINT SPACING
      INTEGER IHPE,IVPE,IHES,IHPS,IVES,IVPS
C    PIXEL ELEMENT SPACING IS HELD ALSO AS
C                    HESDC -  HORIZONTAL ELEMENT SPACING IN DC UNITS
C                    VESDC -  VERTICAL ELEMENT SPACING IN DC UNITS
      REAL HESDC,VESDC
C    SCAN DIRECTION IS DETERMINED BY H-REV, V-REV, H-V INTERCHANGE
C    THESE DEPEND ON COMIC/CINE MODES AND SELECTED VIA ISCAN
C    COMIC = 0, CINE = 1 HELD IN DROT
      INTEGER ISCAN,HVI(0:3,0:1),DROT
C    SCAN DIRECTION AND VALUE AS SHOWN:
C
C
C                          X2Y2    X2Y2          X1Y1               X1Y1
C                    O........      ........O     .........    .........
C DROT               ..      .      .      ..     .      ..    ..      .
C   0  HVI - COMIC   . . 3   .      .   7 . .     .   1 . .    . . 5   .
C                    .  .    .      .    .  .     .    .  .    .  .    .
C      ISCAN         .   0   .      .   1   .     .   2   .    .   3   .
C                    .    .  .      .  .    .     .  .    .    .    .  .
C   1  HVI - CINE    .   6 . .      . . 2   .     . . 4   .    .   0 . .
C                    .      ..      ..      .     ..      .    .      ..
C                    .........      .........     O........    ........O
C                   X1Y1                  X1Y1          X2Y2  X2Y2
C
C                     L TO R         R TO L         L TO R       R TO L
C                     T TO B         T TO B         B TO T       B TO T
C
C                                     ALL HORIZONTAL SCANS
C
C             N.B.  VECTOR PLOTTING IS WITH ISCAN = 2
C
C                   ROTATION MODE DEFAULTS ACCORDING TO DEVICE
C
C   WSCL IS PRE-CLIPPING RECTANGLE IN DC (E.G. FOR PIXEL ARRAYS)
C   WSBL IS PRE-BLANKING RECTANGLE IN DC (E.G. FOR PIXEL ARRAYS)
      REAL WSCL(4),WSBL(4)
C   CELL ARRAY IS STORED LOCALLY WHEN FIRST USED
C   XRAST,YRAST HOLD   0 - START/CURRENT SCAN LINE
C                      1 - LOWER LIMITS OF CELL ARRAY IN DC UNITS
C                      2 - UPPER LIMITS OF CELL ARRAY IN DC UNITS
C                      3 - END OF SCAN LINES
      REAL XRAST(0:3),YRAST(0:3)
C   CELOUT IS SET TRUE IF CELL AREA IS WHOLLY INVISIBLE
C   (FOR LINE MODE IS SET ON INITIAL ENTRY AND USED ON SUBSEQUENT ONES)
C    BLANK IS SET TRUE IF LCAP(2) IS TRUE AND BLANKING IS POSSIBLE
C    LRUN IS LOCAL FLAG FOR ACTUAL RUN LENGTH OR EVERY ELEMENT OUTPUT
      LOGICAL CELOUT,BLANK,LRUN
C    ISR IS SHIFTS FOR CRAY PIXEL DATA IN SCAN
      INTEGER ISR(4)
      REAL Z3(3)
      LOGICAL LCOL,RASTEX
      LOGICAL PUREDC,TRANSX
      LOGICAL USETPE
      CHARACTER*4 CUSE
      CHARACTER*240 RECORD
      SAVE
      DATA RECORD(1:90)/'1         XX        DPLOT'/
      DATA RECORD(91:120)/'D48-DDC V 0.1    XXXX-Z00:****'/
      DATA RECORD(121:240)/'          XX'/
      DATA CNTL/1423116075334270740722B,
     1           403036555274366353323B,
     2           0,0/
      DATA VPAPPD/Z0000,Z0800,Z1000,Z1800/
      DATA DTYPE/RTYPE,GTYPE,BTYPE/
      DATA FILTER/RFILT,GFILT,BFILT/
      DATA HVI/3,7,1,5,6,2,4,0/
      DATA ISR/24,32,40,16/
C
C     ====================================================
C     =                                                  =
C     =     INITIALISATION ENTRY: DFXZ00                 =
C     =        - SETS UP DEVICE COORDINATE MAXIMA        =
C     =                  AND OFFSETS                     =
C     =        - FLAGS IF COLOUR/MONOCHROME DEVICE       =
C     =                                                  =
C     ====================================================
C
C
      XDCMAX = ARG1
      YDCMAX = ARG2
      XDCORG = ARG3
      YDCORG = ARG4
      DROT = ARG5
      ISCAN = ARG6
      COLOUR = LARG1
      CHANLS = 1
      IF (COLOUR) CHANLS = 3
      RECORD(108:111) = CARG1
C    OPEN PLOT FILE
      CALL DFXMS3(RECORD(31:38))
      CALL DFXMS8(RECORD(51:70))
      CALL DFXMS5(RECORD(71:90))
      CALL DFXMS4(RECORD(151:158))
      CALL DFXMS2(RECORD(162:169))
      CALL DFXMS1(RECORD(172:179))
      CALL DFXMS9(RECORD(221:240))
C    PLUG DEVICE DRIVER VERSION
      RECORD(117:120) = DVERSN
      DO 10008 J=1,CHANLS
      DO 10008 I=0,LENBUF
10008 RBUFF(I,J) = 0
      FRAMES = 0
C    FLAG IF USETAPE USE
      USETPE = UTFLAG(NWS).GT.0
C
      PUREDC = .TRUE.
      TRANSX = .FALSE.
      DOMODE = .FALSE.
      DOSPOT = .FALSE.
      DOLWID = .FALSE.
      DOICS = .FALSE.
C
C    ********************************************************
C    *                                                      *
C    *   PURE DDC CODES WILL BE GENERATED UNLESS ICS IS     *
C    *   SPECIFICALLY SET, WHEN ICS WILL BE RESET AT        *
C    *   EACH SUBSEQUENT RESET/ADVANCE OPERATION.           *
C    *                                                      *
C    *   NO TRANSFORMATIONS WILL BE APPLIED TO INPUT        *
C    *   COORDINATES UNLESS D48TRX IS USED TO TURN          *
C    *   TRANSX ON - WHEN SET ON INPUT COORDINATES          *
C    *   WILL BE ASSUMED TO BE SPECIFIED UNDER NORMAL       *
C    *   CARTESIAN COORDINATES (ISCAN=2) AND THE            *
C    *   TRANSFORMATION WILL BE TO THE COORDINATE           *
C    *   SYSTEM CORRESPONDING TO THE CURRENT ISCAN          *
C    *   EQUIVALENT OF THE SPECIFIED HVI (IF ITRAN=0)       *
C    *   OR TO THE SYSTEM ISCAN=ITRAN.                      *
C    *                                                      *
C    ********************************************************
C                                                           *
      CALL DFX04A(FORMID,500000,RECORD,IFAIL)
C    SET 4-BYTE FORM ID, LINE LIMIT, GET ERROR CONDITION
      IF (IFAIL.EQ.0) GO TO 10001
C    FLAG ERROR HERER
      STOP 26
10001 RAST = .FALSE.
C     N.B. THIS DEVICE STORES NO LUTS - ASSUMES USER
C          IS AWARE OF STATE OF D48 AND ISSUES LUT
C          OR DIRECT COLOUR VALUES AS APPROPRIATE
      PIXSIZ = .TRUE.
C    FORCE PIXEL DEFINITION, DEFAULT IS 2048X2048 WITH 2X2 ELEMENTS
C
C    HORIZONTAL/VERTICAL POINTS/ELEMENT = 2
C    HORIZONTAL/VERTICAL ELEMENT SPACING = 16 (=2 WITH 3 BINARY POINTS)
C    HORIZONTAL/VERTICAL POINT SPACING = 8 (=1 WITH 3 BINARY POINTS)
C
C    SPACING IN TERMS OF 4K RASTER DEVICE (N.B. VECTOR:RASTER RATIO 8:1)
C
      IHPE = 2
      IVPE = 2
      IHES = 16
      IHPS = 8
      IVES = 16
      IVPS = 8
      HESDC = IHES
      VESDC = IVES
      XDCOR0 = XDCORG
      YDCOR0 = YDCORG
      HVIV = HVI(ISCAN,DROT)
      CURHVI = HVIV
C    AT OPEN CLEAR ICS FLAGS
      ICSSET = .FALSE.
      ICSMSK = 0
      ICSVAL = 0
      BUFFPT(1) = 0
      BUFFPT(2) = 0
      BUFFPT(3) = 0
      ASSIGN 9999 TO JUMP
      GO TO 10025
C
      ENTRY D48MOV(ARG1,ARG2)
C
C     ====================================================
C     =                                                  =
C     =     BEAM POSITION ENTRY: D48MOV                  =
C     =                                                  =
C     =           - POSITIONED TO (ARG1,ARG2)            =
C     =                                                  =
C     ====================================================
C
C
      PPD = VPAPPD(0)
      GO TO 2
C
      ENTRY D48SPT(ARG1,ARG2)
C
C     ====================================================
C     =                                                  =
C     =     SPOT ENTRY: D48SPT                           =
C     =                                                  =
C     =           - PLOT SPOT AT (ARG1,ARG2)             =
C     =                                                  =
C     ====================================================
C
C
      PPD = VPAPPD(1)
      GO TO 2
C    IF = 4 ON MOVE
    1 XD = XDCO + X*DSCALE
      YD = YDCO + Y*DSCALE
C
      ENTRY D48DRW(ARG1,ARG2)
C
C     ====================================================
C     =                                                  =
C     =     DRAW ENTRY: D48DRW                           =
C     =                                                  =
C     =           - DRAW WITH BEAM ON TO (ARG1,ARG2)     =
C     =                                                  =
C     ====================================================
C
C
      PPD = VPAPPD(2)
C
C    COMMON CODE TO MOVE/DRAW/SPOT
C
    2 XD = XDCO + ARG1
      YD = YDCO + ARG2
      IF (TRANSX) THEN
      ENDIF
      DO 1 I=1,CHANLS
      IF ((BUFFPT(I)+3).GE.MAXBUF)
     1           CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
      INS = OP2.OR.PPD
      IW = SHIFTR(BUFFPT(I),2)
      IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
      RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
      INS = INT(XD+.5).AND.M15
      IW = SHIFTR(BUFFPT(I)+1,2)
      IB16 = SHIFTL((3-((BUFFPT(I)+1).AND.3)),4)
      RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
      INS = INT(YD+.5).AND.M15
      IW = SHIFTR(BUFFPT(I)+2,2)
      IB16 = SHIFTL((3-((BUFFPT(I)+2).AND.3)),4)
      RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
      BUFFPT(I) = BUFFPT(I) + 3
    1 CONTINUE
      XDLAST = XD
      YDLAST = YD
 9999 RETURN
10032 RASTEX = .TRUE.
      GO TO 9999
C                PIXEL CODE
   10 CONTINUE
C    NPAR = 0 IS CELL ARRAY OPTION
C    NPAR > 0 IS LINE CELL  OPTION
      IF ((NPAR.GT.1).AND.(IFLAST.EQ.10)) THEN
C    IF CONTINUATION ENTRY FOR LINE CELL CHECK IF TOTALLY VALID
        IF (RASTEX) GO TO 9999
C    OR SEE IF OUT OF VALID RANGE
        IF (NPAR.GT.NRAST2) GO TO 10032
C    OR NOT YET INTO VALID RANGE
        IF (NPAR.LT.NRAST1) GO TO 9999
      ELSE
        RASTEX = .FALSE.
C    CONVERT CLIP AREA TO WS DC
        WSCL(1) = XDCO + NDCL(1)*DSCALE
        WSCL(2) = XDCO + NDCL(2)*DSCALE
        WSCL(3) = YDCO + NDCL(3)*DSCALE
        WSCL(4) = YDCO + NDCL(4)*DSCALE
        IF (LPAR(2)) THEN
C    CONVERT BLANKING AREA TO WS DC (IF APPLICABLE AND NOT SEGMENT)
             WSBL(1) = XDCO + NDBL(1)*DSCALE
             WSBL(2) = XDCO + NDBL(2)*DSCALE
             WSBL(3) = YDCO + NDBL(3)*DSCALE
             WSBL(4) = YDCO + NDBL(4)*DSCALE
        ENDIF
C    CONVERT CELL ARRAY AREA TO WS DC
C    (NO TRANSFORMATION CURRENTLY PERMITTED)
        XRAST(1) = XDCO + XPAR(1)*DSCALE
        XRAST(2) = XDCO + XPAR(2)*DSCALE
        YRAST(1) = YDCO + YPAR(1)*DSCALE
        YRAST(2) = YDCO + YPAR(2)*DSCALE
C    NOW GET SCAN IN WS DC (CURRENTLY NO TRANSFORMATION)
C
C
C    ALLOW FOR PRECLIPPING IN GETTING START/END POSITIONS
C    DO HORIZONTAL SCANS FIRST
        CELOUT = .TRUE.
C    COMBINE WITH CHECK ON VALIDITY AFTER CLIPPING
        IF (XRAST(1).LE.XRAST(2)) THEN
C    LEFT TO RIGHT
             ISCAN = 0
             XRAST(0) = MAX(XRAST(1),WSCL(1))
             XRAST(3) = MIN(XRAST(2),WSCL(2))
C    FORCE XRAST(0) TO NEXT ADDRESSABLE (VECTOR) POINT (L TO R)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING
             IX0 = IRNDUP(XRAST(0))
             XRAST(0) = IX0
             IF (XRAST(0).GT.XRAST(3)) GO TO 10032
             X1 = XRAST(0)
             X2 = XRAST(3)
        ELSE
C    RIGHT TO LEFT
             ISCAN = 1
             XRAST(0) = MIN(XRAST(1),WSCL(2))
             XRAST(3) = MAX(XRAST(2),WSCL(1))
C    FORCE XRAST(0) TO LAST ADDRESSABLE (VECTOR) POINT (R TO L)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING (FROM R)
             IX0 = XRAST(0)
             XRAST(0) = IX0
             IF (XRAST(3).GT.XRAST(0)) GO TO 10032
             X1 = XRAST(3)
             X2 = XRAST(0)
        ENDIF
C    THEN DO VERTICAL SCAN
        IF (YRAST(1).LE.YRAST(2)) THEN
C    TOP TO BOTTOM
             YRAST(0) = MIN(YRAST(2),WSCL(4))
             YRAST(3) = MAX(YRAST(1),WSCL(3))
C    FORCE YRAST(0) TO LAST ADDRESSABLE (VECTOR) POINT (T TO B)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING (FROM T)
             IY0 = YRAST(0)
             YRAST(0) = IY0
             IF (YRAST(3).GT.YRAST(0)) GO TO 10032
             Y1 = YRAST(3)
             Y2 = YRAST(0)
        ELSE
C    BOTTOM TO TOP
             ISCAN = ISCAN + 2
             YRAST(0) = MAX(YRAST(2),WSCL(3))
             YRAST(3) = MIN(YRAST(1),WSCL(4))
C    FORCE YRAST(0) TO NEXT ADDRESSABLE (VECTOR) POINT (B TO T)
C      - IF WANT FIXED RASTER REFERENCE SHOULD MOD THIS
C        ACCORDING TO RASTER ELEMENT SPACING
             IY0 = IRNDUP(YRAST(0))
             YRAST(0) = IY0
             IF (YRAST(0).GT.YRAST(3)) GO TO 10032
             Y1 = YRAST(0)
             Y2 = YRAST(3)
        ENDIF
C    X1 = MIN(XRAST(0),XRAST(3))
C    X2 = MAX(XRAST(0),XRAST(3))
C    Y1 = MIN(YRAST(0),YRAST(3))
C    Y2 = MAX(YRAST(0),YRAST(3))
C    NOW CHECK VALIDITY OF AREA AGAINST BLANKING (IF ANY)
        BLANK = LPAR(2)
        IF (LPAR(2)) THEN
          IF ((X1.GE.WSBL(1)).AND.(X2.LE.WSBL(2)).AND.
     1    (Y1.GE.WSBL(3)).AND.(Y2.LE.WSBL(4))) GO TO 10032
C    NOT TOTALLY OCCLUDED, SO CHECK FOR ANY POSSIBLE BLANKING
          IF ((X1.GT.WSBL(2)).OR.(X2.LT.WSBL(1)).OR.
     1    (Y1.GT.WSBL(4)).OR.(Y2.LT.WSBL(3))) BLANK = .FALSE.
        ENDIF
        CELOUT = .FALSE.
C***********SET SCAN DIRECTION***********
        DOMODE = (MODE.NE.RASTER)
        HVIR= HVI(ISCAN,DROT)
        DOICS = (CURHVI.NE.HVIR)
CPURE+IF PURE DDC AVOID ICS CALL
CPURE.IF (PUREDC) DOICS = .FALSE.
CPURE-
        IF (DOICS) THEN
            CURHVI = HVIR
            ICSSET = .TRUE.
            ICSMSK = ICSMSK.OR.MHVI
            ICSVAL = (ICSVAL.AND..NOT.MHVI).OR.SHIFTL(CURHVI,5)
        ENDIF
        IXR = IX0
        IYR = IY0
        IF (HVIV.NE.HVIR) THEN
C    MUST GET COODINATES IN NEW ICS REFERENCE SYSTEM
C
C STEP 1: IGNORE INTERCHANGE AND REDUCE TO H,V NORMAL FOR VECTOR SYSTEM
C
C       NEGATE H-REVERSE
           IF ((SHIFTR(HVIV,2).AND.1).EQ.1) IXR = 32767 - IX0
C       NEGATE V-REVERSE
           IF ((SHIFTR(HVIV,1).AND.1).EQ.1) IYR = 32767 - IY0
C
C       IF VECTOR AND RASTER HAVE SAME INTERCHANGE CAN SKIP SWITCH
C
           IF ((HVIV.AND.1).NE.(HVIR.AND.1)) THEN
C STEP 2: PERFORM INTERCHANGE (LEAVING H,V NORMAL FOR RASTER SYSTEM)
                   IXS = IXR
                   IXR = 32767 - IYR
                   IYR = 32767 - IXS
           ENDIF
C
C STEP 3: NOW IN RASTER SYSTEM, BUT H,V NORMAL SO PERFORM ANY REVERSE
C
C       PERFORM H-REVERSE
           IF ((SHIFTR(HVIR,2).AND.1).EQ.1) IXR = 32767 - IXR
C       PERFORM V-REVERSE
           IF ((SHIFTR(HVIR,1).AND.1).EQ.1) IYR = 32767 - IYR
C
        ENDIF
C
C    IF PIXSIZ REQUIRES SPECIFICATION AND HAVE ALREADY GENERATED
C    RASTER OPS MUST DO RESET ON ALL STREAMS FIRST
C
        IF (PIXSIZ.AND.RAST) THEN
                            ASSIGN 10030 TO JUMP
                            GO TO 10028
        ENDIF
      ENDIF
10030 IF ((NPAR.LE.1).OR.(IFLAST.NE.10)) THEN
C
        DO 10011 I=1,3
C    SET RASTER ON ALL STREAMS
        IF (DOMODE) THEN
C                   SELECT RASTER MODE
                          MODE = RASTER
                          INS = OP0.OR.MODE
                          IW = SHIFTR(BUFFPT(I),2)
                          IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
                          RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
                          BUFFPT(I) = BUFFPT(I) + 1
                          IF (BUFFPT(I).EQ.MAXBUF)
     1                    CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
        ENDIF
        IF (DOICS) THEN
C    SET RASTER HVI - NOTING THIS MUST BE BEFORE POSITIONING
                   IF (BUFFPT(I)+3.GE.MAXBUF)
     1             CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
                   INS = OP0.OR.ECS6
                   IW = SHIFTR(BUFFPT(I),2)
                   IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
                   RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
                   INS = MCUICS.OR.MHVI
                   IW = SHIFTR(BUFFPT(I)+1,2)
                   IB16 = SHIFTL((3-((BUFFPT(I)+1).AND.3)),4)
                   RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
                   INS = SHIFTL(HVIR,5)
                   IW = SHIFTR(BUFFPT(I)+2,2)
                   IB16 = SHIFTL((3-((BUFFPT(I)+2).AND.3)),4)
                   RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
                   BUFFPT(I) = BUFFPT(I) + 3
        ENDIF
C    FORCE POSITION TO START OF SCAN
C       NOTE - USING COORDINATES IN RASTER HVI SYSTEM
        IF ((BUFFPT(I)+3).GE.MAXBUF)
     1                    CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
        INS = OP2.OR.VPAPPD(0)
        IW = SHIFTR(BUFFPT(I),2)
        IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
        RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
        INS = IXR.AND.M15
        IW = SHIFTR(BUFFPT(I)+1,2)
        IB16 = SHIFTL((3-((BUFFPT(I)+1).AND.3)),4)
        RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
        INS = IYR.AND.M15
        IW = SHIFTR(BUFFPT(I)+2,2)
        IB16 = SHIFTL((3-((BUFFPT(I)+2).AND.3)),4)
        RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
        BUFFPT(I) = BUFFPT(I) + 3
C    NOW DO OP5 INSTRUCTION IF NECESSARY
        IF (PIXSIZ) THEN
               IF ((BUFFPT(I)+3).GE.MAXBUF)
     1                  CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
               INS = 40960.OR.SHIFTL(IHES,6).OR.IHPS
               IW = SHIFTR(BUFFPT(I),2)
               IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
               RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
               INS = SHIFTL(IVES,6).OR.IVPS
               IW = SHIFTR(BUFFPT(I)+1,2)
               IB16 = SHIFTL((3-((BUFFPT(I)+1).AND.3)),4)
               RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
               INS = SHIFTL(IHPE,4).OR.IVPE
               IW = SHIFTR(BUFFPT(I)+2,2)
               IB16 = SHIFTL((3-((BUFFPT(I)+2).AND.3)),4)
               RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
               BUFFPT(I) = BUFFPT(I) + 3
        ENDIF
10011   CONTINUE
        IF (NPAR.GT.0) THEN
C    FOR SETUP GET VALID LINE RANGE
             DYRAST = (YRAST(1)-YRAST(2))/FLOAT(IPAR(6))
             NRAST1 = INT((YRAST(0)-YRAST(2))/DYRAST) + 1
             NRAST2 = INT((YRAST(3)-YRAST(2))/DYRAST) + 1
C    IF TOTALLY OUTSIDE RANGE EXIT WITH FLAG SETR
             IF (NPAR.GT.NRAST2) GO TO 10032
C    IF NOT YET IN RANGE EXIT
             IF (NPAR.LT.NRAST1) GO TO 9999
        ENDIF
      ENDIF
      PIXSIZ = .FALSE.
C    NOW GET LINE BY LINE RASTER SCAN
      HRAST = HESDC
      VRAST = VESDC
      XRAST0 = XRAST(0)
      YRAST0 = YRAST(0)
      XRAST1 = XRAST(1)
      YRAST1 = YRAST(1)
      XRAST2 = XRAST(2)
      YRAST2 = YRAST(2)
      XRAST3 = XRAST(3)
      YRAST3 = YRAST(3)
C    (NOTE - XRAST0,YRAST0 NEED NOT BE IDENTICAL WITH XRAST1,YRAST1
C          - CLIPPING MAY REQUIRE SUBAREA ONLY TO BE DISPLAYED)
 
      LCOL = LPAR(4)
C    FOR COLOUR DEVICE OUTPUT RASTER IS COLOUR IF INPUT RASTER IS COLOUR
C
C    FLAG AS INITIAL SET UP
      IVSC = 0
C
10020 CALLDFX01F(XARG,YARG,ZARG,NARG,IPAR(1),IPAR(2),D48LUT,MAXLUT,LCOL,
     1    BLANK,WSBL)
C    SAVE NEXT SCAN LINE POSITION
      YRAST(0) = YRAST0
C    SKIP IF INVALID RETURN
      IF (IVSC.LE.0) GO TO 9999
C         HERE FOR RASTER OPERATIONS
C    PERFORM OPS FOR EACH FILTER
      II = 4
      DO 10012 I=1,3
      RGB0(I) = .TRUE.
      IF (LCOL) II = I
      IF ((.NOT.LCOL).AND.(I.NE.1)) GO TO 10021
C    CHECK RUN LENGTH
      LRUN = RUN
      IF (.NOT.LRUN) THEN
C    NOT GLOBAL RUN LENGTH SO DO QUICK CHECK
C    IF SAVE MORE THAN HALF SCAN LENGTH BY COMPRESSION THEN GO AND
C    DO RUN LENGTH IMMEDIATELY
          NRLIM = (IHSC+1)/2
          NR = 0
          NLC = -1
          DO 10013 J=1,IHSC
          LC = SHIFTR(SCAN(J),ISR(II)).AND.M8
          IF (LC.EQ.NLC) THEN
                NR = NR + 1
                IF (NR.GE.NRLIM) THEN
                    LRUN = .TRUE.
                    GO TO 10014
                ENDIF
          ELSE
                NLC = LC
          ENDIF
10013     CONTINUE
      ENDIF
10014     CONTINUE
C    CLEAR ARRAY LSCAN TO ZERO
      DO 10015 J=1,513
10015 LSCAN(J) = 0
C    SET OP CODE 1
      LSCAN(1) = SHIFTL(OP1,48)
      IF (LRUN) THEN
C    IF RUN-LENGTH FOR THIS COLOUR THEN
C    SET FUNCTION CODE 7
          LSCAN(1) = LSCAN(1).OR.SHIFTL(FN7,32)
C    COMPRESS INTO LSCAN
          IW = 1
          IS = 24
C    (IW IS CURRENT WORD IN LSCAN, IS IS CURRENT SHIFT FOR BYTE)
          KOUNT = 0
C    KEEP COUNT OF 16-BIT ELEMENTS BUILT
          NLC = SHIFTR(SCAN(1),ISR(II)).AND.M8
          NR = 0
          DO 10016 J=1,IHSC
          LC = SHIFTR(SCAN(J),ISR(II)).AND.M8
          IF (RUN) THEN
             NR1 = SHIFTR(SCAN(J),48).AND.M16
          ELSE
             NR1 = 1
          ENDIF
          IF (LC.EQ.NLC) THEN
             NR = NR + NR1
          ELSE
             IF (NR.GE.256) THEN
                   NN = NR/256
                   DO 10017 K=1,NN
C               RUN-LENGTH ZERO IS SPECIAL CASE OF 256
                   LSCAN(IW) = LSCAN(IW).OR.SHIFTL(NLC,IS-8)
                   KOUNT = KOUNT + 1
                   IS = IS - 16
                   IF (IS.LT.0) THEN
                          IW = IW + 1
                          IS = 56
                   ENDIF
                   NR = NR - 256
10017              CONTINUE
             ENDIF
             IF (NR.GT.0) THEN
               LSCAN(IW)=LSCAN(IW).OR.SHIFTL(NR,IS).OR.SHIFTL(NLC,IS-8)
               KOUNT = KOUNT + 1
               IS = IS - 16
               IF (IS.LT.0) THEN
                   IW = IW + 1
                   IS = 56
               ENDIF
             ENDIF
             NLC = LC
             NR = NR1
          ENDIF
10016     CONTINUE
C    DO OUTSTANDING PIXELS
          IF (LC.EQ.0) THEN
C        IF ZERO DO NOT SCAN (UNLESS TOTALLY ZERO LINE WHEN DO 1 ZERO
C        (MAY WISH TO INSTATE SCAN IF ZERO EXPOSURE ENABLED?)
                   IF (KOUNT.EQ.0) THEN
                         KOUNT = 1
                         LSCAN(IW) = LSCAN(IW).OR.SHIFT(1,IS)
                   ENDIF
           ELSE
                   IF (NR.GE.256) THEN
                         NN = NR/256
                         DO 10018 K=1,NN
C                    RUN-LENGTH ZERO IS SPECIAL CASE OF 256
                         LSCAN(IW) = LSCAN(IW).OR.SHIFTL(NLC,IS-8)
                         KOUNT = KOUNT + 1
                         IS = IS - 16
                         IF (IS.LT.0) THEN
                               IW = IW + 1
                               IS = 56
                         ENDIF
                         NR = NR - 256
10018                    CONTINUE
                   ENDIF
                   IF (NR.GT.0) THEN
               LSCAN(IW)=LSCAN(IW).OR.SHIFTL(NR,IS).OR.SHIFTL(NLC,IS-8)
                          KOUNT = KOUNT + 1
                          IS = IS - 16
                          IF (IS.LT.0) THEN
                               IW = IW + 1
                               IS = 56
                          ENDIF
                   ENDIF
          ENDIF
      ELSE
C    NOT RUN LENGTH ENCODED FOR THIS COLOUR
C    SET FUNCTION CODE 1
          LSCAN(1) = LSCAN(1).OR.SHIFTL(FN1,32)
          IW = 1
          IS = 24
C    (IW IS CURRENT WORD IN LSCAN, IS IS CURRENT SHIFT FOR BYTE)
          KOUNT = 0
C    KEEP COUNT OF 8-BIT ELEMENTS BUILT (KOUNT IS LAST ENCOUNTERED
C                                        NON-ZERO ELEMENT)
          DO 10019 J=1,IHSC
          LC = SHIFTR(SCAN(J),ISR(II)).AND.M8
          IF (LC.NE.0) KOUNT = J
          LSCAN(IW) = LSCAN(IW).OR.SHIFTL(LC,IS)
          IS = IS - 8
          IF (IS.LT.0) THEN
                      IW = IW + 1
                      IS = 56
          ENDIF
10019     CONTINUE
C     ENSURE AT LEAST 1 ELEMENT
C        - IF TRAILING ZEROS REQUIRED SET KOUNT = IHSC
          KOUNT = MAX(1,KOUNT)
      ENDIF
C    ADD IN KOUNT
      LSCAN(1) = LSCAN(1).OR.SHIFTL(KOUNT,32)
10021 CONTINUE
C
C    GET WORD COUNT TO TRANSFER
      IWC = IW
      IF (IS.EQ.56) IWC = IW - 1
C    NOW READY TO TRANSFER DATA TO OUTPUT BUFFER
C
C    FILL 64-BIT WORD WITH NO-OPS IF NECESSARY
      BUFFPT(I) = SHIFTL(SHIFTR(3+BUFFPT(I),2),2)
      IF(BUFFPT(I)+4.GT.MAXBUF)CALLDFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
      IW = SHIFTR(BUFFPT(I),2)
      DO 10022 IREP=1,IVSC
      DO 10022 J=1,IWC
      RBUFF(IW,I) = LSCAN(J)
      IW = IW + 1
      BUFFPT(I) = BUFFPT(I) + 4
      IF (BUFFPT(I)+4.GT.MAXBUF) THEN
                    CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
                    IW = 0
      ENDIF
10022 CONTINUE
10012 CONTINUE
C
C    SET RASTER FLAG
C
      RAST = .TRUE.
      WSDSE(NWS) = .FALSE.
C
C    NOW CHECK IF CELL ARRAY COMPLETE
C
      IF (NPAR.EQ.0) THEN
C        SET IVSC FOR CONTINUATION ENTRY
            IVSC = -1
            IF (ISCAN.LE.1) THEN
C          TOP TO BOTTOM
                  IF (YRAST0.GE.YRAST3) GO TO 10020
            ELSE
C          BOTTOM TO TOP
                  IF (YRAST0.LE.YRAST3) GO TO 10020
            ENDIF
      ENDIF
      GO TO 9998
  100 IF (IF.GT.200) GO TO 200
C     HERE FOR 101-199
C
      IF (IF.EQ.101) THEN
C
C    101 IS GLOBAL LUT ENTRY (BLOCK)
C
         J1 = MAX(0,NARG(1))
         J2 = MIN(NARG(2),MAXLUT)
         IF (J1.LE.J2) THEN
              DO 10034 I=J1,J2
              IW = I/8
              IBS = 8*(7 - (I - IW*8))
              DO 10035 J=1,3
              Z3(J) = RGBLUT(J,I)
              IZ = INT(Z3(J)*255.+.5)
10035         D48LUT(J,IW) = (D48LUT(J,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              Z = DFX139(Z3(1),Z3(2),Z3(3))
              IZ = INT(Z*255.+.5)
10034         D48LUT(4,IW) = (D48LUT(4,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              DEVCOL(NWS) = .TRUE.
         ENDIF
      ELSE IF (IF.EQ.102) THEN
C
C    102 IS LUT ENTRY (BLOCK) FROM ARGUMENTS
C
         J1 = MAX(0,NARG(1))
         J2 = MIN(NARG(2),MAXLUT)
         IF (J1.LE.J2) THEN
              DO 10036 I=J1,J2
              IW = I/8
              IBS = 8*(7 - (I - IW*8))
              Z3(1) = XARG(I)
              Z3(2) = YARG(I)
              Z3(3) = ZARG(I)
              DO 10037 J=1,3
              IZ = INT(Z3(J)*255.+.5)
10037         D48LUT(J,IW) = (D48LUT(J,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              Z = DFX139(Z3(1),Z3(2),Z3(3))
              IZ = INT(Z*255.+.5)
10036         D48LUT(4,IW) = (D48LUT(4,IW).AND..NOT.SHIFTL(M8,IBS))
     1                         .OR.SHIFTL((IZ.AND.M8),IBS)
              DEVCOL(NWS) = .TRUE.
         ENDIF
      ENDIF
      GO TO 9999
  200 IF (IF.NE.204) GO TO 9999
C     HERE FOR 204
C
  204 XD = X + XDCOR0
      YD = Y + YDCOR0
      IF (N.EQ.0) THEN
                      PPD = VPAPPD(0)
                      GO TO 4
                  ELSE
                      PPD = VPAPPD(2)
                      GO TO 2
      ENDIF
 1000 II = -IF
C       -1000 OR LOWER ARE SPECIAL ACTIONS
      IF (II.GE.1000) GO TO 2000
      GO TO (1001,1002,1003,1004),II
C    CLOSE DEVICE
 1002 IF (WSDSE(NWS).AND.LOPFA) GO TO 10002
      INS = OP0.OR.FILMAD
      IW = SHIFTR(BUFFPT(3),2)
      IB16 = SHIFTL((3-(BUFFPT(3).AND.3)),4)
      RBUFF(IW,3) = RBUFF(IW,3).OR.SHIFTL(INS,IB16)
      BUFFPT(3) = BUFFPT(3) + 1
      IF (BUFFPT(1).NE.0) CALL DFX04B(RBUFF(0,1),BUFFPT(1),DTYPE(1))
      IF (BUFFPT(2).NE.0) CALL DFX04B(RBUFF(0,2),BUFFPT(2),DTYPE(2))
      CALL DFX04B(RBUFF(0,3),BUFFPT(3),DTYPE(3))
      CNTL(3) = FA.OR.FB18
      FRAMES = FRAMES + 1
      CPT = MAXCNT
      CALL DFX04B(CNTL,CPT,CTYPE)
      WSDSE(NWS) = .TRUE.
      LOPFA = .TRUE.
10002 CNTL(3) = EJ.OR.FB116
      IF (FRAMES.EQ.0) THEN
               CALL DFX003('**DIMFILM  -  DEVICE D35C TERMINATED**')
               CALL DFX003('**NO DATA - NO FILM WILL BE GENERATED**')
               GKSERR = 0
               GO TO 9999
      ENDIF
      CPT = MAXCNT
      CALL DFX04B(CNTL,CPT,CTYPE)
C    GET SD PARAMETER FLAG
      CALL DFXMSS(ISD)
      CALL DFX04C(RAST,IFAIL,NOBYTE,ISD)
      CFRAM = 'S'
      IF (FRAMES.EQ.1) CFRAM = ' '
      WRITE(ERRREC,10009) FRAMES,CFRAM
10009 FORMAT('**DIMFILM  -  DEVICE D35C TERMINATED - ',I6,' FRAME',A)
      CALL DFX003(ERRREC(1))
      NB = NOBYTE
      CBYTE = ' BYTES'
      IF (NB.GE.1000000) THEN
                          NB = (NB-1)/1024 + 1
                          CBYTE = 'K BYTES'
      ENDIF
      IF (NB.GE.1000000) THEN
                          NB = (NB-1)/1024 + 1
                          CBYTE = 'M BYTES'
      ENDIF
      IF (NB.EQ.1) CBYTE(7:7) = ' '
      IF (USETPE) THEN
          CUSE = ' SAV'
      ELSE
          CUSE = 'QUEU'
      ENDIF
      WRITE(ERRREC,10010) CUSE,NB,CBYTE
10010 FORMAT('              ',A4,'ED DATASET LENGTH  - ',I6,A)
      CALL DFX003(ERRREC(1))
C    IF NO ERROR SEND SD-RELATED MESSAGES
      IF (IFAIL.EQ.0) THEN
       IF (ISD.EQ.1) THEN
C    SD PARAMETER SPECIFIED
         CALL DFX003('**PLOT DATA SUCCESSFULLY TRANSFERRED')
       ELSE
C    NO SD PARAMETER
         CALL DFX003
     1   ('**UNABLE TO CONFIRM SUCCESSFUL PLOT DATA TRANSFER -')
         CALL DFX003
     1   ('  SD PARAMETER ON JOB STATEMENT STRONGLY RECOMMENDED')
       ENDIF
       IF (USETPE) THEN
         CALL DFX003
     1   ('*****USE TAPE FACILITY WAS USED*****')
         CALL DFX003
     1   ('******DATA WILL NOT BE PLOTTED******')
       ENDIF
      ENDIF
      GKSERR = IFAIL
      GO TO 9999
C    FRAME ADVANCE
 1003 INS = OP0.OR.FILMAD
      IW = SHIFTR(BUFFPT(3),2)
      IB16 = SHIFTL((3-(BUFFPT(3).AND.3)),4)
      RBUFF(IW,3) = RBUFF(IW,3).OR.SHIFTL(INS,IB16)
      BUFFPT(3) = BUFFPT(3) + 1
      IF (BUFFPT(1).NE.0) CALL DFX04B(RBUFF(0,1),BUFFPT(1),DTYPE(1))
      IF (BUFFPT(2).NE.0) CALL DFX04B(RBUFF(0,2),BUFFPT(2),DTYPE(2))
      CALL DFX04B(RBUFF(0,3),BUFFPT(3),DTYPE(3))
      CNTL(3) = FA.OR.FB18
      FRAMES = FRAMES + 1
      CPT = MAXCNT
      CALL DFX04B(CNTL,CPT,CTYPE)
      ASSIGN 9999 TO JUMP
10005 WSDSE(NWS) = .TRUE.
      LOPFA = .TRUE.
C    VECTOR/RASTER MODE UNSET AT BEGINNING OF EACH FRAME
10025 MODE = UNSET
      DO 10006 I=1,3
C    SELECT FILTER AT BEGINNING OF FRAME FOR EACH STREAM
      INS = OP6.OR.FILTER(I)
      IW = SHIFTR(BUFFPT(I),2)
      IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
      RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
      BUFFPT(I) = BUFFPT(I) + 1
C    AT FRAME ADVANCE/RESET MUST SEND ICS STATUS
CPURE+IF PURE DDC AVOID ICS CALL
CPURE.      IF (PUREDC) GO TO 8000
CPURE-
                   INS = OP0.OR.ECS6
                   IW = SHIFTR(BUFFPT(I),2)
                   IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
                   RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
                   INS = MORICS.OR.ICSMSK
C              (MASK AGAINST ORIGINAL ICS - N.B. MORICS ACTUALLY ZERO)
                   IW = SHIFTR(BUFFPT(I)+1,2)
                   IB16 = SHIFTL((3-((BUFFPT(I)+1).AND.3)),4)
                   RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
                   BUFFPT(I) = BUFFPT(I) + 2
                   IF (ICSMSK.NE.0) THEN
C               HERE IF NOT RESETTING TO ORIGINAL
C
C               NOTE - ADDITIONAL OUTPUT WORD HERE
                          INS = ICSVAL
                          IW = SHIFTR(BUFFPT(I),2)
                          IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
                          RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
                          BUFFPT(I) = BUFFPT(I) + 1
                   ENDIF
CPURE+
C8000 CONTINUE
CPURE-
C    SET HERE TO FORCE LINE MULTI-WIDTH AND SPOT SIZE SELECTION VIA DDC
      MWLAST(I) = -1
      SSLAST(I) = -1
      RGB0(I) = .TRUE.
10006 CONTINUE
      DEVCOL(NWS) = .TRUE.
C    SHOULD ALSO SET BEAM POSITION, SPOT SIZE, LINE THICKNESS
C    BEAM POSITION IS SET BY DIMFILM AT FRAME ADVANCE
C    COLOUR IS FORCED AT F/A IN DFX000 VIA DEVCOL, MWLAST AND SSLAST
      GO TO JUMP,(1004,9999,10030)
C    RESET DEVICE TRANSFORMATION
 1004 DSCALE = AMAX1((CWSVP(2,NWS)-CWSVP(1,NWS))
     1                       /(CWSWIN(2,NWS)-CWSWIN(1,NWS)),
     2    (CWSVP(4,NWS)-CWSVP(3,NWS))/(CWSWIN(4,NWS)-CWSWIN(3,NWS)))
      XDCO = CWSVP(1,NWS) - CWSWIN(1,NWS)*DSCALE + XDCOR0
      YDCO = CWSVP(3,NWS) - CWSWIN(3,NWS)*DSCALE + YDCOR0
C    THESE TRANSFORM VALUES YIELD D48 VALUES
      GO TO 9999
C    DEVICE SPECIFIC CODES COMMENCE AT -2001
 2000 II = II - 2000
      GO TO (2001,2002,2003,2004,2005,2006,2007),II
C
C    OPCODE -2001      FORCE FULL RESET ACTION
C
C     SET RETURN PATH - NO TRANSFORMATION RESET
 2001 ASSIGN 9999 TO JUMP
10028 IF (BUFFPT(1).NE.0) CALL DFX04B(RBUFF(0,1),BUFFPT(1),DTYPE(1))
      IF (BUFFPT(2).NE.0) CALL DFX04B(RBUFF(0,2),BUFFPT(2),DTYPE(2))
      IF (BUFFPT(3).NE.0) CALL DFX04B(RBUFF(0,3),BUFFPT(3),DTYPE(3))
      CNTL(3) = RS.OR.FB14
      CPT = MAXCNT
      CALL DFX04B(CNTL,CPT,CTYPE)
C    GO DO BUFFER INITIALISATIONS AND RETURN
C    (NOTE ENTRY 2001 RESULTS IN DIRECT RETURN, ALTERNATE PATHS
C     EXIST FOR ENTRIES VIA 10028 E.G. FROM DEVICE ROTATION,
C     PIXEL SIZE SPECIFICATION OP)
      GO TO 10025
C
C    OPCODE -2002      FORCE PARTIAL RESET ACTION
C
 2002 MODE = UNSET
      DO 10027 I=1,3
      MWLAST(I) = -1
      SSLAST(I) = -1
10027 RGB0(I) = .TRUE.
      PIXSIZ = .TRUE.
C
C    OPCODE -2003      SELECT DEVICE ROTATION
C
 2003 IF (DROT.EQ.N) GO TO 9999
C    ONLY ACCEPT VALID CALL AFTER OPEN OF THIS WS
      IF ((N.NE.0).AND.(N.NE.1)) GO TO 9999
C    RESET ALL CWSWIN/VP THEN SET FOR SPECIFIC ROTATION
      CWSWIN(1,NWS) = 0.0
      CWSWIN(2,NWS) = 1.0
      CWSWIN(3,NWS) = 0.0
      CWSWIN(4,NWS) = 1.0
      CWSVP(1,NWS) = 0.0
      CWSVP(3,NWS) = 0.0
C    FOLLOWING CODE DEPENDENT ON DEFAULT FOR THIS DEVICE
      DROT = N
      HVIV = HVI(2,DROT)
      IF (DROT.EQ.DEFROT) THEN
                 WSMDCS(1,NWS) = XDCMAX
                 WSMDCS(2,NWS) = YDCMAX
                 XDCOR0 = XDCORG
                 YDCOR0 = YDCORG
      ELSE
                 WSMDCS(1,NWS) = YDCMAX
                 WSMDCS(2,NWS) = XDCMAX
                 XDCOR0 = YDCORG
                 YDCOR0 = 32767 - (XDCORG + XDCMAX)
      ENDIF
      CWSVP(2,NWS) = WSMDCS(1,NWS)
      CWSVP(4,NWS) = WSMDCS(2,NWS)
C    ENSURE RESET OF DEVICE TRANSFORMATION AFTER RESET ACTION
      ASSIGN 1004 TO JUMP
      GO TO 10028
C
C    OPCODE -2004      DIRECT DEVICE CODE TRANSFER
C
C    FORCE NPAR WORDS FROM NARG TO DEVICE ACCORDING TO IPAR(1)
C                       IPAR(1) = 0     ALL STREAMS
C                                 1,2,3 TO R,G,B RESPECTIVELY
 2004 N = IPAR(1)
      IF (N.LT.0.OR.N.GT.3) GO TO 9999
      IF (N.EQ.0) THEN
                 I1 = 1
                 I2 = 3
      ELSE
                 I1 = N
                 I2 = N
      ENDIF
      DO 10026 I=I1,I2
      DO 10026 J=1,NPAR
      INS = NARG(J)
      IW = SHIFTR(BUFFPT(I),2)
      IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
      RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
      BUFFPT(I) = BUFFPT(I) + 1
      IF (BUFFPT(I).EQ.MAXBUF)CALLDFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
10026 CONTINUE
      GO TO 9999
C
C    OPCODE -2005      PIXEL SIZE/SPACING SPECIFICATION
C
 2005 IHPE = IPAR(1)
      IVPE = IPAR(2)
      IHES = IPAR(3)
      IHPS = IPAR(4)
      IVES = IPAR(5)
      IVPS = IPAR(6)
C    UNITS FOR HORIZONTAL/VERTICAL ELEMENT SPACING IN TERMS OF 4K
C    RASTER DEVICE (I.E. VECTOR:RASTER RATIO 8:1)
C    IHES,IVES HAVE 3 BINARY FRACTIONAL PLACES
C        - SO H/VESCDC ARE IDENTICAL TO IH/VES
      HESDC = IHES
      VESDC = IVES
      PIXSIZ = .TRUE.
      GO TO 9999
C
C    OPCODE -2006      INITIATE PRIME MODE THEN ADVANCE FRAME
C
 2006 INS = 4
      IW = SHIFTR(BUFFPT(3),2)
      IB16 = SHIFTL((3-(BUFFPT(3).AND.3)),4)
      RBUFF(IW,3) = RBUFF(IW,3).OR.SHIFTL(INS,IB16)
      BUFFPT(3) = BUFFPT(3) + 1
      IF (BUFFPT(3).EQ.MAXBUF)CALL DFX04B(RBUFF(0,3),BUFFPT(3),DTYPE(3))
      PIXSIZ = .TRUE.
      GO TO 1003
C
C    OPCODE -2007      SET/CLEAR SPECIFIED ICS FIELDS
C
C                 NARG(1) IS BIT MASK (RIGHT ADJUSTED) FOR
C                         16-BIT ICS - SET BITS WILL BE SET
C                         WITH VALUE OF CORRESPONDING BIT
C                         IN NARG(2)
C                 NARG(2) IS ICS-VALUES FOR BITS FLAGGED IN
C                         MASK WORD NARG(1)
C
C
 2007 ICSMSK = ICSMSK.OR.NARG(1)
      ICSVAL = (ICSVAL.AND..NOT.NARG(1)).OR.(NARG(1).AND.NARG(2))
      ICSSET = .TRUE.
      ASSIGN 9999 TO JUMP
      GO TO 10025
      END
C
      ENTRY D48 SSZ(ARG1)
C
C     ====================================================
C     =                                                  =
C     =     SPOT SIZE: D48SSZ                            =
C     =                                                  =
C     =           - SET SPOT SIZE TO ARG1                =
C     =                                                  =
C     ====================================================
C
C
      SS = ARG1
      IF (SS.NE.SSLAST) THEN
            DO 201 I=1,CHANLS
            INS = OPSS.OR.SS
            IW = SHIFTR(BUFFPT(I),2)
            IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
            RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
            BUFFPT(I) = BUFFPT(I) + 1
            IF (BUFFPT(I).EQ.MAXBUF)
     1      CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
  201       CONTINUE
            SSLAST = SS
            DOSPOT = .TRUE.
      ENDIF
      GO TO 9999
C
      ENTRY D48LWD(ARG1)
C
C     ====================================================
C     =                                                  =
C     =     LINE WIDTH: D48LWD                           =
C     =                                                  =
C     =           - SET LINE WIDTH TO ARG1               =
C     =                                                  =
C     ====================================================
C
C
      MW = ARG1
      IF (MW.NE.MWLAST) THEN
            DO 202 I=1,CHANLS
            INS = OPMW.OR.MW
            IW = SHIFTR(BUFFPT(I),2)
            IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
            RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
            BUFFPT(I) = BUFFPT(I) + 1
            IF (BUFFPT(I).EQ.MAXBUF)
     1      CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
  202       CONTINUE
            MWLAST(I) = MW
            DOLWID = .TRUE.
      ENDIF
      GO TO 9999
C
      ENTRY D48VEC
C
C     ====================================================
C     =                                                  =
C     =     VECTOR MODE: D48VEC                          =
C     =                                                  =
C     =           - SET VECTOR MODE                      =
C     =                                                  =
C     ====================================================
C
C
      IF (MODE.NE.VECTOR) THEN
            MODE = VECTOR
            DO 203 I=1,CHANLS
C    SELECT VECTOR MODE
            INS = OP0.OR.MODE
            IW = SHIFTR(BUFFPT(I),2)
            IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
            RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
            BUFFPT(I) = BUFFPT(I) + 1
            IF (BUFFPT(I).EQ.MAXBUF)
     1      CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
  203       CONTINUE
            DOMODE = .TRUE.
      ENDIF
      GO TO 9999
C
      ENTRY D48RAS
C
C     ====================================================
C     =                                                  =
C     =     RASTER MODE: D48VEC                          =
C     =                                                  =
C     =           - SET RASTER MODE                      =
C     =                                                  =
C     ====================================================
C
C
      IF (MODE.NE.RASTER) THEN
            MODE = RASTER
            DO 204 I=1,CHANLS
C    SELECT RASTER MODE
            INS = OP0.OR.MODE
            IW = SHIFTR(BUFFPT(I),2)
            IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
            RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
            BUFFPT(I) = BUFFPT(I) + 1
            IF (BUFFPT(I).EQ.MAXBUF)
     1      CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
  204       CONTINUE
            DOMODE = .TRUE.
      ENDIF
      GO TO 9999
C
      ENTRY D48HVI(ARG1)
C
C     ====================================================
C     =                                                  =
C     =     SET HVI: D48HVI                              =
C     =                                                  =
C     =           - SET HVI = ARG1                       =
C     =                     (AND COMPUTE ISCAN/DROT)     =
C     =                                                  =
C     =     ***USE OF ENTRY INHIBITS PURE DDC***         =
C     =                                                  =
C     ====================================================
C
C
      IF (CURHVI.NE.ARG1) THEN
            CURHVI = ARG1
            DOICS = .TRUE.
            PUREDC = .FALSE.
            ICSSET = .TRUE.
            ICSMSK = ICSMSK.OR.MHVI
            ICSVAL = (ICSVAL.AND..NOT.MHVI).OR.SHIFTL(CURHVI,5)
            DO 205 I=1,CHANLS
            IF (BUFFPT(I)+3.GE.MAXBUF)
     1      CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
            INS = OP0.OR.ECS6
            IW = SHIFTR(BUFFPT(I),2)
            IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
            RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
            INS = MCUICS.OR.MHVI
            IW = SHIFTR(BUFFPT(I)+1,2)
            IB16 = SHIFTL((3-((BUFFPT(I)+1).AND.3)),4)
            RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
            INS = SHIFTL(CURHVI,5)
            IW = SHIFTR(BUFFPT(I)+2,2)
            IB16 = SHIFTL((3-((BUFFPT(I)+2).AND.3)),4)
            RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
            BUFFPT(I) = BUFFPT(I) + 3
  205       CONTINUE
      ENDIF
      GO TO 9999
C
      ENTRY D48LUT(ARG1)
C
C     ====================================================
C     =                                                  =
C     =     SET COLOUR VALUE (VIA LUT): D48LUT           =
C     =                                                  =
C     =           - SET LUT VALUE TO ARG1                =
C     =                                                  =
C     ====================================================
C
C
      INS = OP6.OR.ARG1
      DO 206 I=1,CHANLS
      IW = SHIFTR(BUFFPT(I),2)
      IB16 = SHIFTL((3-(BUFFPT(I).AND.3)),4)
      RBUFF(IW,I) = RBUFF(IW,I).OR.SHIFTL(INS,IB16)
      BUFFPT(I) = BUFFPT(I) + 1
      IF(BUFFPT(I).EQ.MAXBUF)CALL DFX04B(RBUFF(0,I),BUFFPT(I),DTYPE(I))
  206 CONTINUE
      GO TO 9999
