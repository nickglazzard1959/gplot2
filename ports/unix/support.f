C
C     SUPPORT FUNCTIONS NEEDED TO BUILD DIMFILM AND GPLOT ON
C     UNIX-LIKE SYSTEMS WITH GFORTRAN
C
      
      REAL FUNCTION RANF()
C----
C     RANDOM FLOAT IN RANGE 0 to 1
C----
      REAL R4_UNI
      LOGICAL FIRST
      INTEGER SEED, S2
      SAVE
      COMMON /RANFSD/ SEED, S2
      DATA FIRST/.TRUE./
C
      IF( FIRST )THEN
         SEED = 1384793
         S2   = 17
      ENDIF
      RANF = R4_UNI(SEED, S2)
      FIRST = .FALSE.
      RETURN
      END

      SUBROUTINE RANSET( N )
C----
C     SEED THE RANDOM NUMBER GENERATOR.
C     ONLY SEED (ABOVE) IS SET HERE, NOT S2, SO NOT SURE HOW
C     THAT WILL AFFECT RANDOMNESS IN DETAIL.
C----
      INTEGER N
C
      REAL JUNK
      INTEGER SEED, S2
      SAVE
      COMMON /RANFSD/ SEED, S2
C
      JUNK = RANF()
      SEED = N
      S2 = 17
      JUNK = RANF()
      RETURN
      END

      FUNCTION R4_UNI ( S1, S2 )
C*********************************************************************72
C
CC R4_UNI RETURNS A PSEUDORANDOM NUMBER BETWEEN 0 AND 1.
C
C  DISCUSSION:
C
C    THIS FUNCTION GENERATES UNIFORMLY DISTRIBUTED PSEUDORANDOM NUMBERS
C    BETWEEN 0 AND 1, USING THE 32-BIT GENERATOR FROM FIGURE 3 OF
C    THE ARTICLE BY L'ECUYER.
C
C    THE CYCLE LENGTH IS CLAIMED TO BE 2.30584E+18.
C
C  MODIFIED:
C
C    08 JULY 2008
C
C  AUTHOR:
C
C    PASCAL ORIGINAL VERSION BY PIERRE L'ECUYER
C    MODIFICATIONS BY JOHN BURKARDT
C
C  REFERENCE:
C
C    PIERRE LECUYER,
C    EFFICIENT AND PORTABLE COMBINED RANDOM NUMBER GENERATORS,
C    COMMUNICATIONS OF THE ACM,
C    VOLUME 31, NUMBER 6, JUNE 1988, PAGES 742-751.
C
C  PARAMETERS:
C
C    INPUT/OUTPUT, INTEGER S1, S2, TWO VALUES USED AS THE
C    SEED FOR THE SEQUENCE.  ON FIRST CALL, THE USER SHOULD INITIALIZE
C    S1 TO A VALUE BETWEEN 1 AND 2147483562;  S2 SHOULD BE INITIALIZED
C    TO A VALUE BETWEEN 1 AND 2147483398.
C
C    OUTPUT, REAL R4_UNI, THE NEXT VALUE IN THE SEQUENCE.
C
      IMPLICIT NONE

      INTEGER K
      REAL R4_UNI
      INTEGER S1
      INTEGER S2
      INTEGER Z
    
      K = S1 / 53668
      S1 = 40014 * ( S1 - K * 53668 ) - K * 12211
      IF ( S1 .LT. 0 ) THEN
        S1 = S1 + 2147483563
      END IF

      K = S2 / 52774
      S2 = 40692 * ( S2 - K * 52774 ) - K * 3791
      IF ( S2 .LT. 0 ) THEN
        S2 = S2 + 2147483399
      END IF

      Z = S1 - S2
      IF ( Z .LT. 1 ) THEN
        Z = Z + 2147483562
      END IF

      R4_UNI = REAL ( Z ) / 2147483563.0E+00

      RETURN
      END

      LOGICAL FUNCTION IBTEST(IV, IB)
C----
C     TEST BIT IB IN INTEGER IV
C----      
      INTEGER IV, IB
      IBTEST = BTEST(IV, IB)
      RETURN
      END

      SUBROUTINE CONNEC( I )
C----
C     STUB FOR NOS CONNEC SUBROUTINE (DO NOTHING)
C----
      RETURN
      END
      
      SUBROUTINE DISCON( I )
C----
C     STUB FOR NOS DISCON SUBROUTINE (DO NOTHING)
C----
      RETURN
      END

      REAL FUNCTION EOF( I )
C----
C     RETURN 0 IF NOT AT EOF, ELSE NON-ZERO. WE ARE NEVER AT EOF!
C----
      EOF = 0.0
      RETURN
      END

      SUBROUTINE PMDSTOP
C----
C     NOS POST MORTEM DUMP STOP. DO NOTHING.
C----
      RETURN
      END

      INTEGER FUNCTION IGETOT()
C----
C     RETURN NOS ORIGIN TYPE. ALWAYS INTERACTIVE (3) ON UNIX.
C----
      IGETOT = 3
      RETURN
      END

      SUBROUTINE GETPARM( KEY, VALUE, ISTAT )
C----
C     EMULATE NOS GETPARM FUNCTION. THE EXPECTED COMMAND LINE
C     IS OF THE FORM KEY=VALUE OR KEY. THAT IS, THE ARGUMENTS
C     SHOULD BE SIMILAR TO NOS FORMAT BUT SEPARATED BY SPACES
C     RATHER THAN COMMAS.
C----
      CHARACTER*(*) KEY, VALUE
      INTEGER ISTAT
C
      CHARACTER*80 INPARM
      INTEGER IKEY, IVALUE, LKEY, LVALUE
      INTEGER ICARG
      SAVE ICARG
      DATA ICARG/1/
C
      KEY = ' '
      VALUE = ' '
      ISTAT = 1
      IKEY = 1
      IVALUE = 1
      LKEY = LEN(KEY)
      LVALUE = LEN(VALUE)
      IF( ICARG .GT. IARGC())THEN
         ISTAT = -1
         RETURN
      ENDIF
      CALL GETARG(ICARG, INPARM)
      ICARG = ICARG + 1
      DO 1 I=1,80
         IF( INPARM(I:I) .EQ. ' ' )GOTO 2
         IF( INPARM(I:I) .EQ. '=' )THEN
            ISTAT = 0
         ELSE
            IF( ISTAT .EQ. 1 )THEN
               IF( IKEY .LE. LKEY )THEN
                  KEY(IKEY:IKEY) = INPARM(I:I)
                  IKEY = IKEY + 1
               ENDIF
            ELSE
               IF( IVALUE .LE. LVALUE )THEN
                  VALUE(IVALUE:IVALUE) = INPARM(I:I)
                  IVALUE = IVALUE + 1
               ENDIF
            ENDIF
         ENDIF
 1    CONTINUE
 2    CONTINUE
      RETURN
      END
      
      SUBROUTINE CNSTDIN( IUNIT )
C----
C     CONNECT IUNIT TO STDIN.
C     YOU CAN USE THE ENV VAR GFORTRAN_STDIN_UNIT TO
C     SET THE UNIT NUMBER BEFORE RUNNING A GFORTRAN
C     PROGRAM, BUT MAYBE THIS ROUTINE IS EASIER.
C----
      INTEGER IUNIT
C
      OPEN(UNIT=IUNIT, FILE='/dev/stdin', STATUS='OLD')
      RETURN
      END
      
