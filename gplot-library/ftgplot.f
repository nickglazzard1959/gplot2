      PROGRAM GPLOT(INPUT=/80,OUTPUT=/132,TAPE7=INPUT,TAPE6=OUTPUT)
C ===================================================
C  GPLOT - DIMFILM BASED INTERACTIVE PLOTTING PROGRAM
C  --------------------------------------------------
C
C  THIS PROGRAM CAN BE BUILT AND MAINTAINED ON BOTH
C  CDC NOS 2.8.7 USING MODIFY AND OTHER CDC TOOLS AND
C  ON "UNIX-LIKE" SYSTEMS USING GIT AND GFORTRAN.
C
C  THE PROGRAMS AND SCRIPTS IN THE GPLOT PROJECT
C  TOOLS DIRECTORY ARE USED TO ACCOMPLISH THIS.
C
C  FOR INSTALLATION AND SOME USAGE INFORMATION, SEE
C  THE PROJECT'S README.MD. FOR MORE DETAILED
C  USAGE INFORMATION, SEE THE GPLOT MANUAL.
C
C ***************************************************
C * GPLOT RELIES ENTIRELY ON THE DIMFILM GRAPHICS   *
C * LIBRARY, WRITTEN BY JOHN C. GILBERT AT U.L.C.C. *
C * AND USED THERE BETWEEN 1973 AND AROUND 1996.    *
C * ONE GOAL OF GPLOT IS TO PRESERVE DIMFILM.       *
C ***************************************************
C
C  GPLOT IS OPEN SOURCE SOFTWARE AND USES THE MIT
C  LICENSE, A COPY OF WHICH IS INCLUDED IN THE GIT
C  REPOSITORY FOR THE PROJECT.
C
C  --------------------------------------------------
C  GPLOT (C) 2013-2025 NICK GLAZZARD NICK@HCCC.ORG.UK
C ===================================================
      IMPLICIT LOGICAL (A-Z)
C
C DIMENSIONS AND LIMITS.
C
C MAXARG - MAXIMUM NUMBER OF ARGUMENTS TO ANY COMMAND.
C MAXDEP - MAXIMUM OBEY FILE NESTING LEVELS.
C MAXSTK - MAXIMUM EVALUATOR STACK LEVELS (NSTACK).
C MAXKEY - MAXIMUM NUMBER OF ENTRIES IN A GRAPH KEY.
C MAXPTS - MAXIMUM DATA POINTS THAT CAN BE GRAPHED.
C MAXFNL - MAXIMUM FILE NAME LENGTH (OS DEPENDENT)
C
C NCMDS  - NUMBER OF DEFINED COMMANDS.
C NFONTS - NUMBER OF AVAILABLE FONTS.
C NREGS  - NUMBER OF EVALUATOR REGISTERS.
C      
      INTEGER MAXARG, MAXDEP, MAXSTK, MAXKEY, MAXPTS, MAXFNL
      INTEGER NCMDS, NFONTS, NREGS
      PARAMETER( MAXARG=9, MAXDEP=5, MAXSTK=9, MAXKEY=20 )
      PARAMETER( MAXPTS=10000 )
#ifdef UNIX
      PARAMETER( MAXFNL=72 )
#else
      PARAMETER( MAXFNL=7 )
#endif
      PARAMETER( NCMDS=95, NFONTS=24, NREGS=9 )
C
C INITIAL DEFAULT NUMBER OF POINTS THAT CAN BE GRAPHED.
C USED ONLY ON SYSTEMS THAT SUPPORT DYNAMIC MEMORY ALLOCATION.
C
      INTEGER  NDEFPTS
      PARAMETER( NDEFPTS=1000 )
C
C COMMAND CODES.
C
      INTEGER KDEV, KMAXPT, KCOL, KWID, KMARK
      INTEGER KCLR, KMOVE, KDRAW, KTEXT, KREAD
      INTEGER KXYPT, KXYLN, KXYAUT, KXRAN, KYRAN
      INTEGER KXYSAM, KXLIN, KYLIN, KXLOG, KYLOG
      INTEGER KXYGRD, KOBEY, KEXIT, KHELP, KBOUND
      INTEGER KTIT, KXLAB, KYLAB, KTEST, KSTYLE
      INTEGER KGET, KSTAT, KANNOT, KFLOG, KINTERP
      INTEGER KEBASM, KHIST, KHISTMD, KPANE, KUNP
      INTEGER KPANEO, KBLNK, KUNBL, KBLNKO, KFILL
      INTEGER KPATHP, KEVAL, KERNG, KPATH, KGRMOVE
      INTEGER KGRDRAW, KNSTACK, KIEVAL, KPROC, KSTO
      INTEGER KRCL, KCANVAS, KCTEXT, KFONT, KLFONT
      INTEGER KSYMHT, KSYMANG, KSTRING, KZERO, KGSTY
      INTEGER KRYLAB, KGRIGHT, KGAXCUT, KCIRC, KARC
      INTEGER KRECT, KCRECT, KBSTAR, KBEND, KBSET
      INTEGER KLSYS, KLDPROC, KTXBOX, KSETCSG
      INTEGER KUSEKEY, KADDKEY, KKEYS, KRESET, KTXBPS
      INTEGER KTXBPH, KTXBPT, KTXBPB, KLINE, KGLABEL, KALABEL
      INTEGER KARPARM, KANPARM, KWAIT, KAXINT, KVRI
      PARAMETER( KDEV=1, KMAXPT=2, KCOL=3, KWID=4, KMARK=5 )
      PARAMETER( KCLR=6, KMOVE=7, KDRAW=8, KTEXT=9, KREAD=10 )
      PARAMETER( KXYPT=11, KXYLN=12, KXYAUT=13, KXRAN=14, KYRAN=15 )
      PARAMETER( KXYSAM=16, KXLIN=17, KYLIN=18, KXLOG=19, KYLOG=20 )
      PARAMETER( KXYGRD=21, KOBEY=22, KEXIT=23, KHELP=24, KBOUND=25 )
      PARAMETER( KTIT=26, KXLAB=27, KYLAB=28, KTEST=29, KSTYLE=30 )
      PARAMETER( KGET=31, KSTAT=32, KANNOT=33, KFLOG=34, KINTERP=35 )
      PARAMETER( KEBASM=36, KHIST=37, KHISTMD=38, KPANE=39, KUNP=40 )
      PARAMETER( KPANEO=41, KBLNK=42, KUNBL=43, KBLNKO=44, KFILL=45 )
      PARAMETER( KPATHP=46, KEVAL=47, KERNG=48, KPATH=49, KGRMOVE=50 )
      PARAMETER( KGRDRAW=51, KNSTACK=52, KIEVAL=53, KPROC=54, KSTO=55 )
      PARAMETER( KRCL=56, KCANVAS=57, KCTEXT=58, KFONT=59, KLFONT=60 )
      PARAMETER( KSYMHT=61, KSYMANG=62, KSTRING=63, KZERO=64, KGSTY=65 )
      PARAMETER( KRYLAB=66, KGRIGHT=67, KGAXCUT=68, KCIRC=69, KARC=70 )
      PARAMETER( KRECT=71, KCRECT=72, KBSTAR=73, KBEND=74, KBSET=75 )
      PARAMETER( KLSYS=76, KLDPROC=77, KTXBOX=78, KSETCSG=79 )
      PARAMETER( KUSEKEY=80, KADDKEY=81, KKEYS=82, KRESET=83 )
      PARAMETER( KTXBPS=84, KTXBPH=85, KTXBPT=86, KTXBPB=87, KLINE=88 )
      PARAMETER( KGLABEL=89, KALABEL=90, KARPARM=91, KANPARM=92 )
      PARAMETER( KWAIT=93, KAXINT=94, KVRI=95 )
C
C DEVICE CODES.
C
      INTEGER NDEVS
      PARAMETER( NDEVS=5 )
      INTEGER KDGT, KDTK, KDEC, KDEB, KSVG
      PARAMETER( KDGT=1, KDTK=2, KDEC=3, KDEB=4, KSVG=5 )
C
C GRID MODE CODES. ALSO INTEGER/REAL AXIS VALUE SELECTION.
C
      INTEGER NGRD
      PARAMETER( NGRD=4 )
      INTEGER KGNO, KGX, KGY, KGXY
      PARAMETER( KGNO=1, KGX=2, KGY=3, KGXY=4 )
C
C LINE STYLE CODES.
C
      INTEGER NSTY
      PARAMETER( NSTY=4 )
      INTEGER KSOLID, KDASH, KDOT, KDSHDOT
      PARAMETER( KSOLID=1, KDASH=2, KDOT=3, KDSHDOT=4 )
C
C INTERPOLATION MODES.
C
      INTEGER NPOL
      PARAMETER( NPOL=3 )
      INTEGER KILIN, KICUB, KIQUIN
      PARAMETER( KILIN=1, KICUB=2, KIQUIN=3 )
C
C HISTOGRAM MODES.
C
      INTEGER NHIST
      PARAMETER( NHIST=5 )
      INTEGER KHABUT, KHABUTS, KHLINE, KHWID, KHWIDS
      PARAMETER( KHABUT=1, KHABUTS=2, KHLINE=3, KHWID=4, KHWIDS=5)
C
C GRAPH STYLES.
C
      INTEGER NGSTY
      PARAMETER( NGSTY=3 )
      INTEGER KGNORM, KGOPEN, KGAXES
      PARAMETER( KGNORM=1, KGAXES=2, KGOPEN=3 )
C
C COLOUR/STYLE SETS
C
      INTEGER NGCS
      PARAMETER( NGCS=4 )
      INTEGER KCSALL, KCSGEN, KCSTEXT, KCSANOT
      PARAMETER( KCSALL=1, KCSGEN=2, KCSTEXT=3, KCSANOT=4)
C
C TEXT BOX HATCHING.
C
      INTEGER NHBH
      PARAMETER( NHBH=4 )
      INTEGER KHBNONE, KHBVRT, KHBHRZ, KHBALL
      PARAMETER( KHBNONE=1, KHBVRT=2, KHBHRZ=3, KHBALL=4 )
C
C TEXT BOX TEXT HANDLING.
C
      INTEGER NHBT
      PARAMETER( NHBT=2 )
      INTEGER KHBFIX, KHBSCL
      PARAMETER( KHBFIX=1, KHBSCL=2 )
C
C TEXT BOX BOX HANDLING
C
      INTEGER NHBB
      PARAMETER( NHBB=4 )
      INTEGER KHBBNO, KHBBOU, KHBBIN, KHBBBT
      PARAMETER( KHBBNO=1, KHBBOU=2, KHBBIN=3, KHBBBT=4 )
C
C ARROW TYPES
C
      INTEGER NART
      PARAMETER( NART=3 )
      INTEGER KARTOP, KARTCL, KARTBA
      PARAMETER( KARTOP=1, KARTCL=2, KARTBA=3 )
C
C VARIABLES.
C
      CHARACTER*15 CMDS(NCMDS)
      CHARACTER*125 DCMDS(NCMDS)
      CHARACTER*6 DEVNAM(NDEVS)
      CHARACTER*72 DDEVS(NDEVS)
      CHARACTER*5 GRDNAM(NGRD)
      CHARACTER*80 ARGS(MAXARG), KEY, VALUE
      CHARACTER*80 OBPSTK(MAXDEP)
      CHARACTER*7 STYNAM(NSTY)
      CHARACTER*7 POLNAM(NPOL)
      CHARACTER*7 GSTYNAM(NGSTY)
      CHARACTER*20 HISTNAM(NHIST)
      CHARACTER*7 GCSNAM(NGCS)
      CHARACTER*5 HBHNAM(NHBH)
      CHARACTER*5 HBTNAM(NHBT)
      CHARACTER*5 HBBNAM(NHBB)
      CHARACTER*6 ARTNAM(NART)
      INTEGER NARGS(NCMDS), INCMDS(NCMDS)
      INTEGER INUNIT, IDEV, MARKNUM, INTERPM
      CHARACTER*80 INLINE, CMD, ARGSTR, CCLINE
      CHARACTER*80 TITLE, XLABEL, YLABEL, RYLABEL
      LOGICAL HAVARG, HAVDATA, HAVDEV, HAVYE, AUTOGET, SLIDE
      LOGICAL HAVTIT, HAVXLAB, HAVYLAB, HAVXE, LBLNK, HAVRLAB
      LOGICAL DOXYAUT, DOXRAN, DOYRAN, HAVAX, KEEPAX, LPANE, DORIGHT
      LOGICAL DOXLOG, DOYLOG, DEBUGON, HAVCCL, QUIET, LASYME, TXTCON
      LOGICAL HAVFLOG, DOANNOT, GCHANGE, DOGRON, DOBB
      REAL RED, GRN, BLU, WID, XLO, YLO, XHI, YHI, XPOS, YPOS
      REAL PXL, PXH, PYL, PYH, BXL, BXH, BYL, BYH, GXPOS, GYPOS
      REAL RBASE, RSTART, RSTOP
      REAL F1, F2, F3, F4, F5, WHIST, FBW, SHDSPC, WHISTIN, TWD, TWIDTH
      INTEGER NEVAL, NSTACK, ITER, IREG, INT1, I, IDOGRID, NINTERP
      INTEGER IHIST, IENUNIT, ISTAT, IDEP, JCMT, IEND, ISTART, IECMD
      INTEGER ISARG, ICMD, ICARGS, IEARG, IE, IWANT, IPFERR, NDATA
      INTEGER IGRID, ISTY, IFNE, INTM, IHMD, ITERST, ITEREN, NWORDS
      INTEGER IAP, LEXPROC, ITERIN, IARG, NAVAIL, IGSTY, INT2, NEWPOS
      CHARACTER*80 PROC(NREGS), STRINGS(NREGS)
      CHARACTER PROCEXP*(NREGS*80)
      INTEGER PROCLEN(NREGS), STRILEN(NREGS)
      REAL MEMS(NREGS)
      CHARACTER*1 CFONMK
      CHARACTER*30 FONTNAM(NFONTS), CLKUPE
      INTEGER FONTNUM(NFONTS), IDXABT1, IDXABT2, IDXABT3, IDXSYMB
      INTEGER IDXMARK, IFONT, ICSGRP, ILKUPE
      REAL FSYMHT, FSYMANG, ZEROVAL, AXCX0, AXCY0, BB(4)
      LOGICAL BBEMPTY, SEVERR, DORESET, LOWEROK
      CHARACTER*10 KEYTEXT(MAXKEY)
      REAL KEYRED(MAXKEY), KEYGRN(MAXKEY), KEYBLU(MAXKEY)
      REAL KEYWID(MAXKEY)
      INTEGER KEYSTY(MAXKEY), NKEYS
      REAL REDGEN, GRNGEN, BLUGEN
      REAL WTXBOX, HTXBOX, WFTXBOX, DHTXBOX, FSYMHTL
      REAL ARSIZE, ARSHARP, ARBARB, ANSKPSL, ANSCALE
      INTEGER IATXBOX, IHTXBOX, ITTXBOX, IBTXBOX, IARTYPE, IAXINT
      CHARACTER*(MAXFNL) PATHNAM, FULLNAM
      CHARACTER*4 VSTR
      LOGICAL SETREGS
C
C VARIABLES FOR DYNAMIC MEMORY POINT STORAGE.
C PORTABLE FORTRAN-77 DOES NOT SUPPORT DYNAMIC ALLOCATION,
C SO JUST DECLARE A STATIC ARRAY BIG ENOUGH FOR THE MAXIMUM POINTS
C AND EVALUATOR STACK LEVELS.
C INTERESTINGLY, GFORTRAN ON INTEL COMPLAINS ABOUT THIS BEING TOO
C LARGE FOR THE STACK AND MAKES IT STATIC (WHICH IS FINE), BUT THIS
C DOES NOT HAPPEN ON ARM64.
C
#ifdef PORTF77
      REAL DA(MAXSTK*MAXPTS)
#else
      REAL DA(1)
#endif      
      INTEGER NPOINTS, IFWA, IOFF, IXOFF, IYOFF, IAOFF, IBOFF
C
C FUNCTIONS.
C
      INTEGER LOOKUP, NNBC, NBC, LNBC, EVAL, EXPROC, IGETOT, NOCC
      INTEGER LSYSTEM, LOCC
      LOGICAL IFROMC, RFROMC, GETYN
      REAL EOF, STRING
#ifdef PORTF77
      INTEGER LOCF
#endif
C
C IF WE ARE NOT ON NOS, UPCASE BEFORE COMPARE IN LOOKUP().
C THIS LETS US KEEP COMMANDS CASE INSENSITIVE WHILE PRESERVING
C LOWER CASE TEXT STRINGS AND FILE NAMES.
C
#ifdef PORTF77
      LOWEROK = .TRUE.
#else
      LOWEROK = .FALSE.
#endif
C
C SET UP MAIN COMMAND NAMES
C
      CMDS(KDEV) = 'DEVICE'
      CMDS(KMAXPT) = 'MAXPOINTS'
      CMDS(KCOL) = 'COLOUR'
      CMDS(KWID) = 'WIDTH'
      CMDS(KMARK) = 'MARKER'
      CMDS(KCLR) = 'CLEAR'
      CMDS(KMOVE) = 'MOVE'
      CMDS(KDRAW) = 'DRAW'
      CMDS(KTEXT) = 'TEXT'
      CMDS(KREAD) = 'READ'
      CMDS(KXYPT) = 'XYPOINT'
      CMDS(KXYLN) = 'XYLINE'
      CMDS(KXYAUT) = 'XYAUTO'
      CMDS(KXRAN) = 'XRANGE'
      CMDS(KYRAN) = 'YRANGE'
      CMDS(KXYSAM) = 'XYSAME'
      CMDS(KXLIN) = 'XLINEAR'
      CMDS(KYLIN) = 'YLINEAR'
      CMDS(KXLOG) = 'XLOG'
      CMDS(KYLOG) = 'YLOG'
      CMDS(KXYGRD) = 'GRID'
      CMDS(KOBEY) = 'OBEY'
      CMDS(KEXIT) = 'EXIT'
      CMDS(KHELP) = 'HELP'
      CMDS(KBOUND) = 'BOUNDS'
      CMDS(KTIT) = 'TITLE'
      CMDS(KXLAB) = 'XLABEL'
      CMDS(KYLAB) = 'YLABEL'
      CMDS(KTEST) = 'MEMTEST'
      CMDS(KSTYLE) = 'STYLE'
      CMDS(KGET) = 'GET'
      CMDS(KSTAT) = 'STATUS'
      CMDS(KANNOT) = 'ANNOTATE'
      CMDS(KFLOG) = 'LOGFILE'
      CMDS(KINTERP) = 'INTERPOLATE'
      CMDS(KEBASM) = 'ASYMYERRORBARS'
      CMDS(KHIST) = 'XYHISTOGRAM'
      CMDS(KHISTMD) = 'HISTSTYLE'
      CMDS(KPANE) = 'PANE'
      CMDS(KUNP) = 'UNPANE'
      CMDS(KPANEO) = 'PANEOUTLINE'
      CMDS(KBLNK) = 'BLANK'
      CMDS(KUNBL) = 'UNBLANK'
      CMDS(KBLNKO) = 'BLANKOUTLINE'
      CMDS(KFILL) = 'FILL'
      CMDS(KPATHP) = 'PREFIXPATH'
      CMDS(KEVAL) = 'EVAL'
      CMDS(KERNG) = 'ERANGE'
      CMDS(KPATH) = 'PATH'
      CMDS(KGRMOVE) = 'GRMOVE'
      CMDS(KGRDRAW) = 'GRDRAW'
      CMDS(KNSTACK) = 'NSTACK'
      CMDS(KIEVAL) = 'ITEVAL'
      CMDS(KPROC) = 'PROC'
      CMDS(KSTO) = 'STO'
      CMDS(KRCL) = 'RCL'
      CMDS(KCANVAS) = 'CANVAS'
      CMDS(KCTEXT) = 'CTEXT'
      CMDS(KFONT) = 'FONT'
      CMDS(KLFONT) = 'LISTFONT'
      CMDS(KSYMHT) = 'SYMHT'
      CMDS(KSYMANG) = 'SYMANG'
      CMDS(KSTRING) = 'STRING'
      CMDS(KZERO) = 'ZEROVAL'
      CMDS(KGSTY) = 'GSTYLE'
      CMDS(KRYLAB) = 'RYLABEL'
      CMDS(KGRIGHT) = 'RIGHTANNOT'
      CMDS(KGAXCUT) = 'AXCUT'
      CMDS(KCIRC) = 'CIRCLE'
      CMDS(KARC) = 'ARC'
      CMDS(KRECT) = 'RECT'
      CMDS(KCRECT) = 'CRECT'
      CMDS(KBSTAR) = 'BBSTART'
      CMDS(KBEND) = 'BBEND'
      CMDS(KBSET) = 'BBSET'
      CMDS(KLSYS) = 'LSYSTEM'
      CMDS(KLDPROC) = 'LOADPROC'
      CMDS(KTXBOX) = 'BOXTEXT'
      CMDS(KSETCSG) = 'CSGROUP'
      CMDS(KUSEKEY) = 'USEKEY'
      CMDS(KADDKEY) = 'ADDKEY'
      CMDS(KKEYS) = 'KEYS'
      CMDS(KRESET) = 'RESET'
      CMDS(KTXBPS) = 'BOXPSIZE'
      CMDS(KTXBPH) = 'BOXPHATCH'
      CMDS(KTXBPT) = 'BOXPTEXT'
      CMDS(KTXBPB) = 'BOXPBOX'
      CMDS(KLINE) = 'LINE'
      CMDS(KGLABEL) = 'GLABEL'
      CMDS(KALABEL) = 'ALABEL'
      CMDS(KARPARM) = 'ARROWPARM'
      CMDS(KANPARM) = 'LINEPARM'
      CMDS(KWAIT) = 'WAIT'
      CMDS(KAXINT) = 'INTVALUES'
      CMDS(KVRI) = 'VERSION'
C
C DEVICE NAMES.
C
      DEVNAM(KDGT) = 'GTERM'
      DEVNAM(KDTK) = 'TEK4K'
      DEVNAM(KDEC) = 'EPSCOL'
      DEVNAM(KDEB) = 'EPSBIN'
      DEVNAM(KSVG) = 'SVG'
C
C GRID MODE NAMES. ALSO FOR INT AXIS VALUES.
C
      GRDNAM(KGNO) = 'NONE'
      GRDNAM(KGX) = 'XAXIS'
      GRDNAM(KGY) = 'YAXIS'
      GRDNAM(KGXY) = 'BOTH'
C
C LINE STYLE NAMES.
C
      STYNAM(KSOLID) = 'SOLID'
      STYNAM(KDASH) = 'DASH'
      STYNAM(KDOT) = 'DOT'
      STYNAM(KDSHDOT) = 'DASHDOT'
C
C INTERPOLATION MODE NAMES.
C
      POLNAM(KILIN) = 'LINEAR'
      POLNAM(KICUB) = 'CUBIC'
      POLNAM(KIQUIN) = 'QUINTIC'
C
C HISTOGRAM STYLE NAMES.
C
      HISTNAM(KHABUT) = 'ABUT'
      HISTNAM(KHABUTS) = 'ABUT+SHADE'
      HISTNAM(KHLINE) = 'LINES'
      HISTNAM(KHWID) = 'WIDE'
      HISTNAM(KHWIDS) = 'WIDE+SHADE'
C
C GRAPH STYLE NAMES.
C
      GSTYNAM(KGNORM) = 'BOXED'
      GSTYNAM(KGAXES) = 'AXES'
      GSTYNAM(KGOPEN) = 'OPEN'
C
C COLOUR/STYLE GROUP NAMES.
C
      GCSNAM(KCSALL) = 'ALL'
      GCSNAM(KCSGEN) = 'GENERAL'
      GCSNAM(KCSTEXT) = 'TEXT'
      GCSNAM(KCSANOT) = 'ANNOT'
C
C TEXT BOX HATCHING NAMES.
C
      HBHNAM(KHBNONE) = 'NONE'
      HBHNAM(KHBVRT) = 'VERT'
      HBHNAM(KHBHRZ) = 'HORIZ'
      HBHNAM(KHBALL) = 'BOTH'
C
C TEXT BOX TEXT HANDLING NAMES.
C
      HBTNAM(KHBFIX) = 'FIX'
      HBTNAM(KHBSCL) = 'SCALE'
C
C TEXT BOX BOX HANDLING NAMES.
C
      HBBNAM(KHBBNO) = 'NONE'
      HBBNAM(KHBBOU) = 'OUTER'
      HBBNAM(KHBBIN) = 'INNER'
      HBBNAM(KHBBBT) = 'BOTH'
C
C ARROW TYPES
C
      ARTNAM(KARTOP) = 'OPEN'
      ARTNAM(KARTCL) = 'CLOSED'
      ARTNAM(KARTBA) = 'BARBED'
C
C FONT NAMES AND NUMBERS.
C ALSO SET DIMFILM DEFAULT ASSIGNMENTS IN IDXABT*,IDXSYMB,IDXMARK USING
C TABLE INDICES (IFONT).
C
      IFONT = 1
      FONTNAM(IFONT) = 'SANS.SIMPLEX'
      FONTNUM(IFONT) = 11
      IDXABT1 = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SANS.SIMPLEX.MONO'
      FONTNUM(IFONT) = 111
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SANS.SIMPLEX.GREEK'
      FONTNUM(IFONT) = 1011
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SANS.DUPLEX'
      FONTNUM(IFONT) = 12
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX'
      FONTNUM(IFONT) = 15
      IDXABT2 = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.SMALL'
      FONTNUM(IFONT) = 14
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.GREEK'
      FONTNUM(IFONT) = 1015
      IDXABT3 = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.GREEK.SMALL'
      FONTNUM(IFONT) = 1014
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.TRIPLEX'
      FONTNUM(IFONT) = 16
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.ITALIC'
      FONTNUM(IFONT) = 25
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.ITALIC.SMALL'
      FONTNUM(IFONT) = 24
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.TRIPLEX.ITALIC'
      FONTNUM(IFONT) = 26
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SCRIPT.SIMPLEX'
      FONTNUM(IFONT) = 31
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SCRIPT.COMPLEX'
      FONTNUM(IFONT) = 35
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'GOTHIC.TRIPLEX'
      FONTNUM(IFONT) = 46
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'GOTHIC.TRIPLEX.GERMAN'
      FONTNUM(IFONT) = 56
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'GOTHIC.TRIPLEX.ITALIAN'
      FONTNUM(IFONT) = 66
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'CYRILLIC.COMPLEX'
      FONTNUM(IFONT) = 2015
C
C SYMBOL NAME AND NUMBERS.
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'MATH.SMALL'
      FONTNUM(IFONT) = 8001
      IDXSYMB = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'CARTOGRAPHIC'
      FONTNUM(IFONT) = 8002
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'ASTRONOMICAL'
      FONTNUM(IFONT) = 8003
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'ASTROLOGICAL'
      FONTNUM(IFONT) = 8004
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'MUSICAL'
      FONTNUM(IFONT) = 8005
C
C MARKER NAMES AND NUMBERS.
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'PRINCIPAL'
      FONTNUM(IFONT) = 9001
      IDXMARK = IFONT
C
C CHECK ON NUMBER OF FONTS.
C
      IF( IFONT .NE. NFONTS )STOP 'INTERNAL ERROR IN FONT DEFINITIONS.'
C
C COMMAND DESCRIPTIONS.
C
      DCMDS(KDEV) = 'NAME - SELECT OUTPUT DEVICE'
      DCMDS(KMAXPT) = 'NUMBER - SET MAX DATA POINTS'
      DCMDS(KCOL) = 'R G B - SET RGB COLOUR TO USE'
      DCMDS(KWID) = 'WIDTH - SET LINE WIDTH'
      DCMDS(KMARK) = 'NUMBER - SET POINT MARKER NUMBER'
      DCMDS(KCLR) = 'CLEAR DRAWING AREA.'
      DCMDS(KMOVE) = 'X Y - MOVE TO POSITION'
      DCMDS(KDRAW) = 'X Y - DRAW TO POSITION'
      DCMDS(KTEXT) = '"TEXT" - DRAW TEXT (WITH FORMAT CONTROL)'
      DCMDS(KREAD) = 'NAME XCOL YCOL [YECOL [XECOL]]' //
     +               ' - READ A DATA FILE USING COLUMNS'
      DCMDS(KXYPT) = 'DRAW XY GRAPH WITH POINTS'
      DCMDS(KXYLN) = 'DRAW XY GRAPH WITH LINES'
      DCMDS(KXYAUT) = 'FIND BOTH AXIS RANGES AUTOMATICALLY'
      DCMDS(KXRAN) = 'XLO YHI - SET X AXIS RANGE'
      DCMDS(KYRAN) = 'YLO YHI - SET Y AXIS RANGE'
      DCMDS(KXYSAM) = 'KEEP PREVIOUS XY AXIS RANGES'
      DCMDS(KXLIN) = 'USE LINEAR X AXIS'
      DCMDS(KYLIN) = 'USE LINEAR Y AXIS'
      DCMDS(KXLOG) = 'USE LOG X AXIS'
      DCMDS(KYLOG) = 'USE LOG Y AXIS'
      DCMDS(KXYGRD) = '"NONE" "X" "Y" "BOTH" - GRID GRAPH IN AXIS'
      DCMDS(KOBEY) = 'NAME - READ COMMANDS FROM FILE.'
      DCMDS(KEXIT) = 'EXIT GPLOT'
      DCMDS(KHELP) = '"LIST" LIST ALL COMMANDS, "DEVICES" LIST' //
     +     ' AVAILABLE DEVICES. "<COMMAND>" DESCRIBE COMMAND.'
      DCMDS(KBOUND) = 'XL XH YL YH - SET PLOT BOUNDS'
      DCMDS(KTIT) = '"TEXT" - SET TITLE'
      DCMDS(KXLAB) = '"TEXT" - SET X AXIS LABEL'
      DCMDS(KYLAB) = '"TEXT" - SET Y AXIS LABEL'
      DCMDS(KTEST) = 'TEST DYNAMIC MEMORY. GENERATE PLOT TEST DATA.'
      DCMDS(KSTYLE) = '"SOLID" "DASH" "DOT" "DASHDOT" - LINE STYLE.'
      DCMDS(KGET) = 'NAME - GET AN INDIRECT PERMANENT FILE.'
      DCMDS(KSTAT) = 'DISPLAY STATUS INFORMATION.'
      DCMDS(KANNOT) = '"ON" "OFF" - TURN GRAPH ANNOTATION ON/OFF.'
      DCMDS(KFLOG) = 'NAME - OPEN A COMMAND LOG FILE.'
      DCMDS(KINTERP) = '"LINEAR" "CUBIC" "QUINTIC" [N] - INTERPOLATE.'
      DCMDS(KEBASM) = '"ON" "OFF" - ASYMETTRIC Y ERROR BARS (OFF '//
     +                'FOR X AND Y ERROR BARS).'
      DCMDS(KHIST) = 'DRAW XY HISTOGRAM'
      DCMDS(KHISTMD) = '"ABUT" "ABUT+SHADE" "LINES" "WIDE" '//
     +                 '"WIDE+SHADE" [WIDTH] - HISTOGRAM STYLE.'
      DCMDS(KPANE) = 'XL XH YL YH - SET PANE (CLIPPING) AREA.'
      DCMDS(KUNP) = 'STOP USING ANY PANE.'
      DCMDS(KPANEO) = 'OUTLINE THE PANE.'
      DCMDS(KBLNK) = 'XL XH YL YH - SET BLANK AREA.'
      DCMDS(KUNBL) = 'STOP USING ANY BLANK AREA.'
      DCMDS(KBLNKO) = 'OUTLINE THE BLANK AREA.'
      DCMDS(KFILL) = 'FILL SCREEN WITH COLOUR (DEV. DEP.).'
      DCMDS(KPATHP) = 'PATH PREFIX FOR FILE NAMES. IGNORED ON NOS.'
      DCMDS(KEVAL) = '"RPN" [ARGS] - EVALUATE FUNCTION USING AN RPN '//
     +     'NOTATION. ARGS="V1,V2,...V9"'
      DCMDS(KERNG) = 'BASE START STOP N - SET A RANGE OF X '//
     +               'VALUES FOR EVAL. BASE 1 IS LINEAR.'
      DCMDS(KPATH) = 'C OR O - DRAW A POLYLINE IN BOUNDS COORDINATES.'
      DCMDS(KGRMOVE) = 'X Y - MOVE TO GRAPH COORDS (X,Y)'
      DCMDS(KGRDRAW) = 'X Y - DRAW TO GRAPH COORDS (X,Y)'
      DCMDS(KNSTACK) = 'N - SET STACK SIZE (MIN. 4)'
      DCMDS(KIEVAL) = 'START END STEP "RPN" [ARGS] - '//
     +     'ITERATED EVALUATION '//
     +     'OVER START TO END BY STEP, ITERATION IN I.'
      DCMDS(KPROC) = 'N "RPN" - STORE RPN CODE STRING IN PROC '//
     +               'REGISTER N.'
      DCMDS(KSTO) = 'N X - STORE X IN MEMORY REGISTER N.'
      DCMDS(KRCL) = 'N - DISPLAY CONTENTS OF MEMORY REGISTER N.'
      DCMDS(KCANVAS) = 'XL XH YL YH - SET BOUNDS AND PANE.'
      DCMDS(KCTEXT) = 'W "TEXT" - TEXT H CENTERED ON CUR XPOS,YPOS.'//
     +                ' W WIDTH IN USER UNITS, 0 FOR DEFAULT.'
      DCMDS(KFONT) = 'SET FONTNAME - SET FONT/SYMBOL/MARKER TO USE.'//
     +               ' SET: 1 2 3 S M FOR 3 ALPHABETS, SYMBOL, MARKER.'
      DCMDS(KLFONT) = 'LIST AVAILABLE FONTS'
      DCMDS(KSYMHT) = 'TEXT/SYMBOL/MARKER HEIGHT IN USER BOUNDS UNITS.'
      DCMDS(KSYMANG) = 'TEXT DRAWING ANGLE WRT X AXIS (CCW DEGREES).'
      DCMDS(KSTRING) = 'N "TEXT" - SET CONTENTS OF STRING REGISTER N.'
      DCMDS(KZERO) = 'V - SET ZERO TRAP VALUE FOR EVAL (DEFL 1E-9).'
      DCMDS(KGSTY) = '"NORMAL" "OPEN" "AXES" - SET OVERALL GRAPHING ' //
     +     'STYLE.'
      DCMDS(KRYLAB) = '"LABEL" - RIGHT HAND EDGE LABEL.'
      DCMDS(KGRIGHT) = '"ON" "OFF" - DO RIGHT EDGE ANNOTATION (IF '//
     +                 'ANNOTATE OFF).'
      DCMDS(KGAXCUT) = 'X Y - SET POINT THRU WHICH AXES ARE DRAWN.'
      DCMDS(KCIRC) = 'X Y R - CIRCLE, CENTER X,Y RADIUS R.'
      DCMDS(KARC) = 'X Y R A1 A2 - CIRCULAR ARC, CENTER X,Y RADIUS R '//
     +                 'ANGLE A1 TO A2.'
      DCMDS(KRECT) = 'X Y W H - RECTANGLE AT X,Y WIDTH W HEIGHT H.'
      DCMDS(KCRECT) = 'X Y W H - RECTANGLE CENTER X,Y WIDTH W HEIGHT H.'
      DCMDS(KBSTAR) = 'EVAL/ITEVAL FIND GRAPHICS BOUNDING BOX ONLY.'
      DCMDS(KBEND) = 'EVAL/ITEVAL RETURN TO RENDERING GRAPHICAL ITEMS.'
      DCMDS(KBSET) = 'SET BOUNDS TO BOUNDING BOX (IF ANY).'
      DCMDS(KLSYS) = 'NRULES NITER ANGLE - DEFINE AND DRAW AN L-SYSTEM.'
      DCMDS(KLDPROC) = 'N NAME - LOAD PROCEDURE NAME INTO REGISTER N.'
      DCMDS(KTXBOX) = '"TEXT" XC YC - DRAW TEXT BOX, CENTER XC,YC.'
      DCMDS(KSETCSG) = 'SELECT COLOUR/STYLE GROUP FOR COLOUR, STYLE '//
     +                 'TO AFFECT. "ALL" "GENERAL" "TEXT" "ANNOT".'
      DCMDS(KUSEKEY) = 'PREPARE TO CREATE A KEY FOR THE GRAPH.'
      DCMDS(KADDKEY) = 'ADD A KEY FOR THE CURRENT GRAPH LINE/POINTS.'
      DCMDS(KKEYS) = 'DRAW THE GRAPH KEYS.'
      DCMDS(KRESET) = 'RESET MOST STATE TO INITIAL VALUES.'
      DCMDS(KTXBPS) = 'W H - SET TEXT BOX SIZE (WIDTH, HEIGHT)'
      DCMDS(KTXBPH) = 'SPACING ISLOPE MODE - HATCH SPACING, SLOPE '//
     +     'ANGLE (SPACINGS, INT), "NONE"/"VERT"/"HORIZ"/"BOTH"'
      DCMDS(KTXBPT) = 'WIDTHFRAC MODE - BOX TEXT SIZE AND STYLE. '//
     +     'SIZE AS FRAC OF BOX WIDTH, SIZE MODE "FIX"/"SCALE".'
      DCMDS(KTXBPB) = 'MODE - DRAW "NONE"/"OUTER"/"INNER"/"BOTH".'
      DCMDS(KLINE) = 'LINESTRING - DRAW A DECORATED LINE AS PER ' //
     +     'LINESTRING. P/A/SX,Y[,ANN]>P/A/SX,Y[,ANN] ...'
      DCMDS(KGLABEL) = 'GX GY LENGTH ANGLE TEXT - DRAW GRAPH LABEL.'
      DCMDS(KALABEL) = 'X Y LENGTH ANGLE TEXT - DRAW LABEL.'
      DCMDS(KARPARM) = 'TYPE SIZE SHARPNESS BARBEDNESS - ARROW ' //
     +     'PARAMETERS. TYPE "OPEN", "CLOSED", "BARBED".'
      DCMDS(KANPARM) = 'SKIPSCALE ANNOTSCALE - DECORATED LINE ' //
     +     'PARAMETERS.'
      DCMDS(KWAIT) = 'WAIT FOR USER RESPONSE ON INTERACTIVE DEVICE.'
      DCMDS(KAXINT) = '"NONE" "X" "Y" "BOTH" - TRY TO USE INTEGERS ' //
     +     'FOR AXIS VALUES.'
      DCMDS(KVRI) = 'VERSION - PUT VERSION INFO IN STRING REG 9'
C
C DEVICE DESCRIPTIONS.
C
      DDEVS(KDGT) = 'GTERM COLOUR GRAPHICS TERMINAL'
      DDEVS(KDTK) = 'TEKTRONIX 4014 GRAPHICS TERMINAL'
      DDEVS(KDEC) = 'NAME - COLOUR EPS FILE'
      DDEVS(KDEB) = 'NAME - BLACK/WHITE EPS FILE'
      DDEVS(KSVG) = 'NAME - SVG FILE'
C
C NUMBER OF ARGUMENTS REQUIRED FOR EACH COMMAND.
C
      NARGS(KDEV) = 1
      NARGS(KMAXPT) = 1
      NARGS(KCOL) = 3
      NARGS(KWID) = 1
      NARGS(KMARK) = 1
      NARGS(KCLR) = 0
      NARGS(KMOVE) = 2
      NARGS(KDRAW) = 2
      NARGS(KTEXT) = 1
      NARGS(KREAD) = 3
      NARGS(KXYPT) = 0
      NARGS(KXYLN) = 0
      NARGS(KXYAUT) = 0
      NARGS(KXRAN) = 2
      NARGS(KYRAN) = 2
      NARGS(KXYSAM) = 0
      NARGS(KXLIN) = 0
      NARGS(KYLIN) = 0
      NARGS(KXLOG) = 0
      NARGS(KYLOG) = 0
      NARGS(KXYGRD) = 1
      NARGS(KOBEY) = 1
      NARGS(KEXIT) = 0
      NARGS(KHELP) = 1
      NARGS(KBOUND) = 4
      NARGS(KTIT) = 1
      NARGS(KXLAB) = 1
      NARGS(KYLAB) = 1
      NARGS(KTEST) = 0
      NARGS(KSTYLE) = 1
      NARGS(KGET) = 1
      NARGS(KSTAT) = 0
      NARGS(KANNOT) = 1
      NARGS(KFLOG) = 1
      NARGS(KINTERP) = 2
      NARGS(KEBASM) = 1
      NARGS(KHIST) = 0
      NARGS(KHISTMD) = 1
      NARGS(KPANE) = 4
      NARGS(KUNP) = 0
      NARGS(KPANEO) = 0
      NARGS(KBLNK) = 4
      NARGS(KUNBL) = 0
      NARGS(KBLNKO) = 0
      NARGS(KFILL) = 0
      NARGS(KPATHP) = 1
      NARGS(KEVAL) = 1
      NARGS(KERNG) = 4
      NARGS(KPATH) = 1
      NARGS(KGRMOVE) = 2
      NARGS(KGRDRAW) = 2
      NARGS(KNSTACK) = 1
      NARGS(KIEVAL) = 4
      NARGS(KPROC) = 2
      NARGS(KSTO) = 2
      NARGS(KRCL) = 1
      NARGS(KCANVAS) = 4
      NARGS(KCTEXT) = 2
      NARGS(KFONT) = 2
      NARGS(KLFONT) = 0
      NARGS(KSYMHT) = 1
      NARGS(KSYMANG) = 1
      NARGS(KSTRING) = 2
      NARGS(KZERO) = 1
      NARGS(KGSTY) = 1
      NARGS(KRYLAB) = 1
      NARGS(KGRIGHT) = 1
      NARGS(KGAXCUT) = 2
      NARGS(KCIRC) = 3
      NARGS(KARC) = 5
      NARGS(KRECT) = 4
      NARGS(KCRECT) = 4
      NARGS(KBSTAR) = 0
      NARGS(KBEND) = 0
      NARGS(KBSET) = 0
      NARGS(KLSYS) = 3
      NARGS(KLDPROC) = 2
      NARGS(KTXBOX) = 3
      NARGS(KSETCSG) = 1
      NARGS(KUSEKEY) = 0
      NARGS(KADDKEY) = 1
      NARGS(KKEYS) = 0
      NARGS(KRESET) = 0
      NARGS(KTXBPS) = 2
      NARGS(KTXBPH) = 3
      NARGS(KTXBPT) = 2
      NARGS(KTXBPB) = 1
      NARGS(KLINE) = 1
      NARGS(KGLABEL) = 5
      NARGS(KALABEL) = 5
      NARGS(KARPARM) = 4
      NARGS(KANPARM) = 2
      NARGS(KWAIT) = 0
      NARGS(KAXINT) = 1
      NARGS(KVRI) = 0
C
C DEFAULT STATE ON START UP.
C NO DATA READ YET. NO DEVICE OPENED. ETC.
C
C---- DATA AND ERROR BAR STATE
      HAVDATA = .FALSE.
      HAVYE = .FALSE.
      HAVXE = .FALSE.
      LASYME = .TRUE.
C---- DEVICE STATE
      SLIDE = .TRUE.
      HAVDEV = .FALSE.
      IDEV = 0
      DORESET = .FALSE.
C---- DEBUGGING STATE
      DEBUGON = .FALSE.
      QUIET = .TRUE.
C---- LOG FILE STATE
      HAVFLOG = .FALSE.
C---- FILE NAME PREFIX
      PATHNAM = ' '
C      
C---- A RESET COMMAND COMES TO HERE.
C---- THIS IS A BIT MESSY, BUT WE DO NOT WANT TO DUPLICATE ALL THIS
C---- VARIABLE SET UP.
 2831 CONTINUE
C      
C---- ANNOTATION STATE
      DOANNOT = .TRUE.
      HAVTIT = .FALSE.
      HAVXLAB = .FALSE.
      HAVYLAB = .FALSE.
      HAVRLAB = .FALSE.
      DOXYAUT = .TRUE.
      DOXRAN = .FALSE.
      DOYRAN = .FALSE.
      MARKNUM = 3
      IDOGRID = 1
      HAVAX = .FALSE.
      KEEPAX = .FALSE.
      DOXLOG = .FALSE.
      DOYLOG = .FALSE.
      IGSTY = KGNORM
      DORIGHT = .FALSE.
      AXCX0 = 0.0
      AXCY0 = 0.0
      IAXINT = 1
C---- DRAWING COLOURS
      RED = 1.0
      GRN = 0.0
      BLU = 0.0
      REDGEN = 1.0
      GRNGEN = 0.0
      BLUGEN = 0.0
C---- LINE WIDTH AND STYLE
      WID = 1.0
      ISTY = 1
C---- BOUNDS STATE
      XLO = 0.0
      XHI = 1.0
      YLO = 0.0
      YHI = 1.0
C---- PANE STATE
      PXL = 0.0
      PXH = 1.0
      PYL = 0.0
      PYH = 1.0
      LPANE = .FALSE.
C---- BLANK STATE
      BXL = 0.0
      BXH = 1.0
      BYL = 0.0
      BYH = 1.0
      LBLNK = .FALSE.
C---- PLOT AND GRAPH CURRENT COORDINATES
      XPOS = 0.0
      YPOS = 0.0
      GXPOS = 0.0
      GYPOS = 0.0
C---- INTERPOLATION STATE
      INTERPM = KILIN
      NINTERP = 5
C---- HISTOGRAM STATE
      IHIST = KHABUT
      WHIST = 1.0
C---- OPTIONS STATE
      AUTOGET = .FALSE.
C---- XRANGE AND EVAL
C---- NOTE: PRE-PROCESSING REPLACES FP CONSTANTS TOO BIG FOR
C----       IEEE SINGLE WHERE NECESSARY.
      IF( .NOT. DORESET )THEN
         NEVAL = 0
         RSTART = 0.0
         RSTOP = 1.0
         RBASE = 1.0
      ENDIF
      ZEROVAL = 1.0E-9
      BB(1) = 1.0E300
      BB(2) = -1.0E300
      BB(3) = 1.0E300
      BB(4) = -1.0E300
      DOBB = .FALSE.
      SEVERR = .FALSE.
C---- PROCEDURE REGISTERS
      DO 65 I=1,NREGS
         PROC(I) = ' '
         PROCLEN(I) = 0
         MEMS(I) = 0.0
         STRINGS(I) = ' '
         STRILEN(I) = 0
 65   CONTINUE
C---- TEXT/SYMBOL DRAWING (APART FROM FONTS, SEE ABOVE).
      FSYMHT = 1.0 / 50.0
      FSYMANG = 0.0
      TXTCON = .FALSE.
C---- COLOUR/STYLE GROUP TO SET WITH COLOUR, ETC.
      ICSGRP = KCSALL
C---- KEYS DEFINED
      NKEYS = 0
C---- TEXT BOX STATE
      WTXBOX = 0.2
      HTXBOX = 0.15
      WFTXBOX = 7.0
      DHTXBOX = 0.1
      IATXBOX = 8
      IHTXBOX = KHBVRT
      ITTXBOX = KHBFIX
      IBTXBOX = KHBBOU
      FSYMHTL = FSYMHT
C---- ARROW DRAWING PARAMETERS.
      IARTYPE = KARTBA - 1
      ARSIZE = 0.7 * FSYMHT
      ARSHARP = 2.0
      ARBARB = 0.3
C---- DECORATED LINE DRAWING PARAMETERS.
      ANSKPSL = 0.5
      ANSCALE = 1.2
C
C IF DOING A RESET COMMAND, FINISH IT.
C NOTE THAT FTN5 WILL *NOT* ALLOW YOU TO JUMP BACK
C IN TO THE "RESET" COMMAND HANDLING IF BLOCK, AND IT
C IS PROBABLY RIGHT TO NOT ALLOW THAT. SO HANDLE THINGS HERE
C AND GO TO 1 TO READ THE NEXT COMMAND (OUTSIDE THE COMMAND
C IF BLOCKS).
C
      IF( DORESET )THEN
         CALL BOUNDS(0.0,1.0,0.0,1.0)
         CALL SYMHT(1.0/50.0)
         CALL SYMANG(0.0)
         CALL ENSYMC
         CALL LINSF(1.0)
         CALL RGB(1.0,0.0,0.0)
         CALL SETFR(1.0,0.0,0.13)
         CALL AUTOXY
         CALL LDSYM(8001)
         CALL LDMARK(9001)
         IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.FALSE.)
         DORESET = .FALSE.
         IF( IDEP .EQ. 0 )THEN
            IF(HAVDEV)CALL MAKEVIS(IDEV,NDEVS)
         ENDIF         
         GOTO 1
      ENDIF
C
C STARTUP ANNOUNCEMENT.
C
      CALL VERSION(VSTR)
      WRITE(6,66)
  66  FORMAT(1X,'==============================================')
      WRITE(6,100)VSTR
 100  FORMAT(1X,'GPLOT INTERACTIVE PLOTTING PROGRAM. V',A)
      WRITE(6,66)
      WRITE(6,177)
 177  FORMAT(1X,'BASED ON ULCC DIMFILM BY JOHN GILBERT.')
      WRITE(6,178)
 178  FORMAT(1X,'WRITTEN FOR CDC NOS 2.8 BY NICK GLAZZARD.')
      WRITE(6,179)
 179  FORMAT(1X,'SOME DEVICE & PARSING CODE BY ADRIAN CLARK.')
      WRITE(6,176)
 176  FORMAT(1X,'----------------------------------------------')
      WRITE(6,175)
 175  FORMAT(1X,'USE HELP OR HELP HELP TO GET MORE INFORMATION.')
      WRITE(6,66)
C
C  ALLOCATE SPACE FOR DATA TO BE PLOTTED (DYNAMICALLY).
C
      NPOINTS = NDEFPTS
      NSTACK = 8
      NWORDS = NSTACK * NPOINTS
      CALL CMMALF(NWORDS,0,0,IFWA)
      IOFF = IFWA - LOCF(DA(1))
      IXOFF = IOFF + 1
      IYOFF = IXOFF + NPOINTS
      IAOFF = IYOFF + NPOINTS
      IBOFF = IAOFF + NPOINTS
      WRITE(6,400)NPOINTS
 400  FORMAT(1X,'ALLOCATED SPACE FOR ',I5,' DATA POINTS.')
C
C WARN ABOUT DEVICE COMMAND DELAY.
C OUTPUT IS ONLY FLUSHED ON A READ, SO DOING IT HERE IS BEST.
C
      WRITE(6,9777)
 9777 FORMAT(1X,'NOTE: OPENING DEVICE, LOADING FONTS MAY TAKE ',
     +     'TIME.')
C
C ATTACH THE FONT FILE DIRECTLY FROM THE PROGRAM.
C
#ifndef PORTF77
      CALL PF('ATTACH','DADIMFO','DADIMFO')
#endif
      WRITE(6,9778)
 9778 FORMAT(1X,'ATTACHED FONT FILE DADIMFO. READY.')
C
C ESTABLISH AN INITIAL EVALUATION RANGE, ETC.
C
      RBASE = 1.0
      RSTART = 0.0
      RSTOP = 1.0
      NEVAL = 101
      CALL LINSPC(DA(IXOFF),NEVAL,RSTART,RSTOP)
C
C PARSE ANY COMMAND LINE ARGUMENTS.
C OBEY=NAME - START BY EXECUTING GPLOT COMMANDS IN FILE NAME.
C PARM=STRING - PARAMETERS TO PASS TO AN OBEY FILE ($A B C$).
C QUIET=Y/N - TURN OFF SOME OUTPUT
C DEBUG=Y/N - TURN ON DEBUGGING
C SLIDE=Y/N - USE SLIDE LAYOUT MODE (DEFAULT)
C NOTE THAT STRINGS WITH SPACES CAN BE SPECIFIED ON THE CONTROL
C CARD BY ENCLOSING THEM WITH $S. E.G. $A STRING WITH SPACES$
C
      INUNIT = 7
      IENUNIT = 7
#ifdef PORTF77
      CALL CNSTDIN(INUNIT)
#endif
      CCLINE = ' '
      HAVCCL = .FALSE.
 5000 CONTINUE
C---- GET THE NEXT PARAMETER. STOP WHEN THERE ARE NO MORE.
         CALL GETPARM( KEY, VALUE, ISTAT )
         IF( ISTAT .EQ. -1 )GOTO 5001
#ifdef PORTF77
C---- IF NOT ON NOS, UPCASE KEY SO LOWER CASE WILL MATCH.
         CALL UPCASE( KEY )
#endif
            IF( ISTAT .EQ. 1 )THEN
C---- DEAL WITH KEY WORDS WITH NO VALUES
               WRITE(6,2176)KEY(1:LNBC(KEY,1,1))
 2176          FORMAT(1X,'UNKNOWN KEY ONLY CONTROL CARD OPTION ',A)
            ELSE
C---- DEAL WITH KEY=VALUE PARAMETERS.
               IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'OBEY' )THEN
                  INUNIT = 8
                  IENUNIT = 8
                  CALL ADDSTR(CCLINE,'OBEY',.FALSE.,.FALSE.)
                  CALL ADDSTR(CCLINE,VALUE,.TRUE.,.FALSE.)
                  HAVCCL = .TRUE.
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'PARM' )THEN
                  CALL ADDSTR(CCLINE,VALUE,.TRUE.,.FALSE.)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'DEBUG' )THEN
                  DEBUGON = GETYN(VALUE)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'QUIET' )THEN
                  QUIET = GETYN(VALUE)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'GET' )THEN
                  AUTOGET = GETYN(VALUE)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'SLIDE' )THEN
                  SLIDE = GETYN(VALUE)
               ELSE
                  WRITE(6,2177)KEY(1:LNBC(KEY,1,1))
 2177             FORMAT(1X,'UNKNOWN KEY-VAL CONTROL CARD OPTION ',A)
               ENDIF
            ENDIF
         GOTO 5000
 5001 CONTINUE
C
C INITIALISE DIMFILM. HOPEFULLY.
C
      CALL DIMSET
C
C NO COMMANDS HAVE YET BEEN ISSUED THAT HAVE DRAWN ANYTHING.
C TRACK THIS SO WE CAN FORCE ALL DRAWN THINGS TO BE VISIBLE WHEN
C NEEDED, BUT NOT OTHERWISE.
C
      GCHANGE = .FALSE.
C
C MAIN COMMAND LOOP. READ COMMAND FROM CURRENT INPUT FILE.
C IF HAVCCL, INSERT CCLINE IN TO INLINE WITHOUT A READ JUST ONCE.
C THIS LETS A COMMAND SPECIFIED ON THE CONTROL CARD BE EXECUTED.
C
   1  CONTINUE
      IDEP = INUNIT - IENUNIT
      IF( HAVCCL )THEN
         INLINE = CCLINE
         HAVCCL = .FALSE.
      ELSE
C
C IF THE OBEY FILE STACK DEPTH IS 0, WE ARE READING FROM INPUT.
C IN THAT CASE, FLUSH ANY GRAPHICS COMMANDS AND SWITCH TO TEXT
C MODE ON THE DEVICE (IF THAT IS MEANINGFUL FOR THAT DEVICE).
C
         IF( IDEP .EQ. 0 .AND. HAVDEV )THEN
            CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         ENDIF
#ifdef PORTF77
C---- NOS AUTOMATICALLY ISSUES ? PROMPT FOR READ ON INTERACTIVE
C---- INPUT DEVICE. OTHERWISE, WE HAVE TO ISSUE THE PROMPT OURSELVES.
         IF( IDEP .EQ. 0 )THEN
            WRITE(6,7711)
 7711       FORMAT('? ',$)
         ENDIF
#endif
         READ(INUNIT,101,ERR=998,END=1000)INLINE
 101     FORMAT(A)
#ifndef PORTF77
C---- ON NOS, CONVERT THE WHOLE INPUT LINE TO UPPER CASE NOW.
C---- ON OTHER SYSTEMS, LOOKUP() WILL DO THE CASE CONVERSION WHILE
C---- LEAVING OTHER ARGUMENTS IN MIXED CASE. 
         CALL UPCASE(INLINE)
#endif
C
C IF AT OBEY FILE DEPTH 0 (INTERACTIVE), WRITE TO ANY LOG FILE,
C
         IF( IDEP .EQ. 0 .AND. HAVFLOG )THEN
            WRITE(3,3000)INLINE(1:LNBC(INLINE,1,1))
 3000       FORMAT(A)
         ENDIF
C
C IF THE FIRST CHARACTERS ON THE LINE ARE 'C ', TREAT AS COMMENT.
C IGNORE ANYTHING ON A LINE AFTER A SEMI-COLON.
C BUT ONLY IF IT IS AFTER THE LAST DOUBLE QUOTE (IF ANY).
C
         IF( INLINE(1:2) .EQ. 'C ' )GOTO 1
         JCMT = INDEX(INLINE,';')
         IF( JCMT .GT. 0 )THEN
            INT1 = LOCC(INLINE,'"',1,0)
            JCMT = LOCC(INLINE,';',1,0)
            IF( JCMT .GT. INT1 )INLINE(JCMT:) = ' '
         ENDIF
C
C AFTER THE READ, SWITCH BACK TO GRAPHICS MODE (IF MEANINGFUL).
C
         IF( IDEP .EQ. 0 .AND. HAVDEV )THEN
            CALL GOGRAF(IDEV,NDEVS)
         ENDIF
      ENDIF
      GOTO 900
C
C END OF CURRENT INPUT FILE. POP OBEY FILE STACK. EXIT IF EMPTY.
C WHEN RETURNING TO INTERACTIVE LEVEL, MAKE ANY DRAWING VISIBLE.
C
 1000 CONTINUE
      IF( INUNIT .GT. IENUNIT )THEN
         CLOSE(UNIT=INUNIT,ERR=1001)
 1001    CONTINUE
         INUNIT = INUNIT - 1
         IF( (INUNIT-IENUNIT) .EQ. 0 )THEN
            SEVERR = .FALSE.
            IF( GCHANGE )THEN
               IF(HAVDEV)CALL MAKEVIS(IDEV,NDEVS)
               GCHANGE = .FALSE.
            ENDIF
         ENDIF
C
C IF UNWINDING OBEY FILES AFTER AN EVAL ERROR, REPEAT UNTIL INTERACTIVE.
C
         IF( SEVERR )GOTO 1000
         GOTO 1
      ELSE
         GOTO 2
      ENDIF
C
C GET COMMAND AND ANY TRAILING ARGUMENT STRING.
C
 900  CONTINUE
      IEND = LNBC(INLINE,1,0)
      IF( IEND .EQ. 0 )GOTO 1
      ISTART = NNBC(INLINE,1,0)
      IF( ISTART .EQ. 0 )GOTO 1
      IECMD = NBC(INLINE,ISTART,IEND+1)
      CMD = INLINE(ISTART:IECMD-1)
      IF( IECMD .NE. IEND )THEN
         ISARG = NNBC(INLINE,IECMD,0)
         IF( ISARG .EQ. 0 )THEN
            HAVARG = .FALSE.
            ARGSTR = ' '
         ELSE
            HAVARG = .TRUE.
            ARGSTR = INLINE(ISARG:IEND)
         ENDIF
      ELSE
         HAVARG = .FALSE.
         ARGSTR = ' '
      ENDIF
C
C LOOKUP THE COMMAND
C
      ICMD = LOOKUP(CMDS,NCMDS,CMD,LOWEROK,.TRUE.)
      IF(ICMD .EQ. 0 )THEN
         CALL TXBEGIN
         WRITE(6,102)CMD(1:LNBC(CMD,1,1))
 102     FORMAT(1X,'UNKNOWN COMMAND (',A,'). TRY HELP.')
         CALL TXEND
      ELSE IF( ICMD .LT. 0 )THEN
         CALL TXBEGIN
         WRITE(6,103)CMD(1:LNBC(CMD,1,1))
 103     FORMAT(1X,'AMBIGUOUS COMMAND (',A,'). TRY HELP.')
         CALL TXEND
      ELSE
C
C CHECK ARGUMENTS PRESENT IF REQUIRED, NOT IF NOT.
C HELP, WHICH CAN HAVE NO ARGUMENTS, NEEDS A SPECIAL CASE.
C
         IF( HAVARG .AND. NARGS(ICMD) .EQ. 0 )THEN
            CALL TXBEGIN
            WRITE(6,120)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 120        FORMAT(1X,'COMMAND ',A,' SHOULD HAVE NO ARGUMENTS')
            CALL TXEND
            GOTO 1
         ENDIF
         IF( .NOT. HAVARG .AND. NARGS(ICMD) .GT. 0 )THEN
            IF( ICMD .NE. KHELP )THEN
               CALL TXBEGIN
               WRITE(6,121)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),
     +              NARGS(ICMD)
 121           FORMAT(1X,'COMMAND ',A,' SHOULD HAVE ',I1,' ARGUMENTS')
               CALL TXEND
               GOTO 1
            ENDIF
         ENDIF
C
C IF READING AN OBEY FILE, IF IT HAS PARAMETERS, DO PARAMETER
C SUBSTITUTION. CONVERT ' TO " IN ARGS AFTER SUBSTITUTION.
C
         IF( IDEP .GT. 0 )THEN
            IPFERR = 0
            CALL PARSUB(OBPSTK(IDEP),ARGSTR,LNBC(ARGSTR,1,1),IPFERR)
            IF( IPFERR .NE. 0 )THEN
               SEVERR = .TRUE.
               GOTO 1000
            ENDIF
            CALL QUOTS2D(ARGSTR)
         ENDIF
C
C DIVIDE ARGUMENT STRING IN TO SEPARATE ARGUMENTS.
C ALLOW DOUBLE QUOTES TO ENCLOSE ARGUMENTS WITH SPACES.
C
         ICARGS = 0
         IF( HAVARG )THEN
            ISARG = 1
            DO 129 ICARGS=1,MAXARG
               IF( ARGSTR(ISARG:ISARG) .EQ. '"' )THEN
                  IEARG = NOCC(ARGSTR,'"',ISARG+1,0)
                  IF( IEARG .EQ. 0 )THEN
                     CALL TXBEGIN
                     WRITE(6,123)
 123                 FORMAT(1X,'UNMATCHED QUOTE')
                     CALL TXEND
                     GOTO 1
                  ENDIF
                  ARGS(ICARGS) = ARGSTR(ISARG+1:IEARG-1)
               ELSE
                  IEARG = NBC(ARGSTR,ISARG,IEND)
                  ARGS(ICARGS) = ARGSTR(ISARG:IEARG)
               ENDIF
               IF( IEARG .EQ. IEND )GOTO 130
               ISARG = NNBC(ARGSTR,IEARG+1,0)
               IF( ISARG .EQ. 0 )GOTO 130
 129        CONTINUE
         ENDIF
 130     CONTINUE
C
C CHECK CORRECT NUMBER OF ARGUMENTS FOR COMMAND.
C ALLOW 1 OR 2 ARGUMENTS FOR DEVICE, HISTSTYLE AND OBEY AS SPECIAL CASES
C ALLOW 3, 4 0R 5 ARGUMENTS FOR READ AS A SPECIAL CASE.
C ALLOW 0 OR 1 ARGUMENTS FOR HELP AS A SPECIAL CASE.
C ALLOW 1 OR 2 ARGUMENTS FOR EVAL AS A SPECIAL CASE.
C ALLOW 4 OR 5 ARGUMENTS FOR ITEVAL AS A SPECIAL CASE.
C
         IF( ICARGS .NE. NARGS(ICMD) )THEN
            IF( ICMD .EQ. KDEV .OR. ICMD .EQ. KOBEY .OR.
     +           ICMD .EQ. KREAD .OR. ICMD .EQ. KHISTMD .OR.
     +           ICMD .EQ. KHELP .OR. ICMD .EQ. KEVAL .OR.
     +           ICMD .EQ. KIEVAL )THEN
               IF( ICMD .EQ. KREAD )THEN
                  IF( ICARGS .LT. 3 .OR. ICARGS .GT. 5 )THEN
                     CALL TXBEGIN
                     WRITE(6,124)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),3,5
                     CALL TXEND
                     GOTO 1
                  ENDIF
               ELSE IF( ICMD .EQ. KHELP )THEN
                  IF( ICARGS .GT. 1 )THEN
                     CALL TXBEGIN
                     WRITE(6,124)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),0,1
                     CALL TXEND
                     GOTO 1
                  ENDIF
               ELSE IF( ICMD .EQ. KEVAL )THEN
                  IF( ICARGS .LT. 1 .OR. ICARGS .GT. 2 )THEN
                     CALL TXBEGIN
                     WRITE(6,124)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),1,2
                     CALL TXEND
                     GOTO 1
                  ENDIF
               ELSE IF( ICMD .EQ. KIEVAL )THEN
                  IF( ICARGS .LT. 4 .OR. ICARGS .GT. 5 )THEN
                     CALL TXBEGIN
                     WRITE(6,124)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),4,5
                     CALL TXEND
                     GOTO 1
                  ENDIF
               ELSE
                  IF( ICARGS .GT. 2 )THEN
                     CALL TXBEGIN
                     WRITE(6,124)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),1,2
 124                 FORMAT(1X,'COMMAND ',A,' REQUIRES ',I1,' TO ',
     +                    I1,' ARGUMENTS')
                     CALL TXEND
                     GOTO 1
                  ENDIF
               ENDIF
            ELSE
               CALL TXBEGIN
               WRITE(6,121)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),
     +              NARGS(ICMD)
               CALL TXEND
               GOTO 1
            ENDIF
         ENDIF
C
C DISPLAY THE ARGUMENTS FOR DEBUG PURPOSES (AFTER ANY SUBSTS).
C
         IF( DEBUGON )THEN
            CALL TXBEGIN
            DO 888 IARG=1,ICARGS
               WRITE(6,8881)IARG,ARGS(IARG)(1:LNBC(ARGS(IARG),1,1))
 8881          FORMAT(1X,'ARG NUM=',I2,' ARG=',A)
 888        CONTINUE
            CALL TXEND
         ENDIF
C
C EXECUTE THE COMMAND
C
         IF( .NOT. QUIET )THEN
            CALL TXBEGIN
            WRITE(6,140)(IDEP+1),
     +         CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 140        FORMAT(1X,'--(',I1,')--> ',A)
            CALL TXEND
         ENDIF
         GOTO(201,202,203,204,205,206,207,208,209,210,
     +        211,212,213,214,215,216,217,218,219,220,
     +        221,222,223,224,225,226,227,228,229,230,
     +        231,232,233,234,235,236,237,238,239,240,
     +        241,242,243,244,245,246,247,248,249,250,
     +        251,252,253,254,255,256,257,258,259,260,
     +        261,262,263,264,265,266,267,268,269,270,
     +        271,272,273,274,275,276,277,278,279,280,
     +        281,282,283,284,285,286,287,288,289,290,
     +        291,292,293,294,295),ICMD
C
C DEVICE
 201     CONTINUE
         IF( HAVDEV )THEN
            CALL TXBEGIN
            WRITE(6,2016)
 2016       FORMAT(1X,'DEVICE ALREADY SET. CANNOT REPLACE.')
            CALL TXEND
            GOTO 299
         ENDIF
         IDEV = LOOKUP(DEVNAM,NDEVS,ARGS(1),LOWEROK,.TRUE.)
         IF( IDEV .EQ. 0 )THEN
            WRITE(6,2019)
 2019       FORMAT(1X,'UNKNOWN DEVICE. TRY HELP.')
         ELSE IF( IDEV .LT. 0 )THEN
            WRITE(6,2018)
 2018       FORMAT(1X,'AMBIGUOUS DEVICE. TRY HELP.')
         ELSE
            GOTO(2011,2012,2013,2014,2015),IDEV
C---- GTERM DEVICE
 2011       CONTINUE
            CALL DGTERM
            CALL GTWIDTH(2.0)
            GOTO 2017
C---- TEK4K DEVICE
 2012       CONTINUE
            CALL DTEK4K
            GOTO 2017
C---- EPSCOL DEVICE
 2013       CONTINUE
            IF( ICARGS .NE. 2 )THEN
               WRITE(6,9010)
 9010          FORMAT(1X,'DEVICE NEEDS A FILE NAME.')
               GOTO 299
            ENDIF
            IE = LNBC(ARGS(2),1,1)
            CALL EPSNAM(ARGS(2)(1:IE))
            CALL DEPCOL
            GOTO 2017
C---- EPSBIN DEVICE
 2014       CONTINUE
            IF( ICARGS .NE. 2 )THEN
               WRITE(6,9010)
               GOTO 299
            ENDIF
            IE = LNBC(ARGS(2),1,1)
            CALL EPSNAM(ARGS(2)(1:IE))
            CALL DEPBIN
            GOTO 2017
C---- SVG DEVICE
 2015       CONTINUE
            IF( ICARGS .NE. 2 )THEN
               WRITE(6,9010)
               GOTO 299
            ENDIF
            IE = LNBC(ARGS(2),1,1)
            CALL SVGNAM(ARGS(2)(1:IE))
            CALL DSVGCL
            GOTO 2017
 2017       CONTINUE
C---- COMMON INITIALIZATION
            HAVDEV = .TRUE.
            IF( SLIDE )CALL GRCONA
            IF( QUIET )CALL NOCHCK
            CALL BOUNDS(0.0,1.0,0.0,1.0)
            CALL LINSF(1.0)
            CALL RGB(1.0,0.0,0.0)
            CALL SETFR(1.0,0.0,0.13)
            CALL AUTOXY
            CALL LDSYM(8001)
            CALL LDMARK(9001)
            CALL GFLUSH(IDEV,NDEVS,.FALSE.)
            CALL TXSETUP(IDEV,NDEVS)
         ENDIF
         GOTO 299
C
C MAXPOINTS. FREE AND RE-ALLOCATE POINT DATA STORE.
 202     CONTINUE
         IF( IFROMC(ARGS(1),IWANT,1,NEWPOS) )THEN
            IF(IWANT .LT. 10 .OR. IWANT .GT. MAXPTS )THEN
               CALL TXBEGIN
               WRITE(6,2021)IWANT,MAXPTS
 2021          FORMAT(1X,I7,' POINTS .LT. 10 OR .GT. ',I6,' INVALID.')
               CALL TXEND
               GOTO 299
            ENDIF
            NPOINTS = IWANT
            CALL CMMFRF(IFWA)
#ifdef PORTF77
            NAVAIL = MAXSTK * MAXPTS
#else
            CALL CMMGFS(1,0,NAVAIL)
#endif
            CALL TXBEGIN
            WRITE(6,2023)NAVAIL
 2023       FORMAT(1X,'WORDS AVAILABLE: ',I6,' INCLUDING 1000 EXCESS.')
            NWORDS = NSTACK * NPOINTS
            IF( NWORDS .GT. (NAVAIL-1000) )THEN
               WRITE(6,2024)NSTACK,NPOINTS,NWORDS,NAVAIL-1000
 2024          FORMAT(1X,'NSTACK:',I6,' NPOINTS:',I6,' = ',I6,' WORDS,',
     +                ' EXCEEDS MAX AVAIL:',I6)
               NWORDS = NAVAIL - 1000
               NPOINTS = NWORDS / NSTACK
               WRITE(6,2025)NPOINTS
 2025          FORMAT(1X,'ALLOCATING MAXIMUM. NPOINTS = ',I6)
            ENDIF
            CALL CMMALF(NWORDS,0,0,IFWA)
            IOFF = IFWA - LOCF(DA(1))
            IXOFF = IOFF + 1
            IYOFF = IXOFF + NPOINTS
            IAOFF = IYOFF + NPOINTS
            IBOFF = IAOFF + NPOINTS
            WRITE(6,400)NPOINTS
            HAVDATA = .FALSE.
            IF( NEVAL .GT. NPOINTS )NEVAL = 0
            CALL TXENDGR
         ELSE
            CALL TXBEGIN
            WRITE(6,2022)
 2022       FORMAT(1X,'EXPECTED AN INTEGER.')
            CALL TXEND
         ENDIF
         GOTO 299
C
C COLOUR
 203     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         RED = F1
         GRN = F2
         BLU = F3
         IF( ICSGRP .EQ. KCSALL )THEN
            CALL RGB(MAX(0.01,RED),MAX(0.01,GRN),MAX(0.01,BLU))
            REDGEN = RED
            GRNGEN = GRN
            BLUGEN = BLU
         ELSE IF( ICSGRP .EQ. KCSGEN )THEN
            CALL RGB1(MAX(0.01,RED),MAX(0.01,GRN),MAX(0.01,BLU))
            REDGEN = RED
            GRNGEN = GRN
            BLUGEN = BLU            
         ELSE IF( ICSGRP .EQ. KCSTEXT )THEN
            CALL RGB2(MAX(0.01,RED),MAX(0.01,GRN),MAX(0.01,BLU))
         ELSE IF( ICSGRP .EQ. KCSANOT )THEN
            CALL RGB3(MAX(0.01,RED),MAX(0.01,GRN),MAX(0.01,BLU))
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C WIDTH
 204     CONTINUE
         IF( .NOT.HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         WID = F1
         IF( ICSGRP .EQ. KCSALL )THEN
            CALL LINSF(WID)
         ELSE IF( ICSGRP .EQ. KCSGEN )THEN
            CALL LINSF1(WID)
         ELSE IF( ICSGRP .EQ. KCSTEXT )THEN
            CALL LINSF2(WID)
         ELSE IF( ICSGRP .EQ. KCSANOT )THEN
            CALL LINSF3(WID)
         ENDIF         
         GCHANGE = .TRUE.
         GOTO 299
C
C MARKER
 205     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),INT1,1,LNBC(ARGS(1),1,1)) )
     +      GOTO 9093
         MARKNUM = INT1
         IF( MARKNUM .LT. 3 .OR. MARKNUM .GT. 25 )THEN
            CALL TXBEGIN
            WRITE(6,2052)
 2052       FORMAT(1X,'MARK NUMBERS 3 (DEF) TO 25 ONLY DEFINED.')
            CALL TXEND
            MARKNUM = 3
         ENDIF
         GOTO 299
C
C CLEAR (FRAME)
 206     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL FRAME
         GCHANGE = .TRUE.
         CALL GFLUSH(IDEV,NDEVS,.FALSE.)
         GOTO 299
C
C MOVE
 207     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         XPOS = F1
         YPOS = F2
         CALL OFF2(XPOS,YPOS)
         GCHANGE = .TRUE.
         GOTO 299
C
C DRAW
 208     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         XPOS = F1
         YPOS = F2
         CALL ON2(XPOS,YPOS)
         GCHANGE = .TRUE.
         GOTO 299
C
C TEXT
 209     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL SYMTXT( ARGS(1)(1:LNBC(ARGS(1),1,1)) )
         GCHANGE = .TRUE.
         GOTO 299
C READ
 210     CONTINUE
         NDATA = 0
         NEVAL = 0
         HAVDATA = .FALSE.
         HAVYE = .FALSE.
         HAVXE = .FALSE.
         IF(AUTOGET)THEN
            IF( ARGS(1)(1:LNBC(ARGS(1),1,1)) .NE. 'HERE' )THEN
#ifndef PORTF77
               CALL PF('GET',ARGS(1),ARGS(1),'NA','IGNR','RC',IPFERR)
#else
               IPFERR = 0
#endif
               IF( IPFERR .NE.0 )THEN
                  CALL TXBEGIN
                  WRITE(6,2101)IPFERR
 2101             FORMAT(1X,'PFERROR ',I4,' OCCURRED.')
                  WRITE(6,2102)ARGS(1)(1:LNBC(ARGS(1),1,1))
 2102             FORMAT(1X,'DOES INDIRECT FILE ',A,' EXIST?')
                  CALL TXEND
               ENDIF
            ENDIF
         ENDIF
         CALL DOREAD(ARGS(1),ARGS(2),ARGS(3),DA(IXOFF),DA(IYOFF),
     +        NPOINTS,NDATA,ISTAT,INUNIT,
     +        ARGS(4),ARGS(5),DA(IAOFF),DA(IBOFF),ICARGS,
     +        PATHNAM, FULLNAM)
         IF( ISTAT .EQ. 1 .AND. NDATA .GT. 0 )THEN
            HAVDATA = .TRUE.
            IF( ICARGS .GE. 4 )HAVYE = .TRUE.
            IF( ICARGS .EQ. 5 )HAVXE = .TRUE.
            IF( HAVYE .AND. HAVXE .AND. LASYME )THEN
               CALL AREPACK(DA(IXOFF),DA(IYOFF),DA(IAOFF),DA(IBOFF),
     +                      NDATA)
            ELSE IF( HAVYE .OR. HAVXE )THEN
               CALL REPACK(DA(IXOFF),DA(IYOFF),DA(IAOFF),DA(IBOFF),
     +                     NDATA)
            ENDIF
         ENDIF
         GOTO 299
C
C XYPOINT
C XYLINE
C XYHISTOGRAM
 211     CONTINUE
 212     CONTINUE
 237     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. HAVDATA )GOTO 9095
C---- SET AXIS MODES AND RANGES.
         IF( .NOT. KEEPAX )THEN
            IF( DOXLOG )THEN
               CALL LOGX
            ELSE
               CALL LINX
            ENDIF
            IF( DOYLOG )THEN
               CALL LOGY
            ELSE
               CALL LINY
            ENDIF
            IF( DOXYAUT )THEN
               CALL AUTOXY
            ELSE IF( DOXRAN .AND. DOYRAN )THEN
               CALL XAXIS(XLO,XHI)
               CALL YAXIS(YLO,YHI)
            ELSE IF( DOXRAN )THEN
               CALL XAXIS(XLO,XHI)
               CALL AUTOY
            ELSE IF( DOYRAN )THEN
               CALL YAXIS(YLO,YHI)
               CALL AUTOX
            ELSE
               CALL AUTOXY
            ENDIF
            HAVAX = .TRUE.
         ELSE
            CALL SAMEXY
         ENDIF
C---- DRAW THE GRAPH.
         IF( ICMD .EQ. KXYPT )THEN
            IF( HAVXE .AND. HAVYE )THEN
               IF( LASYME )THEN
                  CALL PTPLTE(DA(IXOFF),DA(IAOFF),NDATA,MARKNUM,1,3)
               ELSE
                  CALL PTPLTE(DA(IXOFF),DA(IYOFF),NDATA,MARKNUM,2,2)
               ENDIF
            ELSE IF( HAVYE )THEN
               CALL PTPLTE(DA(IXOFF),DA(IYOFF),NDATA,MARKNUM,1,2)
            ELSE
               CALL PTPLOT(DA(IXOFF),DA(IYOFF),NDATA,MARKNUM)
            ENDIF
         ELSE IF( ICMD .EQ. KHIST )THEN
            FBW = 0.0
            IF( IHIST .EQ. KHABUT .OR. IHIST .EQ. KHABUTS )THEN
               FBW = -1.0
            ELSE IF( IHIST .EQ. KHLINE )THEN
               FBW = 0.0
            ELSE
               FBW = WHIST
            ENDIF
            IF( IHIST .EQ. KHABUTS .OR. IHIST .EQ. KHWIDS )THEN
               SHDSPC = 0.02 * ( XHI - XLO )
               CALL SHDEGR(DA(IXOFF),DA(IYOFF),NDATA,FBW,45.0,SHDSPC)
               CALL ENPANE
            ELSE
               CALL HISTGR(DA(IXOFF),DA(IYOFF),NDATA,FBW)
            ENDIF
         ELSE
            IF( HAVXE .AND. HAVYE )THEN
               IF(DEBUGON)CALL SHOW2D(DA(IXOFF),DA(IYOFF),NDATA,2,2)
               IF( LASYME )THEN
                  IF( INTERPM .EQ. KILIN )THEN
                     CALL GRAPHE(DA(IXOFF),DA(IAOFF),NDATA,1,3)
                  ELSE IF( INTERPM .EQ. KICUB )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY3E(DA(IXOFF),DA(IAOFF),NDATA,1,3)
                  ELSE IF( INTERPM .EQ. KIQUIN )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY5E(DA(IXOFF),DA(IAOFF),NDATA,1,3)
                  ENDIF
               ELSE
                  IF( INTERPM .EQ. KILIN )THEN
                     CALL GRAPHE(DA(IXOFF),DA(IYOFF),NDATA,2,2)
                  ELSE IF( INTERPM .EQ. KICUB )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY3E(DA(IXOFF),DA(IYOFF),NDATA,2,2)
                  ELSE IF( INTERPM .EQ. KIQUIN )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY5E(DA(IXOFF),DA(IYOFF),NDATA,2,2)
                  ENDIF
               ENDIF
            ELSE IF( HAVYE )THEN
               IF(DEBUGON)CALL SHOW2D(DA(IXOFF),DA(IYOFF),NDATA,1,2)
               IF( INTERPM .EQ. KILIN )THEN
                  CALL GRAPHE(DA(IXOFF),DA(IYOFF),NDATA,1,2 )
               ELSE IF( INTERPM .EQ. KICUB )THEN
                  IF( NDATA .LT. 3 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY3E(DA(IXOFF),DA(IYOFF),NDATA,1,2)
               ELSE IF( INTERPM .EQ. KIQUIN )THEN
                  IF( NDATA .LT. 5 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY5E(DA(IXOFF),DA(IYOFF),NDATA,1,2)
               ENDIF
            ELSE
               IF( INTERPM .EQ. KILIN )THEN
                  IF(DEBUGON)CALL SHOW1D(DA(IXOFF),DA(IYOFF),NDATA)
                  CALL GRAPH(DA(IXOFF),DA(IYOFF),NDATA)
               ELSE IF( INTERPM .EQ. KICUB )THEN
                  IF( NDATA .LT. 3 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY3(DA(IXOFF),DA(IYOFF),NDATA)
               ELSE IF( INTERPM .EQ. KIQUIN )THEN
                  IF( NDATA .LT. 5 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY5(DA(IXOFF),DA(IYOFF),NDATA)
               ENDIF
            ENDIF
         ENDIF
C---- ADD ANNOTATION, TICKS, GRIDS, FRAME / EDGES / AXES
         IF( DOANNOT )THEN
            IF( HAVTIT )CALL UTITLE(TITLE(1:LNBC(TITLE,1,1)))
            IF( HAVXLAB )CALL LXLAB(XLABEL(1:LNBC(XLABEL,1,1)))
            IF( HAVYLAB )CALL LYLAB(YLABEL(1:LNBC(YLABEL,1,1)))
            IF( (.NOT. DOXLOG) .AND. (.NOT. DOYLOG) )THEN
               GOTO(2121,2122,2123,2124),IAXINT
 2121          CONTINUE
                  CALL RXAX
                  CALL RYAX
                  GOTO 2129
 2122          CONTINUE
                  CALL IXAX
                  CALL RYAX
                  GOTO 2129
 2123          CONTINUE
                  CALL RXAX
                  CALL IYAX
                  GOTO 2129
 2124          CONTINUE
                  CALL IXAX
                  CALL IYAX
 2129          CONTINUE
            ENDIF
            IF( IGSTY .EQ. KGNORM )THEN
               CALL LUXTIK
               CALL LRYTIK
               CALL LXVAL
               CALL LYVAL
            ELSE IF( IGSTY .EQ. KGOPEN )THEN
               CALL LXOPT
               CALL LYOPT
               CALL LXVAL
               CALL LYVAL
            ELSE
               CALL AXCUT(AXCX0,AXCY0)
               CALL LXATIK
               CALL LYATIK
               CALL LXAVAL
               CALL LYAVAL
            ENDIF
            GOTO(2119,2111,2112,2113),IDOGRID
 2111       CONTINUE
               CALL XGRID
               GOTO 2119
 2112       CONTINUE
               CALL YGRID
               GOTO 2119
 2113       CONTINUE
               CALL XYGRID
 2119       CONTINUE
            IF( IGSTY .EQ. KGNORM )THEN
               CALL GRFRAM
C              AXES DO NOT EVEN GET TICKS BY DEFAULT.
C              HOWEVER, EXPLICITLY DRAWING AXES GETS THEM DRAWN
C              IN CS GENERAL RATHER THAN CS ANNOTATION.
C              NOT SURE WHAT IS BEST TO DO HERE.
C               CALL DRAWXA
C               CALL DRAWYA
            ELSE IF( IGSTY .EQ. KGOPEN )THEN
               CALL EDGES(0011,0)
            ELSE
               CALL DRAWXA
               CALL DRAWYA
            ENDIF
         ELSE IF( DORIGHT )THEN
            IF(HAVRLAB)CALL RYLAB(RYLABEL(1:LNBC(RYLABEL,1,1)))
            CALL RYOPT
            CALL RYVAL
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
 2114    CONTINUE
         CALL TXBEGIN
         WRITE(6,2115)NDATA,POLNAM(INTERPM)
 2115    FORMAT(1X,I1,' POINTS TOO FEW FOR ',A7,'INTERPOLATION.')
         CALL TXEND
         GOTO 299
C
C XYAUTO
 213     CONTINUE
         KEEPAX = .FALSE.
         DOXYAUT = .TRUE.
         DOXRAN = .FALSE.
         DOYRAN = .FALSE.
         GOTO 299
C
C XRANGE
 214     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         XLO = F1
         XHI = F2
         KEEPAX = .FALSE.
         DOXYAUT = .FALSE.
         DOXRAN = .TRUE.
         GOTO 299
C
C YRANGE
 215     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         YLO = F1
         YHI = F2
         KEEPAX = .FALSE.
         DOXYAUT = .FALSE.
         DOYRAN = .TRUE.
         GOTO 299
C
C XYSAME
 216     CONTINUE
         IF( .NOT. HAVAX )THEN
            CALL TXBEGIN
            WRITE(6,2161)
 2161       FORMAT(1X,'AXES NOT YET DETERMINED. CANNOT KEEP.')
            CALL TXEND
         ELSE
            KEEPAX = .TRUE.
         ENDIF
         GOTO 299
C
C XLINEAR
 217     CONTINUE
         DOXLOG = .FALSE.
         GOTO 299
C
C YLINEAR
 218     CONTINUE
         DOYLOG = .FALSE.
         GOTO 299
C
C XLOG
 219     CONTINUE
         DOXLOG = .TRUE.
         GOTO 299
C
C YLOG
 220     CONTINUE
         DOYLOG = .TRUE.
         GOTO 299
C
C XYGRID
 221     CONTINUE
         IGRID = LOOKUP(GRDNAM,NGRD,ARGS(1),LOWEROK,.TRUE.)
         IF( IGRID .LE. 0 )THEN
            ILKUPE = IGRID
            CLKUPE = 'GRID MODE'
            GOTO 9100
         ELSE
            IDOGRID = IGRID
         ENDIF
         GOTO 299
C OBEY
C SAVE ANY ARGUMENT TO OBEY ON A STACK OF ARGUMENTS.
 222     CONTINUE
         IF( IDEP .EQ. MAXDEP )THEN
            CALL TXBEGIN
            WRITE(6,2221)MAXDEP
 2221       FORMAT(1X,'OBEY NESTING OF MAX ',I1,' EXCEEDED.')
            CALL TXEND
         ELSE
            IF( ICARGS .EQ. 2 )THEN
               OBPSTK(IDEP+1) = ARGS(2)
            ELSE
               OBPSTK(IDEP+1) = ' '
            ENDIF
            IF(AUTOGET)THEN
#ifndef PORTF77
               CALL PF('GET',ARGS(1),ARGS(1),'NA','IGNR','RC',IPFERR)
#else
               IPFERR = 0
#endif
               IF( IPFERR .NE. 0 )THEN
                  CALL TXBEGIN
                  WRITE(6,2101)IPFERR
                  WRITE(6,2102)ARGS(1)(1:LNBC(ARGS(1),1,1))
                  CALL TXEND
               ENDIF
            ENDIF
            CALL DOOBEY(ARGS(1),INUNIT,ISTAT,PATHNAM,FULLNAM)
         ENDIF
         GOTO 299
C
C EXIT
 223     CONTINUE
         GOTO 2
C HELP
 224     CONTINUE
         CALL TXBEGIN
         IF( ICARGS .EQ. 0 )THEN
            CALL DOHELP(CMDS,NCMDS,DCMDS,DEVNAM,NDEVS,DDEVS,
     +           INCMDS,'LIST',LOWEROK)
         ELSE
            CALL DOHELP(CMDS,NCMDS,DCMDS,DEVNAM,NDEVS,DDEVS,
     +           INCMDS,ARGS(1)(1:LNBC(ARGS(1),1,1)),LOWEROK)
         ENDIF
         CALL TXEND
         GOTO 299
C
C BOUNDS
 225     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            CALL TXBEGIN
            WRITE(6,2251)
 2251       FORMAT(1X,'INVALID BOUNDS SPECIFICATION.')
            CALL TXEND
         ELSE
            XLO = F1
            XHI = F2
            YLO = F3
            YHI = F4
            CALL BOUNDS(XLO,XHI,YLO,YHI)
            FSYMHT = (YHI - YLO) / 50.0
            CALL SYMHT(FSYMHT)
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C TITLE
 226     CONTINUE
         TITLE = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVTIT = .TRUE.
         GOTO 299
C
C XLABEL
 227     CONTINUE
         XLABEL = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVXLAB = .TRUE.
         GOTO 299
C
C YLABEL
 228     CONTINUE
         YLABEL = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVYLAB = .TRUE.
         GOTO 299
C
C MEMTEST
 229     CONTINUE
         CALL MEMTEST(NPOINTS,DA(IXOFF),DA(IYOFF),DA(IAOFF),DA(IBOFF))
         HAVDATA = .TRUE.
         NDATA = NPOINTS
         GOTO 299
C
C STYLE
 230     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         ISTY = LOOKUP(STYNAM,NSTY,ARGS(1),LOWEROK,.TRUE.)
         IF( ISTY .LE. 0 )THEN
            ILKUPE = ISTY
            CLKUPE = 'STYLE MODE'
            GOTO 9100
         ELSE
            CALL SETSTY(ISTY)
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C GET
 231     CONTINUE
#ifndef PORTF77
         CALL PF('GET',ARGS(1),ARGS(1),'NA','IGNR','RC',IPFERR)
#else
         IPFERR = 0
#endif
         IF( IPFERR .NE.0 )THEN
            CALL TXBEGIN
            WRITE(6,2101)IPFERR
            WRITE(6,2102)ARGS(1)(1:LNBC(ARGS(1),1,1))
            CALL TXEND
         ENDIF
         GOTO 299
C
C STATUS
 232     CONTINUE
         CALL TXBEGIN
         WRITE(6,*)' '
C
         WRITE(6,2329)'SYSTEM'
 2329    FORMAT(1X,'-----',A,'-----')
         WRITE(6,*)'CURRENT OBEY DEPTH = ',IDEP
         IF( AUTOGET )THEN
            WRITE(6,*)'AUTOMATIC FILE GET ON FOR READ & OBEY.'
         ELSE
            WRITE(6,*)'READ & OBEY OF LOCAL FILES. MANUAL GET REQD.'
         ENDIF
         WRITE(6,*)'PATH PREFIX = [',PATHNAM(1:LNBC(PATHNAM,1,1)),']'
         IF( HAVDEV )THEN
            WRITE(6,*)'DEVICE = ',DEVNAM(IDEV)
         ELSE
            WRITE(6,*)'NO DEVICE OPEN YET.'
         ENDIF
         WRITE(6,*)'MAX POINTS = ',NPOINTS
         WRITE(6,*)'MAX STACK = ',NSTACK
#ifdef PORTF77
            NAVAIL = MAXSTK * MAXPTS
#else
            CALL CMMGFS(1,0,NAVAIL)
#endif
         WRITE(6,*)'AVAILABLE WORDS OF DYNAMIC MEMORY = ',NAVAIL
         IF( HAVFLOG )THEN
            WRITE(6,*)'LOG FILE IS OPEN'
         ELSE
            WRITE(6,*)'NO LOG FILE OPEN.'
         ENDIF
C
         CALL TXPAGE
         WRITE(6,2329)'GRAPH PLOTTING'
         IF( HAVDATA )THEN
            WRITE(6,*)'DATA POINTS READ/EVALUATED = ',NDATA
         ELSE
            WRITE(6,*)'NO DATA READ/EVALUATED YET.'
         ENDIF
         IF( NEVAL .GT. 0 )THEN
            WRITE(6,*)'RANGE STEPS = ',NEVAL
            WRITE(6,*)'RANGE BASE = ',RBASE,' (1:LINEAR, >1:LOG)'
            WRITE(6,*)'RANGE START = ',RSTART
            WRITE(6,*)'RANGE STOP = ',RSTOP
         ELSE
            WRITE(6,*)'NO FUNCTION EVALUATION RANGE ESTABLISHED.'
         ENDIF
         IF( HAVXE .AND. HAVYE )THEN
            IF( LASYME )THEN
               WRITE(6,*)'DRAWING ASYMMETRIC Y ERROR BAR DATA.'
            ELSE
               WRITE(6,*)'DRAWING Y AND X SYMMETRIC ERROR BAR DATA.'
            ENDIF
         ELSE IF( HAVYE )THEN
            WRITE(6,*)'DRAWING Y ERROR BAR DATA.'
         ELSE IF( HAVXE )THEN
            WRITE(6,*)'DRAWING X ERROR BAR DATA.'
         ELSE
            WRITE(6,*)'NO ERROR BAR DATA READ.'
         ENDIF
         IF( HAVAX )THEN
            WRITE(6,*)'AXIS RANGES HAVE BEEN DETERMINED.'
         ELSE
            WRITE(6,*)'AXIS RANGES NOT DETERMINED YET.'
         ENDIF
         IF( DOANNOT )THEN
            WRITE(6,*)'GRAPH ANNOTATION ON.'
         ELSE
            WRITE(6,*)'GRAPH ANNOTATION OFF.'
         ENDIF
         IF( DORIGHT )THEN
             WRITE(6,*)'RIGHT EDGE ANNOTATION ON.'
         ELSE
             WRITE(6,*)'RIGHT EDGE ANNOTATION OFF.'
         ENDIF
         WRITE(6,*)'GRID MODE = ',GRDNAM(IDOGRID)
         WRITE(6,*)'AXIS INT VALUE MODE = ',GRDNAM(IAXINT)
         WRITE(6,*)'INTERPOLATION = ',POLNAM(INTERPM)
         WRITE(6,*)'HISTOGRAM MODE = ',HISTNAM(IHIST)
         WRITE(6,*)'HISTOGRAM BAR WIDTH = ',WHIST
         WRITE(6,*)'GRAPH STYLE = ',GSTYNAM(IGSTY)
         WRITE(6,*)'AXES CROSS AT ',AXCX0,' , ',AXCY0
C
         CALL TXPAGE
         WRITE(6,2329)'DRAWING'
         WRITE(6,*)'BOUNDS = ',XLO,' TO ',XHI,' BY '
         WRITE(6,*)'         ',YLO,' TO ',YHI
         IF( LPANE )THEN
            WRITE(6,*)'PANE = ',PXL,' TO ',PXH,' BY '
            WRITE(6,*)'       ',PYL,' TO ',PYH
         ELSE
            WRITE(6,*)'NO PANE ACTIVE.'
         ENDIF
         IF( LBLNK )THEN
            WRITE(6,*)'BLANK = ',BXL,' TO ',BXH,' BY '
            WRITE(6,*)'        ',BYL,' TO ',BYH
         ELSE
            WRITE(6,*)'NO BLANK AREA ACTIVE.'
         ENDIF
         WRITE(6,*)'XPOS,YPOS = ',XPOS,' , ',YPOS
         WRITE(6,*)'GXPOS,GYPOS = ',GXPOS,' , ',GYPOS
         WRITE(6,*)'MARKER NUMBER = ',MARKNUM
C
         CALL TXPAGE
         WRITE(6,2329)'EVALUATOR'
         DO 2321 I=1,NREGS
            IF( PROCLEN(I) .GT. 0 )THEN
               WRITE(6,*)'PROCEDURE REGISTER ',I,' CONTAINS:'
               WRITE(6,2322)PROC(I)(1:PROCLEN(I))
 2322          FORMAT(1X,A)
            ENDIF
 2321    CONTINUE
         IF( DOBB )THEN
            WRITE(6,*)'EVAL IN BOUNDING BOX ACCUMULATION MODE.'
         ELSE
            WRITE(6,*)'EVAL IN GRAPHICS RENDERING MODE.'
         ENDIF
         IF( BBEMPTY(BB) )THEN
            WRITE(6,*)'EVAL BOUNDING BOX IS EMPTY.'
         ELSE
            WRITE(6,*)'EVAL BOUNDING BOX: XLO=',BB(1),
     +                ' XHI=',BB(2),' YLO=',BB(3),' YHI=',BB(4)
         ENDIF
C
         CALL TXPAGE
         WRITE(6,2329)'FONTS AND TEXT'
         WRITE(6,*)'ALPHABET 1: ',
     +             FONTNAM(IDXABT1)(1:LNBC(FONTNAM(IDXABT1),1,1))
         WRITE(6,*)'ALPHABET 2: ',
     +             FONTNAM(IDXABT2)(1:LNBC(FONTNAM(IDXABT2),1,1))
         WRITE(6,*)'ALPHABET 3: ',
     +             FONTNAM(IDXABT3)(1:LNBC(FONTNAM(IDXABT3),1,1))
         WRITE(6,*)'SYMBOLS: ',
     +             FONTNAM(IDXSYMB)(1:LNBC(FONTNAM(IDXSYMB),1,1))
         WRITE(6,*)'MARKERS: ',
     +             FONTNAM(IDXMARK)(1:LNBC(FONTNAM(IDXMARK),1,1))
         WRITE(6,*)'SYMBOL DRAWING HEIGHT, BOUNDS UNITS: ',FSYMHT
         WRITE(6,*)'SYMBOL DRAWING ANGLE, CCW WRT X AXIS, DEG: ',FSYMANG
         DO 2324 I=1,NREGS
            IF( STRILEN(I) .GT. 0 )THEN
               WRITE(6,*)'STRING REGISTER ',I,' CONTAINS:'
               WRITE(6,2322)STRINGS(I)(1:STRILEN(I))
            ENDIF
 2324    CONTINUE
         IF( TXTCON )THEN
            WRITE(6,*)'TEXT CONTINUATION ON'
         ELSE
            WRITE(6,*)'TEXT CONTINUATION OFF'
         ENDIF
C
         CALL TXPAGE
         WRITE(6,2329)'HIGHER LEVEL DRAWING'
         WRITE(6,*)'BOXTEXT WIDTH: ',WTXBOX
         WRITE(6,*)'BOXTEXT HEIGHT: ',HTXBOX
         WRITE(6,*)'BOXTEXT LINES/HEIGHT OR TEXT WIDTH FRAC: ',WFTXBOX
         WRITE(6,*)'BOXTEXT LAST SYMBOL HEIGHT: ',FSYMHTL
         WRITE(6,*)'BOXTEXT HATCH SPACE FRACTION: ',DHTXBOX
         WRITE(6,*)'BOXTEXT HATCH ANGLE STEPS: ',IATXBOX
         WRITE(6,*)'BOXTEXT HATCH MODE: ',HBHNAM(IHTXBOX)
         WRITE(6,*)'BOXTEXT TEXT MODE: ',HBTNAM(ITTXBOX)
         WRITE(6,*)'BOXTEXT BOX MODE: ',HBBNAM(IBTXBOX)
         WRITE(6,*)'ARROW TYPE: ',ARTNAM(IARTYPE+1)
         WRITE(6,*)'ARROW SIZE: ',ARSIZE
         WRITE(6,*)'ARROW SHARPNESS: ',ARSHARP
         WRITE(6,*)'ARROW BARBNESS: ',ARBARB
         WRITE(6,*)'LINE SKIP SCALE: ',ANSKPSL
         WRITE(6,*)'LINE ANNOTATION SCALE: ',ANSCALE
C         
         CALL TXENDGR
         GOTO 299
C
C ANNOT
 233     CONTINUE
         DOANNOT = GETYN(ARGS(1))
         GOTO 299
C
C LOGFILE
 234     CONTINUE
         IF( HAVFLOG )THEN
            CLOSE(UNIT=3,ERR=2343)
 2343       CONTINUE
         ENDIF
         CALL MKFULNM(ARGS(1),PATHNAM,FULLNAM,MAXFNL,IFNE)
         OPEN(UNIT=3,FILE=FULLNAM(1:IFNE),STATUS='NEW',ERR=2341)
         HAVFLOG = .TRUE.
         GOTO 299
 2341    CONTINUE
         CALL TXBEGIN
         WRITE(6,2342)ARGS(1)(1:IFNE)
 2342    FORMAT(1X,'CANNOT CREATE LOG FILE: ',A,' NOT NEW?')
         CALL TXEND
         HAVFLOG = .FALSE.
         GOTO 299
C
C INTERP
 235     CONTINUE
         INTM = LOOKUP(POLNAM,NPOL,ARGS(1),LOWEROK,.TRUE.)
         IF( INTM .LE. 0 )THEN
            ILKUPE = INTM
            CLKUPE = 'INTERP MODE'
            GOTO 9100
         ELSE
            INTERPM = INTM
         ENDIF
         IF( ICARGS .EQ. 2 )THEN
            IF( .NOT. IFROMC(ARGS(2),NINTERP,1,LNBC(ARGS(2),1,1)) )
     +          GOTO 9093
            IF(NINTERP .LT. 5)NINTERP = 5
         ENDIF
         GOTO 299
C
C ASYMYERRORBARS
 236     CONTINUE
         LASYME = GETYN(ARGS(1))
         GOTO 299
C
C HISTSTYLE
 238     CONTINUE
         IHMD = LOOKUP(HISTNAM,NHIST,ARGS(1),LOWEROK,.TRUE.)
         IF( IHMD .LE. 0 )THEN
            ILKUPE = IHMD
            CLKUPE = 'HISTOGRAM STYLE'
            GOTO 9100
         ELSE
            IHIST = IHMD
         ENDIF
         IF( ICARGS .EQ. 2 )THEN
            IF( .NOT. RFROMC(ARGS(2),F1,1,LNBC(ARGS(2),1,1)) )
     +         GOTO 9098
            WHISTIN = F1
            IF(WHISTIN .LT. 0.0)WHISTIN = 0.0
            WHIST = WHISTIN
         ENDIF
         GOTO 299
C
C PANE
 239     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            CALL TXBEGIN
            WRITE(6,2391)
 2391       FORMAT(1X,'INVALID PANE SPECIFICATION.')
            CALL TXEND
         ELSE
            PXL = F1
            PXH = F2
            PYL = F3
            PYH = F4
            CALL PANE(PXL,PXH,PYL,PYH)
         ENDIF
         LPANE = .TRUE.
         GCHANGE = .TRUE.
         GOTO 299
C
C UNPANE
 240     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL ENPANE
         LPANE = .FALSE.
         GOTO 299
C
C PANEOUTLINE
 241     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. LPANE )THEN
            CALL TXBEGIN
            WRITE(6,2411)
 2411       FORMAT(1X,'WARNING - NO PANE ACTIVE.')
            CALL TXEND
         ELSE
            CALL OPANE
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C BLANK
 242     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            CALL TXBEGIN
            WRITE(6,2421)
 2421       FORMAT(1X,'INVALID BLANK SPECIFICATION.')
            CALL TXEND
         ELSE
            BXL = F1
            BXH = F2
            BYL = F3
            BYH = F4
            CALL BLANK(BXL,BXH,BYL,BYH)
         ENDIF
         LBLNK = .TRUE.
         GCHANGE = .TRUE.
         GOTO 299
C
C UNBLANK
 243     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL ENBLNK
         LBLNK = .FALSE.
         GOTO 299
C
C BLANKOUTLINE
 244     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. LBLNK )THEN
            CALL TXBEGIN
            WRITE(6,2441)
 2441       FORMAT(1X,'WARNING - NO BLANK AREA ACTIVE.')
            CALL TXEND
         ELSE
            CALL OBLANK
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C FILL
 245     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL DEVFILL(IDEV,NDEVS,RED,GRN,BLU)
         GOTO 299
C
C PATHPREFIX
 246     CONTINUE
         PATHNAM = ARGS(1)(1:LNBC(ARGS(1),1,1))
         GOTO 299
C
C EVAL
C ITEVAL
 247     CONTINUE
C---- EVAL.
         ITERST = 1
         ITEREN = 1
         ITERIN = 1
         IAP = 1
         IF( ICARGS .EQ. 2 )THEN
            IF( .NOT. SETREGS(ARGS(2), MEMS, NREGS) )GOTO 299
         ENDIF
         GOTO 2473
 253     CONTINUE
C---- ITEVAL.
         IF( .NOT. IFROMC(ARGS(1),ITERST,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( .NOT. IFROMC(ARGS(2),ITEREN,1,LNBC(ARGS(2),1,1)) )GOTO 9093
         IF( .NOT. IFROMC(ARGS(3),ITERIN,1,LNBC(ARGS(3),1,1)) )GOTO 9093
         IAP = 4
         IF( ICARGS .EQ. 5 )THEN
            IF( .NOT. SETREGS(ARGS(5), MEMS, NREGS) )GOTO 299
         ENDIF
 2473    CONTINUE
C---- SHARED EVAL/ITEVAL.
         IF( NEVAL .EQ. 0 )THEN
            CALL TXBEGIN
            WRITE(6,2471)
 2471       FORMAT(1X,'NO ERANGE HAS BEEN SET.  DEFAULTING.')
            CALL TXENDGR
            RBASE = 1.0
            RSTART = 0.0
            RSTOP = 1.0
            NEVAL = 101
            CALL LINSPC(DA(IXOFF),NEVAL,RSTART,RSTOP)
         ENDIF
         LEXPROC = EXPROC(ARGS(IAP)(1:LNBC(ARGS(IAP),1,1)), PROCEXP,
     +        PROC, PROCLEN, NREGS )
         IF( LEXPROC .GT. 0 )THEN
            DO 2472 ITER=ITERST,ITEREN,ITERIN
               IF( EVAL(DA(IXOFF),NEVAL,NPOINTS,NWORDS,NSTACK,
     +              PROCEXP(1:LEXPROC),
     +              HAVDEV, IDEV, NDEVS, ITER, MEMS,
     +              GCHANGE, RBASE, RSTART, RSTOP,
     +              STRINGS, STRILEN, TXTCON,
     +              ZEROVAL, BB, DOBB, FSYMHT,
     +              ARSIZE, ARSHARP, ARBARB,
     +              IARTYPE, ANSKPSL, ANSCALE) .EQ. 0 )THEN
                  HAVDATA = .TRUE.
                  NDATA = NEVAL
               ELSE
                  HAVDATA = .FALSE.
                  NDATA = 0
                  IF( IDEP .GT. 0 .OR. INUNIT .EQ. 8 )THEN
                     CALL TXBEGIN
                     WRITE(6,2474)
 2474      FORMAT(1X,'EVAL ERROR IN SCRIPT, RETURNING TO INTERACTIVE.')
                     CALL TXEND
                     SEVERR = .TRUE.
                     GOTO 1000
                  ENDIF
               ENDIF
 2472       CONTINUE
            IF( DOBB )THEN
               IF( BBEMPTY(BB) )THEN
                  CALL TXBEGIN
                  WRITE(6,*)'EVAL BOUNDING BOX IS EMPTY.'
                  CALL TXEND
               ELSE
                  CALL TXBEGIN
                  WRITE(6,*)'EVAL BOUNDING BOX UPDATED, XLO=',BB(1),
     +                 ' XHI=',BB(2),' YLO=',BB(3),' YHI=',BB(4)
                  CALL TXEND
               ENDIF
            ENDIF
         ENDIF
         GOTO 299
C
C ERANGE
 248     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),RBASE,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),RSTART,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),RSTOP,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. IFROMC(ARGS(4),NEVAL,1,LNBC(ARGS(4),1,1)) )GOTO 9093
         IF( (NEVAL .LT. 2) .OR. (NEVAL .GT. NPOINTS) )THEN
            CALL TXBEGIN
            WRITE(6,2481)NEVAL, NPOINTS
 2481       FORMAT(1X, 'INVALID NUMBER OF PNTS, ',I6,', CUR MAX ',I6)
            CALL TXEND
         ELSE
            IF( RBASE .LE. 1.0 )THEN
               CALL LINSPC(DA(IXOFF),NEVAL,RSTART,RSTOP)
            ELSE
               CALL LOGSPC(DA(IXOFF),NEVAL,RSTART,RSTOP,RBASE)
            ENDIF
         ENDIF
         GOTO 299
C
C PATH
 249     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. HAVDATA )GOTO 9095
         IF( NDATA .GT. 1 )THEN
            CALL PATH(DA(IXOFF),DA(IYOFF),NDATA,(ARGS(1)(1:1).EQ.'C'))
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C GRMOVE
C GRDRAW
 250     CONTINUE
         DOGRON = .FALSE.
         GOTO 2502
 251     CONTINUE
         DOGRON = .TRUE.
 2502    CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         GXPOS = F1
         GYPOS = F2
         IF( DOGRON )THEN
            CALL GRON(GXPOS,GYPOS)
         ELSE
            CALL GROFF(GXPOS,GYPOS)
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C NSTACK
 252     CONTINUE
         IF( IFROMC(ARGS(1),IWANT,1,NEWPOS) )THEN
            IF(IWANT .LT. 4 .OR. IWANT .GT. MAXSTK )THEN
               CALL TXBEGIN
               WRITE(6,2521)IWANT,MAXSTK
 2521          FORMAT(1X,I7,' NSTACK .LT. 4 OR .GT. ',I2,' INVALID.')
               CALL TXEND
               GOTO 299
            ENDIF
            NSTACK = IWANT
            CALL CMMFRF(IFWA)
#ifdef PORTF77
            NAVAIL = MAXSTK * MAXPTS
#else
            CALL CMMGFS(1,0,NAVAIL)
#endif
            CALL TXBEGIN
            WRITE(6,2523)NAVAIL
 2523       FORMAT(1X,'WORDS AVAILABLE: ',I6,' INCLUDING 1000 EXCESS.')
            NWORDS = NSTACK * NPOINTS
            IF( NWORDS .GT. (NAVAIL-1000) )THEN
               WRITE(6,2524)NSTACK,NPOINTS,NWORDS,NAVAIL-1000
 2524          FORMAT(1X,'NSTACK:',I6,' NPOINTS:',I6,' = ',I6,' WORDS,',
     +                ' EXCEEDS MAX AVAIL:',I6)
               NWORDS = NAVAIL - 1000
               NPOINTS = NWORDS / NSTACK
               WRITE(6,2525)NPOINTS
 2525          FORMAT(1X,'ALLOCATING MAXIMUM. NPOINTS = ',I6)
            ENDIF
            CALL CMMALF(NWORDS,0,0,IFWA)
            IOFF = IFWA - LOCF(DA(1))
            IXOFF = IOFF + 1
            IYOFF = IXOFF + NPOINTS
            IAOFF = IYOFF + NPOINTS
            IBOFF = IAOFF + NPOINTS
            WRITE(6,2526)NSTACK
 2526       FORMAT(1X,'ALLOCATED SPACE FOR ',I2,' STACK LEVELS.')
            HAVDATA = .FALSE.
            IF( NEVAL .GT. NPOINTS )NEVAL = 0
            CALL TXENDGR
         ELSE
            GOTO 9093
         ENDIF
         GOTO 299
C
C ITEVAL - 253 - SEE 247 EVAL.
C
C PROC
 254     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            CALL TXBEGIN
            WRITE(6,2541)IREG
 2541       FORMAT(1X,I3,' IS NOT A VALID REGISTER NUMBER.')
            CALL TXEND
         ELSE
            PROC(IREG) = ARGS(2)
            PROCLEN(IREG) = LNBC(ARGS(2),1,0)
         ENDIF
         GOTO 299
C
C STO
 255     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. NREGS )THEN
            CALL TXBEGIN
            WRITE(6,2541)IREG
            CALL TXEND
         ELSE
            IF( .NOT. RFROMC(ARGS(2),F1,1,LNBC(ARGS(2),1,1)) )GOTO 9098
            MEMS(IREG) = F1
         ENDIF
         GOTO 299
C
C RCL
 256     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         CALL TXBEGIN
         IF( IREG .LT. 1 .OR. IREG .GT. NREGS )THEN
            WRITE(6,2541)IREG
         ELSE
            WRITE(6,2561)IREG, MEMS(IREG)
 2561       FORMAT(1X,'MEMS(',I1,') = ', G13.6)
         ENDIF
         CALL TXEND
         GOTO 299
C
C CANVAS
 257     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            CALL TXBEGIN
            WRITE(6,2571)
 2571       FORMAT(1X,'INVALID CANVAS SPECIFICATION.')
            CALL TXEND
         ELSE
            XLO = F1
            XHI = F2
            YLO = F3
            YHI = F4
            PXL = F1
            PXH = F2
            PYL = F3
            PYH = F4
            CALL BOUNDS(XLO,XHI,YLO,YHI)
            CALL PANE(PXL,PXH,PYL,PYH)
         ENDIF
         LPANE = .TRUE.
         GCHANGE = .TRUE.
         GOTO 299
C CTEXT
 258     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         TWD = F1
         TWIDTH = STRING( ARGS(2)(1:LNBC(ARGS(2),1,1)) )
         IF( TWD .GT. 0.0 )THEN
            F2 = TWD / TWIDTH
            CALL SYMHT(F2)
            TWIDTH = TWD
         ELSE
            F2 = FSYMHT
            TWIDTH = F2 * TWIDTH
         ENDIF
         CALL OFF2(XPOS-TWIDTH/2,YPOS-0.5*F2)
         CALL SYMTXT( ARGS(2)(1:LNBC(ARGS(2),1,1)) )
         IF( TWD .GT. 0.0 )THEN
            CALL SYMHT(FSYMHT)
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C FONT SELECTION.
 259     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IFONT = LOOKUP(FONTNAM,NFONTS,ARGS(2)(1:LNBC(ARGS(2),1,1)),
     +        LOWEROK,.TRUE.)
         IF( IFONT .LE. 0 )THEN
            ILKUPE = IFONT
            CLKUPE = 'FONT, MARKER OR SYMBOL FONT'
            GOTO 9100
         ELSE
            IF( ARGS(1)(1:1) .EQ. '1' )THEN
               IF( FONTNUM(IFONT) .GE. 8000 )GOTO 2594
               CALL LDABET(1,FONTNUM(IFONT))
               IDXABT1 = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. '2' )THEN
               IF( FONTNUM(IFONT) .GE. 8000 )GOTO 2594
               CALL LDABET(2,FONTNUM(IFONT))
               IDXABT2 = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. '3' )THEN
               IF( FONTNUM(IFONT) .GE. 8000 )GOTO 2594
               CALL LDABET(3,FONTNUM(IFONT))
               IDXABT3 = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. 'S' )THEN
               IF( FONTNUM(IFONT) .GE. 9000 .OR.
     +             FONTNUM(IFONT) .LT. 8001 )GOTO 2594
               CALL LDSYM(FONTNUM(IFONT))
               IDXSYMB = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. 'M' )THEN
               IF( FONTNUM(IFONT) .LT. 9001 )GOTO 2594
               CALL LDMARK(FONTNUM(IFONT))
               IDXMARK = IFONT
            ELSE
               CALL TXBEGIN
               WRITE(6,2593)
 2593          FORMAT(1X,'UNKNOWN FONT TYPE (NOT 1,2,3,S,M)')
               CALL TXEND
            ENDIF
            GOTO 2596
 2594       CONTINUE
            CALL TXBEGIN
            WRITE(6,2595)ARGS(1)(1:1)
 2595       FORMAT(1X,'FONT INAPPROPRIATE FOR USE WITH SET: ',A)
            CALL TXEND
 2596       CONTINUE
         ENDIF
         GOTO 299
C
C LIST FONTS
 260     CONTINUE
         CALL TXBEGIN
         DO 2601 I=1,NFONTS
            CFONMK = ' '
            IF( FONTNUM(I) .LT. 8001 )THEN
               IF( I .EQ. IDXABT1 )THEN
                  CFONMK = '1'
               ELSE IF( I .EQ. IDXABT2 )THEN
                  CFONMK = '2'
               ELSE IF( I .EQ. IDXABT3 )THEN
                  CFONMK = '3'
               ENDIF
               WRITE(6,2602)FONTNAM(I), 'ALPHABETIC', CFONMK
            ELSE IF( FONTNUM(I) .LT. 9000 )THEN
               IF( I .EQ. IDXSYMB )CFONMK = 'S'
               WRITE(6,2602)FONTNAM(I), 'SYMBOL', CFONMK
            ELSE
               IF( I .EQ. IDXMARK )CFONMK = 'M'
               WRITE(6,2602)FONTNAM(I), 'MARKER', CFONMK
            ENDIF
 2601    CONTINUE
         CALL TXEND
 2602    FORMAT(1X,A30,A15,1X,A1)
         GOTO 299
C
C TEXT / SYMBOL / MARKER DRAWING HEIGHT.
 261     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         FSYMHT = F1
         FSYMHTL = FSYMHT
         CALL SYMHT(FSYMHT)
         CALL MARKHT(FSYMHT)
         GOTO 299
C
C TEXT / SYMBOL DRAWING ANGLE.
 262     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         FSYMANG = F1
         CALL SYMANG(FSYMANG)
         GOTO 299
C
C STRING
 263     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            CALL TXBEGIN
            WRITE(6,2541)IREG
            CALL TXEND
         ELSE
            STRINGS(IREG) = ARGS(2)
            STRILEN(IREG) = LNBC(ARGS(2),1,0)
         ENDIF
         GOTO 299
C
C ZEROVAL
 264     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         ZEROVAL = F1
         GOTO 299
C
C GSTYLE
 265     CONTINUE
         IARG = LOOKUP(GSTYNAM,NGSTY,ARGS(1),LOWEROK,.TRUE.)
         IF( IARG .LE. 0 )THEN
            ILKUPE = IARG
            CLKUPE = 'UNKNOWN GRAPH STYLE'
            GOTO 9100
         ELSE
            IGSTY = IARG
         ENDIF
         GOTO 299
C
C RYLABEL
 266     CONTINUE
         RYLABEL = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVRLAB = .TRUE.
         GOTO 299
C
C RIGHTANNOT
 267     CONTINUE
         DORIGHT = GETYN(ARGS(1))
         GOTO 299
C
C AXCUT
 268     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         AXCX0 = F1
         AXCY0 = F2
         GOTO 299
C
C CIRCLE
 269     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         CALL CIRCLE(F1,F2,F3)
         GOTO 299
C
C ARC
 270     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(5),F5,1,LNBC(ARGS(5),1,1)) )GOTO 9098
         CALL CIRARC(F1,F2,F3,F4,F5)
         GOTO 299
C
C RECT
C CRECT
 271     CONTINUE
 272     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( ICMD .EQ. KCRECT )THEN
            F1 = F1 - 0.5 * F3
            F2 = F2 - 0.5 * F4
         ENDIF
         CALL RECT(F1,F2,0.0,F3,F4)
         GOTO 299
C
C BBSTART - EVAL/ITEVAL TO FIND BOUNDING BOX ONLY.
C            NOTE: PRE-PROCESSING REPLACES FP CONSTANTS TOO BIG FOR
C                  IEEE SINGLE WHERE NECESSARY.
 273     CONTINUE
         BB(1) = 1.0E300
         BB(2) = -1.0E300
         BB(3) = 1.0E300
         BB(4) = -1.0E300
         DOBB = .TRUE.
         CALL TXBEGIN
         WRITE(6,*)'EVAL/ITEVAL WILL ACCUMULATE BOUNDING BOX.'
         CALL TXEND
         GOTO 299
C
C BBEND - EVAL/ITEVAL TO RETURN TO DRAWING GRAPHICAL ITEMS.
 274     CONTINUE
         DOBB = .FALSE.
         CALL TXBEGIN
         WRITE(6,*)'EVAL/ITEVAL WILL RENDER GRAPHICAL ITEMS.'
         CALL TXEND
         GOTO 299
C
C BBSET - SET BOUNDS TO EVAL BOUNDING BOX (IF ANY).
 275     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL TXBEGIN
         IF( BBEMPTY(BB) )THEN
            WRITE(6,*)'EVAL BOUNDING BOX EMPTY. BOUNDS UNCHANGED.'
         ELSE
            XLO = BB(1)
            XHI = BB(2)
            YLO = BB(3)
            YHI = BB(4)
            CALL BOUNDS(XLO,XHI,YLO,YHI)
            GCHANGE = .TRUE.
            WRITE(6,*)'BOUNDS SET TO EVAL BOUNDING BOX.'
         ENDIF
         CALL TXEND
         GOTO 299
C
C LSYSTEM
 276     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),INT1,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( .NOT. IFROMC(ARGS(2),INT2,1,LNBC(ARGS(2),1,1)) )GOTO 9093
         IF( .NOT. RFROMC(ARGS(3),F1,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( LSYSTEM(INT1, INT2, F1, STRINGS, STRILEN, MEMS) .NE. 0)THEN
            IF( IDEP .GT. 0 .OR. INUNIT .EQ. 8 )THEN
               CALL TXBEGIN
               WRITE(6,2761)
 2761    FORMAT(1X,'LSYSTEM ERROR IN SCRIPT, RETURNING TO INTERACTIVE.')
               CALL TXEND
               SEVERR = .TRUE.
               GOTO 1000
            ENDIF
         ENDIF
         GOTO 299
C
C LOADPROC
 277     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            CALL TXBEGIN
            WRITE(6,2541)IREG
            CALL TXEND
         ELSE
            CALL LDPROC(ARGS(2)(1:LNBC(ARGS(2),1,1)),IREG,PROC,IDEV,
     +                  NDEVS,HAVDEV,PATHNAM,FULLNAM)
            PROCLEN(IREG) = LNBC(PROC(IREG),1,0)
         ENDIF
         GOTO 299
C
C TXBOX
 278     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( ITTXBOX .EQ. KHBFIX )THEN
            F4 = WFTXBOX
         ELSE
            F4 = WFTXBOX * WTXBOX
         ENDIF
         CALL HTBOX(ARGS(1)(1:LNBC(ARGS(1),1,1)),
     +        IATXBOX,
     +        F2, F3,
     +        WTXBOX, HTXBOX,
     +        F4,
     +        DHTXBOX * WTXBOX,
     +        XLO, XHI,
     +        (IHTXBOX .EQ. KHBHRZ) .OR. (IHTXBOX .EQ. KHBALL),
     +        (IHTXBOX .EQ. KHBVRT) .OR. (IHTXBOX .EQ. KHBALL),
     +        (IBTXBOX .EQ. KHBBIN) .OR. (IBTXBOX .EQ. KHBBBT),
     +        ITTXBOX .EQ. KHBFIX,
     +        FSYMHT,
     +        (IBTXBOX .EQ. KHBBOU) .OR. (IBTXBOX .EQ. KHBBBT),
     +        FSYMHTL)
         GCHANGE = .TRUE.
         GOTO 299
C
C CSGROUP
 279     CONTINUE
         I = LOOKUP(GCSNAM,NGCS,ARGS(1),LOWEROK,.TRUE.)
         IF( I .LE. 0 )THEN
            ILKUPE = I
            CLKUPE = 'COLOUR/STYLE GROUP NAME'
            GOTO 9100
         ELSE
            ICSGRP = I
         ENDIF
         GOTO 299
C
C USEKEY
 280     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( LPANE )CALL ENPANE
         PXL = 0.0
         PXH = 0.8
         PYL = 0.0
         PYH = 0.999
         CALL PANE(PXL,PXH,PYL,PYH)
         LPANE = .TRUE.
         GCHANGE = .TRUE.
         NKEYS = 0
         GCHANGE = .TRUE.
         GOTO 299
C
C ADDKEY
 281     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( NKEYS .EQ. MAXKEY )THEN
            CALL TXBEGIN
            WRITE(6,2811)
 2811       FORMAT(1X,'CANNOT ADD ANOTHER KEY, ALL USED.')
            CALL TXEND
         ELSE
            NKEYS = NKEYS + 1
            KEYTEXT(NKEYS) = ARGS(1)(1:MIN(10,LNBC(ARGS(1),1,1)))
            KEYRED(NKEYS) = RED
            KEYGRN(NKEYS) = GRN
            KEYBLU(NKEYS) = BLU
            KEYWID(NKEYS) = WID
            KEYSTY(NKEYS) = ISTY
         ENDIF
         GOTO 299
C
C KEYS
 282     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090         
         IF( .NOT. LPANE )THEN
            CALL TXBEGIN
            WRITE(6,2821)
 2821       FORMAT(1X,'EXPECTED ACTIVE PANE. FORGOT USEKEY?')
            CALL TXEND
         ELSE
            CALL OPANE
            CALL ENPANE
            IF( NKEYS .EQ. 0 )THEN
               CALL TXBEGIN
               WRITE(6,2822)
 2822          FORMAT(1X,'NO KEYS ADDED.')
               CALL TXEND
            ELSE
               PXL = 0.82
               PXH = 0.999
               PYL = 0.0
               PYH = 0.999
               CALL PANE(PXL,PXH,PYL,PYH)
               LPANE = .TRUE.
               GCHANGE = .TRUE.        
               XPOS = 0.91
               YPOS = 0.95
               CALL OFF2(XPOS,YPOS)
               TWD = 0.1
               TWIDTH = STRING('KEY')
               CALL SYMHT(TWD/TWIDTH)
               TWIDTH = TWD
               CALL OFF2(XPOS-TWIDTH/2,YPOS)
               CALL SYMTXT('KEY')
               XPOS = 0.85
               YPOS = 0.9
               CALL SYMHT(0.02)
               DO 2823 I=1,NKEYS
                  CALL RGB1(KEYRED(I),KEYGRN(I),KEYBLU(I))
                  CALL LINSF1(KEYWID(I))
                  CALL SETSTY(KEYSTY(I))
                  XPOS = 0.85
                  CALL OFF2(XPOS,YPOS)
                  XPOS = 0.97
                  CALL ON2(XPOS,YPOS)
                  CALL DSHOFF
                  XPOS = 0.85
                  YPOS = YPOS - 0.02
                  CALL OFF2(XPOS,YPOS)
                  CALL SYMTXT(KEYTEXT(I)(1:LNBC(KEYTEXT(I),1,1)))
                  YPOS = YPOS - 0.03
 2823          CONTINUE
               CALL RGB1(REDGEN,GRNGEN,BLUGEN)
               CALL DSHOFF
               CALL OPANE
               CALL ENPANE
               LPANE = .FALSE.
               NKEYS = 0
            ENDIF
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C RESET
C NOTE: WE CANNOT COME BACK HERE. JUMPING IN TO AN IF BLOCK IS
C       ILLEGAL. BUT WE DO NOT WANT TO DUPLICATE ALL THE VARIABLE
C       INITIALISATIONS HERE, SO ACCEPT A BIT OF MESSINESS.
 283     CONTINUE
         DORESET = .TRUE.
         IF( LPANE )CALL ENPANE
         GOTO 2831
C
C BOXPSIZE W H
 284     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         WTXBOX = F1
         HTXBOX = F2
         GOTO 299
C
C BOXPHATCH SPACING IANGLE MODE
 285     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. IFROMC(ARGS(2),INT1,1,LNBC(ARGS(2),1,1)) )GOTO 9093
         I = LOOKUP(HBHNAM,NHBH,ARGS(3),LOWEROK,.TRUE.)
         IF( I .LE. 0 )THEN
            ILKUPE = I
            CLKUPE = 'BOXTEXT HATCH MODE'
            GOTO 9100
         ELSE
            IHTXBOX = I
         ENDIF
         DHTXBOX = F1
         IATXBOX = INT1
         GOTO 299
C
C BOXPTEXT WIDTHFRAC MODE
 286     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         I = LOOKUP(HBTNAM,NHBT,ARGS(2),LOWEROK,.TRUE.)
         IF( I .LE. 0 )THEN
            ILKUPE = I
            CLKUPE = 'BOXTEXT TEXT MODE'
            GOTO 9100
         ELSE
            ITTXBOX = I
         ENDIF
         WFTXBOX = F1
         GOTO 299
C
C BOXPBOX MODE
 287     CONTINUE
         I = LOOKUP(HBBNAM,NHBB,ARGS(1),LOWEROK,.TRUE.)
         IF( I .LE. 0 )THEN
            ILKUPE = I
            CLKUPE = 'BOXTEXT BOX MODE'
            GOTO 9100
         ELSE
            IBTXBOX = I
         ENDIF
         GOTO 299
C
C LINE
 288     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL DECLINE(ARGS(1)(1:LNBC(ARGS(1),1,1)),
     +        IARTYPE, ARSIZE, ARSHARP, ARBARB, ANSKPSL, ANSCALE,
     +        FSYMHT )
         GCHANGE = .TRUE.
         GOTO 299
C
C GLABEL
C ALABEL
 289     CONTINUE
 290     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098         
         CALL GLABEL(F1, F2, F3, F4, ARGS(5)(1:LNBC(ARGS(5),1,1)),
     +        FSYMHT, (ICMD .EQ. KALABEL),
     +        IARTYPE, ARSIZE, ARSHARP, ARBARB, ANSKPSL, ANSCALE )
         GCHANGE = .TRUE.
         GOTO 299
C
C ARROWPARM
 291     CONTINUE
         I = LOOKUP(ARTNAM,NART,ARGS(1),LOWEROK,.TRUE.)
         IF( I .LE. 0 )THEN
            ILKUPE = I
            CLKUPE = 'ARROW TYPE'
            GOTO 9100
         ELSE
            IARTYPE = I - 1
         ENDIF
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F2 .LT. 0 )THEN
            ARSIZE = 0.7 * FSYMHT
         ELSE
            ARSIZE = F2
         ENDIF
         ARSHARP = F3
         ARBARB = F4
         GOTO 299
C
C LINEPARM
 292     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         ANSKPSL = F1
         ANSCALE = F2
         GOTO 299
C
C WAIT
 293     CONTINUE
         CALL DEVWAIT(IDEV,NDEVS)
         GOTO 299
C
C USE INTEGERS FOR GRAPH AXIS VALUES IF POSSIBLE.
 294     CONTINUE
         IARG = LOOKUP(GRDNAM,NGRD,ARGS(1),LOWEROK,.TRUE.)
         IF( IARG .LE. 0 )THEN
            ILKUPE = IARG
            CLKUPE = 'AXIS VALUE INT MODE'
            GOTO 9100
         ELSE
            IAXINT = IARG
         ENDIF
         GOTO 299
C
C PUT VERSION INFORMATION IN STRING REGISTER 9.
 295     CONTINUE
         CALL GETVRI(STRINGS(NREGS))
         STRILEN(NREGS) = LNBC(STRINGS(NREGS),1,0)
         GOTO 299
C
C END OF COMMAND SWITCH
C IF THE GRAPHICS DISPLAY HAS BEEN CHANGED, TRY TO ENSURE THE
C CHANGES ARE MADE VISIBLE - BUT ONLY IF AT INTERACTIVE LEVEL.
 299     CONTINUE
         IF( GCHANGE .AND. IDEP .EQ. 0 )THEN
            IF(HAVDEV)CALL MAKEVIS(IDEV,NDEVS)
            GCHANGE = .FALSE.
         ENDIF
      ENDIF
C
C READ NEXT COMMAND
C
      GOTO 1
C
C HANDLE DEVICE NOT OPENED PROBLEM.
C
 9090 CONTINUE
      WRITE(6,9091)
 9091 FORMAT(1X,'DEVICE MUST BE OPEN FOR THIS COMMAND.')
      GOTO 1
C
C HANDLE INVALID INTEGER NUMBER.
C
 9093 CONTINUE
      CALL TXBEGIN
      WRITE(6,9094)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 9094 FORMAT(1X,'INVALID INTEGER NUMBER LITERAL FOR ',A,' COMMAND.')
      CALL TXEND
      GOTO 1
C
C HANDLE NO DATA TO PLOT PROBLEM.
C
 9095 CONTINUE
      CALL TXBEGIN
      WRITE(6,9096)
 9096 FORMAT(1X,'NO DATA READ TO PLOT. USE READ.')
      CALL TXEND
      GOTO 1
C
C HANDLE INVALID REAL NUMBER.
C
 9098 CONTINUE
      CALL TXBEGIN
      WRITE(6,9099)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 9099 FORMAT(1X,'INVALID REAL NUMBER LITERAL FOR ',A,' COMMAND.')
      CALL TXEND
      GOTO 1
C
C HANDLE INVALID OPTION STRINGS.
C
 9100 CONTINUE
      CALL TXBEGIN
      IF( ILKUPE .EQ. 0 )THEN
         WRITE(6,9101)CLKUPE(1:LNBC(CLKUPE,1,1))
 9101    FORMAT(1X,'UNKNOWN ',A,'. TRY HELP.')
      ELSE IF( ILKUPE .LT. 0 )THEN
         WRITE(6,9102)CLKUPE(1:LNBC(CLKUPE,1,1))
 9102    FORMAT(1X,'AMBIGUOUS ',A,'. TRY HELP.')
      ENDIF
      CALL TXEND
      GOTO 1
C
C TERMINATE. FLUSH. CLOSE. FREE DYNAMIC STORE (NOT REALLY NECESSARY).
C TRY TO PREVENT AN EMPTY LINE ACCIDENTALLY TERMINATING GPLOT.
C BUT ONLY IF INTERACTIVE (ORIGIN TYPE = 3).
C
   2  CONTINUE
      IF( (EOF(7) .NE. 0) .AND. (IGETOT() .EQ. 3) )GOTO 1
      IF( HAVDEV )THEN
         CALL GFLUSH(IDEV,NDEVS,.FALSE.)
         CALL MAKEVIS(IDEV,NDEVS)
         CALL DIMEND
      ENDIF
      CALL CMMFRF(IFWA)
      STOP 'GPLOT FINISHED.'
C
C READ ERROR HANDLER
C
 998  CONTINUE
      STOP 'ERROR READING INPUT.'
      END
C
      SUBROUTINE DOHELP(CMDS,NCMDS,DCMDS,DEVNAM,NDEVS,DDEVS,
     +     INCMDS,WHAT,LOWEROK)
C ----------------------------------------------------------
C OUTPUT HELP. NOTE: THIS IS CALLED FROM A TXBEGIN/TXEND REGION.
C ----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NCMDS, NDEVS
      CHARACTER*(*) CMDS(NCMDS)
      CHARACTER*(*) DCMDS(NCMDS)
      CHARACTER*(*) DEVNAM(NDEVS)
      CHARACTER*(*) DDEVS(NDEVS)
      INTEGER INCMDS(NCMDS)
      CHARACTER*(*) WHAT
C
      INTEGER I, LWHAT, ICMD, J, LENC, ISTEP, ILIMIT
      INTEGER LNBC, LOOKUP
      CHARACTER*80 OLIST
C
C OUTPUT A BLANK LINE TO IMPROVE TEK401X BEHAVIOUR.
      WRITE(6,110)
C
C SORT THE COMMAND NAMES.
      CALL SORTIDX(CMDS, NCMDS, INCMDS )
C
C DECIDE WHAT TO OUTPUT.
      CALL UPCASE(WHAT)
      LWHAT = LNBC(WHAT,1,0)
      IF( (LWHAT .EQ. 0) .OR. (WHAT(1:LWHAT) .EQ. 'LIST') )THEN
C
C LIST ALL DEFINED COMMANDS.
         ISTEP = 16
         ILIMIT = 80
         WRITE(6,101)
 101     FORMAT(1X,'COMMANDS:')
         OLIST = ' '
         J = 1
         DO 1 I=1,NCMDS
            LENC = LNBC(CMDS(INCMDS(I)),1,1)
            OLIST(J:J+LENC) = CMDS(INCMDS(I))(1:LENC)
            J = J + ISTEP
            IF( J .GT. ILIMIT )THEN
               WRITE(6,108)OLIST
               OLIST = ' '
               J = 1
            ENDIF
 1       CONTINUE
         IF( J .GT. 1 )WRITE(6,108)OLIST
      ELSE IF( WHAT(1:LWHAT) .EQ. 'DEVICES' )THEN
C
C LIST AVAILABLE DEVICES.
         WRITE(6,104)
 104     FORMAT(3X,'AVAILABLE DEVICES:')
         DO 2 I=1,NDEVS
            WRITE(6,105)DEVNAM(I)
 105        FORMAT(5X,A)
            WRITE(6,106)DDEVS(I)
 106        FORMAT(7X,A)
 2       CONTINUE
      ELSE
C
C GIVE HELP ON A SPECIFIC COMMAND.
         ICMD = LOOKUP(CMDS,NCMDS,WHAT,LOWEROK,.TRUE.)
         IF(ICMD .EQ. 0 )THEN
            WRITE(6,102)WHAT(1:LNBC(WHAT,1,1))
 102        FORMAT(1X,'UNKNOWN COMMAND NAME: ',A)
         ELSE IF( ICMD .LT. 0 )THEN
            WRITE(6,103)WHAT(1:LNBC(WHAT,1,1))
 103        FORMAT(1X,'AMBIGUOUS COMMAND NAME: ',A)
         ELSE
            WRITE(6,108)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 108        FORMAT(1X,A)
            WRITE(6,109)DCMDS(ICMD)(1:LNBC(DCMDS(ICMD),1,1))
 109        FORMAT(3X,A)
         ENDIF
      ENDIF
C
      WRITE(6,110)
 110  FORMAT(1X)
      RETURN
      END
C
      SUBROUTINE DOOBEY(FNAME,INUNIT,ISTAT,PATHNAM,FULLNAM)
C ----------------------------------------------
C OPEN AN OBEY FILE AND PREPARE TO READ FROM IT.
C ----------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*)FNAME, PATHNAM, FULLNAM
      INTEGER INUNIT, ISTAT, IFNE
      INTEGER MAXFNL
#ifdef PORTF77
      PARAMETER( MAXFNL=72 )
#else
      PARAMETER( MAXFNL=7 )
#endif
C
      CALL MKFULNM(FNAME,PATHNAM,FULLNAM,MAXFNL,IFNE)
      OPEN(UNIT=INUNIT+1,FILE=FULLNAM(1:IFNE),STATUS='OLD',ERR=2221)
      INUNIT = INUNIT + 1
      REWIND(UNIT=INUNIT)
      ISTAT = 1
      RETURN
 2221 CONTINUE
      CALL TXBEGIN
      WRITE(6,2222)FNAME(1:IFNE)
 2222 FORMAT(1X,'CANNOT OPEN OBEY INPUT FILE ',A)
      CALL TXEND
      ISTAT = 0
      RETURN
      END
C
      SUBROUTINE MEMTEST(N,X,Y,A,B)
C--------------------------------------
C TEST THAT DYNAMIC MEMORY IS WORKING.
C GENERATE TEST DATA.
C--------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL A(N), B(N), X(N), Y(N)
C
      INTEGER I, IX, IY, IA, IB
C
      DO 1 I=1,N
         X(I) = I
         Y(I) = I + 2 * N
         A(I) = I + 3 * N
         B(I) = I + 4 * N
  1   CONTINUE
      IX = N
      IY = 3 * N
      IA = 4 * N
      IB = 5 * N
      CALL TXBEGIN
      WRITE(6,*)'... GOT ',X(N),Y(N),A(N),B(N)
      WRITE(6,*)'... EXPECTED ',IX,IY,IA,IB
      IF((X(N).EQ.IX).AND.(Y(N).EQ.IY).AND.(A(N).EQ.IA).AND.
     +   (B(N).EQ.IB) )THEN
         WRITE(6,*)'OK - DYNAMIC ALLOCATION TEST PASSED.'
         DO 2 I=1,N
            X(I) = 3.0 * 6.283 * FLOAT(I)/N
            Y(I) = SIN(X(I))
  2      CONTINUE
         WRITE(6,*)'GENERATED TEST DATA.'
      ELSE
         WRITE(6,*)'ERROR - DYNAMIC ALLOCATION TEST FAILED.'
      ENDIF
      CALL TXEND
      RETURN
      END
C
      SUBROUTINE DOREAD(FNAME,COL1,COL2,X,Y,NP,NOUT,ISTAT,IUN,
     +                  COL3,COL4,YE,XE,NARG,PATHNAM,FULLNAM)
C--------------------------------------------------------------
C READ X,Y DATA FROM FILE FNAME USING COLUMNS COL1, COL2.
C RETURN NUMBER OF DATA POINTS READ IN NOUT. MAX NP.
C IF FNAME=HERE, READ FROM IUN UNTIL LINE STARTING EOF FOUND.
C IF COL1=0, USE THE NUMBER OF PTS SO FAR, NOT READ COLUMN.
C--------------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) FNAME, COL1, COL2, COL3, COL4, PATHNAM, FULLNAM
      INTEGER NP, NOUT, ISTAT, IUN, NARG
      REAL X(NP), Y(NP), YE(NP), XE(NP)
C
      LOGICAL IFROMC, RFROMC
      LOGICAL LHERE, DEVTEK
      CHARACTER*80 LINE
      REAL FVAL
      INTEGER IS, IE, ICOL1, ICOL2, INUN, IFNE, ICOL3, ICOL4, IECOL
      INTEGER ILNBC, ILINE, NEWPOS
      INTEGER LNBC
      INTEGER MAXFNL
#ifdef PORTF77
      PARAMETER( MAXFNL=72 )
#else
      PARAMETER( MAXFNL=7 )
#endif      
C
C PARSE THE COLUMN NUMBER ARGUMENTS.
C
      IF( .NOT. IFROMC(COL1,ICOL1,1,NEWPOS) )GOTO 26
      IF( .NOT. IFROMC(COL2,ICOL2,1,NEWPOS) )GOTO 26
      IF( ICOL1 .LT. 0 )GOTO 25
      IF( ICOL2 .LE. 0 )GOTO 25
      IF( NARG .GE. 4 )THEN
         IF( .NOT. IFROMC(COL3,ICOL3,1,NEWPOS) )GOTO 26
         IF( ICOL3 .LE. 0 )GOTO 25
      ENDIF
      IF( NARG .EQ. 5 )THEN
         IF( .NOT. IFROMC(COL4,ICOL4,1,NEWPOS) )GOTO 26
         IF( ICOL4 .LE. 0 )GOTO 25
      ENDIF
C
C OPEN THE DATA FILE.
C
      IFNE = LNBC(FNAME,1,1)
      IF( IFNE .GT. MAXFNL )IFNE = MAXFNL
      IF( FNAME(1:IFNE) .EQ. 'HERE' )THEN
         LHERE = .TRUE.
         INUN = IUN
      ELSE
         LHERE = .FALSE.
         INUN = 4
         CALL MKFULNM(FNAME,PATHNAM,FULLNAM,MAXFNL,IFNE)
         OPEN(UNIT=INUN,FILE=FULLNAM(1:IFNE),STATUS='OLD',ERR=9)
         REWIND(UNIT=INUN)
      ENDIF
C
C READ THE FILE LINE BY LINE.
C
      NOUT = 0
      ILINE = 0
      ISTAT = 1
 900  CONTINUE
      IF( NOUT .GE. NP )GOTO 19
      READ(INUN,102,ERR=7,END=28)LINE
 102  FORMAT(A)
      ILINE = ILINE + 1
C
C IGNORE BLANK LINES AND LINES BEGINNING WITH C IN COLUMN 1
C
      ILNBC = LNBC(LINE,1,0)
      IF( ILNBC .EQ. 0 )GOTO 900
      IF( LINE(1:1) .EQ. 'C' )GOTO 900
C
C IF IN "HERE" MODE, STOP READING IF LINE BEGINS "EOF"
C
      IF( LHERE .AND. ILNBC .EQ. 3 )THEN
         IF( LINE(1:3) .EQ. 'EOF' )GOTO 28
      ENDIF
C
C CONVERT COMMAS TO SPACES
C
      CALL DECOMMA(LINE)
C
C PARSE THE LINE FOR TWO/THREE/FOUR SPACE SEPARATED REAL NUMBERS
C
      IS = 1
      IF( ICOL1 .EQ. 0 )THEN
         FVAL = NOUT
      ELSE
         IECOL = ICOL1
         CALL GETSCOL(LINE,ICOL1,IS)
         IF( IS .EQ. 0 )GOTO 66
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
      ENDIF
      X(NOUT+1) = FVAL
      IS = 1
      IECOL = ICOL2
      CALL GETSCOL(LINE,ICOL2,IS)
      IF( IS .EQ. 0 )GOTO 66
      IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
      Y(NOUT+1) = FVAL
      IF( NARG .GE. 4 )THEN
         IS = 1
         IECOL = ICOL3
         CALL GETSCOL(LINE,ICOL3,IS)
         IF( IS .EQ. 0 )GOTO 66
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
         YE(NOUT+1) = FVAL
      ENDIF
      IF( NARG .EQ. 5 )THEN
         IS = 1
         IECOL = ICOL4
         CALL GETSCOL(LINE,ICOL4,IS)
         IF( IS .EQ. 0 )GOTO 66
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
         XE(NOUT+1) = FVAL
      ENDIF
      NOUT = NOUT + 1
      GOTO 900
C
C FILE READ SUCCESSFULLY.
C
 28   CONTINUE
      CALL ISTEK4K(DEVTEK)
      IF( .NOT. DEVTEK )THEN
         CALL TXBEGIN
         WRITE(6,198)ILINE, NOUT
 198     FORMAT(1X,'OK END OF FILE. LINES=',I5,' POINTS=',I5)
         CALL TXEND
      ENDIF
C
C CLOSE THE INPUT FILE. RETURN ISTAT. MAYBE AFTER ERROR.
C
  29  CONTINUE
      IF(.NOT. LHERE)CLOSE(UNIT=INUN)
      RETURN
C
C LINE PARSE ERROR.
C
 6    CONTINUE
      CALL TXBEGIN
      WRITE(6,110)ILINE
 110  FORMAT(1X,'CANNOT PARSE X,Y [YE [XE]] FROM LINE: ',I5)
      CALL TXEND
      ISTAT = 0
      GOTO 29
C
C COLUMN NOT FOUND ERROR.
C
 66   CONTINUE
      CALL TXBEGIN
      WRITE(6,116)IECOL, ILINE
 116  FORMAT(1X,'CANNOT FIND COLUMN: ',I5,' IN LINE: ',I5)
      CALL TXEND
      ISTAT = 0
      GOTO 29
C
C FILE READ ERROR.
C
  7   CONTINUE
      CALL TXBEGIN
      WRITE(6,111)ILINE
 111  FORMAT(1X,'FILE READ ERROR AT LINE: ',I5)
      CALL TXEND
      ISTAT = 0
      GOTO 29
C
C TOO MANY DATA POINTS.
C
 19   CONTINUE
      CALL TXBEGIN
      WRITE(6,112)NOUT,ILINE
 112  FORMAT(1X,'TOO MANY DATA POINTS ',I5,' AT LINE ',I5)
      CALL TXEND
      ISTAT = 0
      GOTO 29
C
C COLUMN NUMBER PARSE ERROR.
C
 26   CONTINUE
      CALL TXBEGIN
      WRITE(6,126)
 126  FORMAT(1X,'CANNOT PARSE COLUMN SPECIFIERS.')
      CALL TXEND
      ISTAT = 0
      GOTO 29
C
C ILLEGAL NEGATIVE COLUMN NUMBER
C
 25   CONTINUE
      CALL TXBEGIN
      WRITE(6,125)
 125  FORMAT(1X,'ILLEGAL NEGATIVE OR NON X ZERO COLUMN NUMBER.')
      CALL TXEND
      ISTAT = 0
      GOTO 29
C
C CANNOT OPEN INPUT FILE.
C
 9    CONTINUE
      CALL TXBEGIN
      WRITE(6,100)FNAME(1:IFNE)
 100  FORMAT(1X,'CANNOT OPEN DATA FILE: ',A)
      CALL TXEND
      ISTAT = 0
      RETURN
      END
C
      SUBROUTINE GETSCOL(LINE,IWCOL,IS)
C---------------------------------------------------------
C FIND THE CHARACTER IS IN LINE AT WHICH COLUMN IWCOL STARTS
C "COLUMNS" ARE SPACE DELIMITED CHARACTER STRINGS OR
C SINGLE QUOTE ' PAIR DELIMITED TO ALLOW EMBEDDED SPACES.
C---------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) LINE
      INTEGER IWCOL, IS
C
      LOGICAL QUOTED
      INTEGER ICOL
      INTEGER NOCC, NBC, NNBC
C
C NO COLUMN FOUND YET. LOOK FOR THE FIRST (NEXT) COLUMN.
      ICOL = 0
  1   CONTINUE
C FIND NEXT NON BLANK. IF NONE, THERE IS NO NEXT COLUMN.
      IS = NNBC(LINE,IS,0)
      IF( IS .EQ. 0 )RETURN
C IF THE NON-BLANK IS A SINGLE QUOTE, USE THAT AS THE COLUMN
C TERMINATOR INSTEAD OF SPACE.
      QUOTED = ( LINE(IS:IS) .EQ. '''' )
C INC COLUMN NUMBER. IF THAT IS THE WANTED ONE, RETURN IS.
      ICOL = ICOL + 1
      IF( ICOL .EQ. IWCOL )RETURN
C SKIP TO THE ENDING QUOTE IF QUOTED.
      IF( QUOTED )THEN
         IS = NOCC(LINE,'''',IS+1,0)
         IF( IS .EQ. 0 )THEN
            CALL TXBEGIN
            WRITE(6,100)ICOL
 100        FORMAT(1X,'WARN: MISMATCHED QUOTE AT COL=',I3)
            CALL TXEND
         ENDIF
      ENDIF
C FIND NEXT BLANK. OR SINGLE QUOTE. IF NONE, THERE IS NO NEXT COLUMN.
      IS = NBC(LINE,IS,0)
      IF( IS .EQ. 0 )RETURN
C LOOP TO FIND NEXT COLUMN START.
      GOTO 1
      END
C
      SUBROUTINE DECOMMA(LINE)
C----------------------------------------------------
C CONVERT COMMAS TO SPACES TO DEAL WITH CSV DATA.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*)LINE
C
      INTEGER I
C
      DO 1 I=1,LEN(LINE)
         IF( LINE(I:I) .EQ. ',' )LINE(I:I) = ' '
  1   CONTINUE
      RETURN
      END
C
      SUBROUTINE QUOTS2D( ARGSTR )
C----------------------------------------------------
C CONVERT SINGLE QUOTES TO DOUBLE QUOTES.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) ARGSTR
C
      INTEGER I
C
      DO 1 I=1,LEN(ARGSTR)
         IF(ARGSTR(I:I) .EQ. '''' )ARGSTR(I:I) = '"'
  1   CONTINUE
      RETURN
      END
C
      SUBROUTINE SQSTRIP( ARGSTR )
C----------------------------------------------------
C REMOVE ALL SINGLE QUOTES IN ARGSTR.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) ARGSTR
C
      CHARACTER*80 TARG
      INTEGER I, J
C
      J = 1
      DO 1 I=1,LEN(ARGSTR)
         IF( ARGSTR(I:I) .NE. '''' )THEN
            TARG(J:J) = ARGSTR(I:I)
            J = J + 1
         ENDIF
  1   CONTINUE
      DO 2 I=J,LEN(ARGSTR)
         TARG(I:I) = ' '
  2   CONTINUE
      ARGSTR = TARG
      RETURN
      END
C
      SUBROUTINE GOGRAF( IDEV, NDEV )
C----------------------------------------------------
C ENSURE DEVICE IDEV IS IN "GRAPHICS MODE" IF NEEDED.
C TEK4K DOES NEED THIS. GTERM ALSO.
C THIS MAY NEED TO BE CALLED AFTER ANY NON-GRAPHICS
C TEXT HAS BEEN SENT TO THE DEVICE TO GET IT BACK IN TO
C GRAPHICS MODE.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO GOGRAF UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
      CALL TEKGRAF
      CALL TEKCLR
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE GFLUSH( IDEV, NDEV, LTEXT )
C----------------------------------------------------
C FLUSH THE OUTPUT, MAYBE GO TO TEXT MODE (IF MEANINGFUL).
C NOTE THAT THIS SENDS ANY QUEUED OUTPUT TO THE DEVICE,
C BUT IT DOES NOT NECESSARILY MAKE THE DEVICE DRAW.
C WITH INTERACTIVE DEVICES ON A TERMINAL LINE, THIS MUST
C BE CALLED BEFORE ANY NON GRAPHICS IS SENT TO THE TERMINAL
C TO PREVENT THAT TEXT BEING MIXED UP WITH PARTIAL GRAPHICS
C COMMANDS.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
      LOGICAL LTEXT
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO GFLUSH UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
      CALL A12FLS
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
      CALL A12FLS
      IF( LTEXT )THEN
         CALL TEKGRAF
         CALL TEKDRAW(3,747,0)
         CALL TEKTEXT
         CALL A12FLS
      ENDIF
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE MAKEVIS( IDEV, NDEV )
C-------------------------------------------
C MAKE THE DEVICE SHOW ALL GRAPHICS IT HAS RECEIVED NOW.
C GTERM NEEDS THIS.
C-------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO MAKEVIS UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
      CALL GTFLUSH
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
      CALL A12FLS
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE DEVFILL( IDEV, NDEV, RED, GRN, BLU )
C----------------------------------------------------
C MAKE THE DEVICE FILL THE DRAWING AREA WITH THE CURRENT COLOUR.
C ONLY GTERM CAN DO THIS AT THE MOMENT.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
      REAL RED, GRN, BLU
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO DEVFILL UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
      CALL GTCOL(RED,GRN,BLU)
      CALL GTFILL
      CALL GTFLUSH
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE DEVWAIT( IDEV, NDEV )
C----------------------------------------------------
C IF A DEVICE IS "INTERACTIVE", WAIT FOR A RESPONSE FROM THE
C USER BEFORE CONTINUING.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO DEVWAIT UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
      CALL GTWAIT
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
      CALL TEKWAIT
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE      
      RETURN
      END
C
      SUBROUTINE TXSETUP( IDEVU, NDEVU )
C----------------------------------------
C PROVIDE A COMPACT METHOD OF SWITCHING TO AND FROM TEXT MODE.
C TXBEGIN() SHOULD BE CALLED BEFORE OUTPUTTING TEXT.
C TXEND() OR TXENDGR() SHOULD BE CALLED AFTER OUTPUTTING TEXT.
C THIS IS IMPORTANT MOSTLY FOR THE TEK 401X DEVICE.
C
C BEFORE A COMMAND IS READ, DEVICES ARE SWITCHED TO "TEXT MODE".
C AFTER A COMMAND IS READ, DEVICES ARE SWITCHED BACK TO "GRAPHICS MODE".
C BEFORE TEXT IS OUTPUT (USUALLY AN ERROR MESSAGE WHILE EXECUTING
C A COMMAND, OR TEXT FROM HELP OR STATUS) THE DEVICE IS SWITCHED BACK
C TO "TEXT MODE" HERE (AND SOME "PADDING" IS OUTPUT FOR TEK4K TO TRY
C TO REDUCE OUTPUT TRAMPLING ON EXISTING OUTPUT).
C USUALLY, AFTER AN ERROR MESSAGE IS OUTPUT, CONTROL RETURNS TO THE
C TOP OF THE COMMAND LOOP (WHICH GOES BACK TO "GRAPHICS MODE" BEFORE
C ANOTHER COMMAND IS EXECUTED). USE TXEND() - WHICH DOES NOTHING NOW.
C IN A FEW CASES, A MESSAGE IS OUTPUT *AND* A GRAPHICS OUTPUTTING
C COMMAND IS EXECUTED. IN THIS CASE, USE TXENDGR() TO GO BACK
C TO "GRAPHICS MODE" BEFORE EXECUTING THE REST OF THE COMMAND.
C----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEVU, NDEVU
C
C SETUP. THIS CAN ONLY BE CALLED ONCE, WHEN A DEVICE IS CHOSEN.
      LOGICAL YES
      INTEGER IDEV, NDEV
      SAVE IDEV, NDEV
      DATA IDEV/-1/, NDEV/0/
C
      IDEV = IDEVU
      NDEV = NDEVU
      RETURN
C
C BEGIN TEXT MODE, IF POSSIBLE.
      ENTRY TXBEGIN
      IF( IDEV .LE. 0 )RETURN
      CALL GFLUSH(IDEV, NDEV, .TRUE.)
      IF( IDEV .EQ. 2 )WRITE(6,*)' '
      RETURN
C
C END TEXT MODE, IF POSSIBLE.
      ENTRY TXEND
      IF( IDEV .LE. 0 )RETURN
C DO NOTHING AT PRESENT. GOGRAF WILL ERASE
C TEK 401X WHICH WE DO NOT WANT HERE.
C      CALL GOGRAF(IDEV, NDEV)
      RETURN
C
C END TEXT MODE, GO GRAPHICAL.
      ENTRY TXENDGR
      IF( IDEV .LE. 0 )RETURN
      IF( IDEV .EQ. 2 )THEN
         CALL TEKWAIT
         CALL GOGRAF(IDEV, NDEV)
      ENDIF
      RETURN      
C
C CHECK IF TEK 401X OR NOT.
      ENTRY ISTEK4K(YES)
      YES = (IDEV .EQ. 2)
      RETURN
C
C END A DISPLAY PAGE FOR A TEK401X DEVICE.
      ENTRY TXPAGE
      IF( IDEV .EQ. 2 )THEN
         CALL TEKWAIT
         WRITE(6,*)' '
         WRITE(6,*)' '
      ENDIF
      RETURN
      END
C
      SUBROUTINE PARSUB(SUBSTR,ARGSTR,NCARG,IERR)
C----------------------------------------
C SUBSTITUTE FORMAL ARGUMENT VARIABLES IN ARGSTR WITH ACTUAL ARGS
C IN SUBSTR. IF ARGSTR CONTAINS $N THEN THAT IS SUBSTITUTED WITH
C THE NTH SPACE SEPARATED ITEM IN SUBSTR.
C ACTUAL ARGS IN SUBSTR MAY BE ENCLOSED IN SINGLE QUOTES TO ALLOW
C THEM TO CONTAIN SPACES.
C THE RESULT IS TRUNCATED AT THE SIZE OF ARGSTR REGARDLESS.
C IERR IS RETURNED WITH 0 IF THERE ARE NO ERRORS. IT IS AN ERROR
C TO NOT SUPPLY ENOUGH ARGUMENTS SO THAT SOME $N SUBSTITUTION FAILS.
C----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) SUBSTR, ARGSTR
      INTEGER NCARG, IERR
C
      INTEGER LARGSTR, LSUBSTR
      CHARACTER*80 SBUF
      CHARACTER*9 ARGDIG
      CHARACTER*1 TRMCHR
      LOGICAL ADDCHR
      INTEGER I, J, K, IS, IARG
C
      IERR = 0
      SBUF = ' '
      ARGDIG = '123456789'
      LARGSTR = LEN(ARGSTR)
      LSUBSTR = LEN(SUBSTR)
      J = 1
      I = 1
C---- PROCESS ALL CHARACTERS IN ARGSTR.
C---- THIS USES AN "OPEN CODED" DO-LOOP ON I AS I MAY NEED TO
C---- BE CONDITIONALLY INCREMENTED. I IS THE INDEX IN ARGSTR.
 1    CONTINUE
      IF( I .GT. NCARG )GOTO 2
C---- LOOK FOR $ AS A PARAMETER INDICATOR.
         IF( ARGSTR(I:I) .EQ. '$' )THEN
            IF( I .LT. NCARG )THEN
C---- IF NEXT CHAR IS DIGIT, DECODE AS A PARAMETER NUMBER.
               IARG = INDEX(ARGDIG,ARGSTR(I+1:I+1))
               IF( IARG .GT. 0 )THEN
C---- SKIP THE DIGIT SO WE DO NOT COPY IT.
                  I = I + 1
C---- FIND WHERE THE IARG'TH WORD STARTS IN SUBSTR
                  IS = 1
                  CALL GETSCOL(SUBSTR,IARG,IS)
C---- IF THERE WAS SUCH A WORD, SUBSTITUTE IT IN PLACE OF $N
                  IF( IS .GT. 0 )THEN
C---- IF THE WORD STARTS WITH ' IT SHOULD END WITH ' NOT SPACE.
C---- RETAIN THE ' AT THIS POINT, HOWEVER.
                     IF( SUBSTR(IS:IS) .EQ. '''' )THEN
                        TRMCHR = ''''
                        IF( ADDCHR(SUBSTR(IS:IS),SBUF,J,80) )GOTO 2
                        IS = IS + 1
                     ELSE
                        TRMCHR = ' '
                     ENDIF
C---- COPY THE WORD TO THE END OF SBUF. K IS THE SUBSTR INPUT
C---- POSITION (INDEX), J IS THE SBUF OUTPUT POSITION.
                     DO 3 K=IS,LSUBSTR
                        IF( SUBSTR(K:K) .EQ. TRMCHR )THEN
                           IF( TRMCHR .EQ. ' ' )GOTO 4
                           IF(ADDCHR(SUBSTR(K:K),SBUF,J,80))GOTO 2
                           GOTO 4
                        ENDIF
                        IF(ADDCHR(SUBSTR(K:K),SBUF,J,80))GOTO 2
  3                  CONTINUE
  4                  CONTINUE
C---- INSERT A SPACE AFTER THE SUBSTITUTION.
                     IF(ADDCHR(' ',SBUF,J,80))GOTO 2
                  ELSE
                     CALL TXBEGIN
                     WRITE(6,100)IARG
 100  FORMAT(1X,'REQUIRED OBEY FILE ARGUMENT ',I2,' MISSING.')
                     CALL TXEND
                     IERR = 1
                     RETURN
                  ENDIF
               ELSE
C---- DOLLAR NOT FOLLOWED BY A DIGIT. INSERT DOLLAR.
                  IF(ADDCHR(ARGSTR(I:I),SBUF,J,80))GOTO 2
               ENDIF
            ELSE
C---- DOLLAR AT END OF STRING. INSERT DOLLAR.
               IF(ADDCHR(ARGSTR(I:I),SBUF,J,80))GOTO 2
            ENDIF
C---- IF CHAR IN ARGSTR IS NOT $, COPY IT TO THE RESULT.
         ELSE
            IF(ADDCHR(ARGSTR(I:I),SBUF,J,80))GOTO 2
         ENDIF
         I = I + 1
      GOTO 1
  2   CONTINUE
C---- COPY THE FINAL SUBSTITUTED RESULT BACK TO ARGSTR, TRUNCATING.
      DO 9 I=1,LARGSTR
         ARGSTR(I:I) = SBUF(I:I)
  9   CONTINUE
      RETURN
      END
C
      SUBROUTINE ADDSTR( RESULT, PART, LPRESPC, LENCQT )
C-------------------------------------------------------
C ADD STRING PART TO THE END OF RESULT.
C IF LPRESPC, INSERT A SPACE BEFORE THE NEW COMPONENT.
C IF LENCQT, ENCLOSE THE NEW COMPONENT IN DOUBLE QUOTES.
C-------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) RESULT, PART
      LOGICAL LPRESPC, LENCQT
C
      LOGICAL ADDCHR
      INTEGER LNBC
      INTEGER ILRESL, IERESL, IEPART, IR, I
C
      ILRESL = LEN(RESULT)
      IERESL = LNBC(RESULT,1,1)
      IEPART = LNBC(PART,1,0)
      IF( IEPART .EQ. 0 )RETURN
      IR = IERESL + 1
      IF( LPRESPC )THEN
         IF( ADDCHR( ' ', RESULT, IR, ILRESL ) )RETURN
      ENDIF
      IF( LENCQT )THEN
         IF( ADDCHR( '"', RESULT, IR, ILRESL ) )RETURN
      ENDIF
      DO 1 I=1,IEPART
         IF( ADDCHR( PART(I:I), RESULT, IR, ILRESL ) )RETURN
  1   CONTINUE
      IF( LENCQT )THEN
         IF( ADDCHR( '"', RESULT, IR, ILRESL ) )RETURN
      ENDIF
      RETURN
      END
C
      LOGICAL FUNCTION ADDCHR( INCHAR, OUTSTR, IOUT, OUTL )
C----------------------------------------------------------
C ADD CHARACTER INCHAR TO OUTSTR AT POSITION IOUT. BUMP IOUT.
C RETURN TRUE IF OUTSTR, LENGTH OUTL, IS ALREADY FULL.
C----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*1 INCHAR
      CHARACTER*(*) OUTSTR
      INTEGER IOUT, OUTL
C
      ADDCHR = .FALSE.
      IF( IOUT .GT. OUTL )THEN
         ADDCHR = .TRUE.
      ELSE
         OUTSTR(IOUT:IOUT) = INCHAR
         IOUT = IOUT + 1
      ENDIF
      RETURN
      END
C
      LOGICAL FUNCTION GETYN( STRING )
C----------------------------------------------------------
C RETURN .TRUE. IF STRING CONTAINS Y OR YES ELSE .FALSE.
C----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) STRING
C
      INTEGER ICMD
      INTEGER LOOKUP
      CHARACTER*3 OPTS(4)
C
      OPTS(1) = 'YES'
      OPTS(2) = 'NO'
      OPTS(3) = 'ON'
      OPTS(4) = 'OFF'
#ifdef PORTF77
      ICMD = LOOKUP(OPTS,4,STRING,.TRUE.,.TRUE.)
#else
      ICMD = LOOKUP(OPTS,4,STRING,.FALSE.,.TRUE.)
#endif
      GETYN = .FALSE.
      IF( ICMD .EQ. 0 )THEN
         CALL TXBEGIN
         WRITE(6,100)
 100     FORMAT(1X,'EXPECTED YES, NO, Y, N, ON, OFF' )
         CALL TXEND
      ELSE
         IF( ICMD .EQ. 1 .OR. ICMD .EQ. 3 )GETYN = .TRUE.
      ENDIF
      RETURN
      END
C
      SUBROUTINE REPACK(X,Y,YE,XE,NDATA)
C-----------------------------------------------------------
C REARRANGES DATA SO THAT IT CAN BE ACCESSED AS A 2D ARRAY
C BY GRAPHE AND PTPLTE FOR ERROR BARS. THIS IS NECESSARILY
C QUITE HACKISH. THE "A" AND "B" ARRAYS ARE ALLOCATED SO
C THEY IMMEDIATELY FOLLOW THE X AND Y ARRAYS SO THIS SHOULD
C WORK.
C-----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL X(1), Y(1), YE(1), XE(1)
      INTEGER NDATA
C
      INTEGER I
C
C MOVE XE SO IT ABUTTS THE END OF NDATA USED X DATA POINTS.
C LIKEWISE FOR YE AND Y.
C
      DO 1 I=1,NDATA
         X(I+NDATA) = XE(I)
         Y(I+NDATA) = YE(I)
 1    CONTINUE
      RETURN
      END
C
      SUBROUTINE AREPACK(X,Y,YED,YEU,NDATA)
C---------------------------------------------------------
C REARRANGE DATA FOR ASYMMETRIC Y ERROR BARS. IN THIS CASE,
C THE ORDER NEEDS TO CHANGE SO THAT:
C X -> X, Y -> "A", YED -> Y, YEU -> "B".
C YED IS THE "DOWN" PART OF THE ERROR BAR AND YEU THE "UP".
C----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL X(1), Y(1), YED(1), YEU(1)
      INTEGER NDATA
C
      INTEGER I
      REAL RTEMP
C
C FIRST, SWAP THE CONTENTS OF THE Y AND YED ("A") ARRAYS.
C YED = DA(IAOFF) WILL THEN CONTAIN Y AND Y = DA(IYOFF) YED.
C
      DO 1 I=1,NDATA
         RTEMP = Y(I)
         Y(I) = YED(I)
         YED(I) = RTEMP
  1   CONTINUE
C
C NOW, SQUISH THE ERROR BAR ARRAYS TOGETHER.
C
      DO 2 I=1,NDATA
         YED(I+NDATA) = Y(I)
         YED(I+2*NDATA) = YEU(I)
  2   CONTINUE
      RETURN
      END
C
      SUBROUTINE SHOW2D(X,Y,N,MX,MY)
C--------------------------------------------
C TEST REPACK HAS THE DESIRED EFFECT.
C--------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N, MX, MY
      REAL X(N,MX), Y(N,MY)
C
      INTEGER I, J
C
      CALL TXBEGIN
      DO 1 J=1,MX
         DO 2 I=1,N
            WRITE(6,*)'X(',I,',',J,')=',X(I,J)
  2      CONTINUE
  1   CONTINUE
      DO 3 J=1,MY
         DO 4 I=1,N
            WRITE(6,*)'Y(',I,',',J,')=',Y(I,J)
  4      CONTINUE
 3    CONTINUE
      CALL TXEND
      RETURN
      END
C
      SUBROUTINE SHOW1D(X,Y,N)
C--------------------------------------------
C DUMP X,Y DATA TO BE PLOTTED.
C--------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL X(N), Y(N)
C
      INTEGER I
C
      CALL TXBEGIN
      DO 1 I=1,N
         WRITE(6,*)'X(',I,')=',X(I),' Y(',I,')=',Y(I)
 1    CONTINUE
      CALL TXEND
      RETURN
      END
C
      SUBROUTINE SETSTY(ISTY)
C--------------------------------------------
C SET LINE DRAWING STYLE.
C--------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER ISTY
C
      IF( (ISTY .LT. 1) .OR. (ISTY .GT. 4) )THEN
         CALL TXBEGIN
         WRITE(6,100)ISTY
 100     FORMAT(1X,'SETSTY PASSED INVALID ISTY',I6)
         CALL TXEND
         RETURN
      ENDIF
      GOTO(1,2,3,4),ISTY
 1    CONTINUE
      CALL DSHOFF
      GOTO 5
 2    CONTINUE
      CALL DASH
      GOTO 5
 3    CONTINUE
      CALL DOT
      GOTO 5
 4    CONTINUE
      CALL DSHDOT
 5    CONTINUE
      RETURN
      END
C
      SUBROUTINE LINSPC(X,N,START,STOP)
C--------------------------------------------
C INSERT N EVENLY SPACED VALUES COVERING START TO STOP INCLUSIVE.
C--------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL X(N), START, STOP
C
      INTEGER I
      REAL STEP
C
      STEP = (STOP - START) / (N - 1)
      DO 1 I=1,N
         X(I) = START + (I-1) * STEP
 1    CONTINUE
      RETURN
      END
C
      SUBROUTINE LOGSPC(X,N,START,STOP,BASE)
C---------------------------------------------
C RETURN N NUMBERS SPACED EVENLY ON A LOG SCALE.
C---------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL X(N), START, STOP, BASE
C
      INTEGER I
C
      CALL LINSPC(X,N,START,STOP)
      DO 1 I=1,N
         X(I) = BASE ** X(I)
 1    CONTINUE
      RETURN
      END
C
      LOGICAL FUNCTION VALDFMT(FMTSTR)
C---------------------------------------------
C SIMPLE CHECKS THAT A FORMAT STRING MIGHT BE VALID.
C---------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) FMTSTR
C
      INTEGER L
C
      L = LEN(FMTSTR)
      VALDFMT = .TRUE.
      IF( FMTSTR(1:1) .NE. '(' )VALDFMT = .FALSE.
      IF( FMTSTR(L:L) .NE. ')' )VALDFMT = .FALSE.
      RETURN
      END
C
      INTEGER FUNCTION EVAL(STACK,NELEM,NPOINTS,NWORDS,NSTACK,COPS,
     +                      HAVDEV,IDEV,NDEVS,ITER,MEMS,GCHANGE,
     +                      RBASE,RSTART,RSTOP,STRINGS,STRILEN,TXTCON,
     +                      ZEROVAL,BB,DOBB,FSYMHT,ASIZE,ASHARP,BARB,
     +                      ISTYLE,SKIPSCL,ANNSCL)
C---------------------------------------------
C ULTRA SIMPLE RPN FUNCTION EVALUATOR THAT OPERATES ON VECTORS.
C COPS IS A STRING CONTAINING OPERANDS AND OPERATORS SEPARATED BY COMMAS
C STACK IS THE ALLOCATED POINTS ARRAY, TOTAL SIZE NWORDS=NSTACK*NPOINTS
C  USED AS: ISTACK = 0 [1 .. NELEM .. NPOINTS] <- X RANGE VALUES.
C           ISTACK = 1 [NPOINTS+1 .. NPOINTS+1+NELEM .. 2*NPOINTS] <- Y
C           ISTACK = 2 [2*NPOINTS+1 .. 2*NPOINTS+1+NELEM .. 3*NPOINTS]
C           ISTACK = 3 [3*NPOINTS+1 .. 3*NPOINTS+1+NELEM .. 4*NPOINTS]
C           ...
C           ISTACK = NSTACK-1
C  NELEM IS THE NUMBER OF ACTIVE ELEMENTS = NUMBER OF X RANGE VALUES.
C  ISTACK = 0 IS NEVER MODIFIED, EXCEPT BY SETX AND XLIN,XLOG.
C  RETURN 0 IF EVALUATION WORKED, ELSE AN ERROR CODE.
C---------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NELEM, NPOINTS, NWORDS, IDEV, NDEVS, NSTACK, ITER
      REAL STACK(NWORDS), MEMS(9), RBASE, RSTART, RSTOP, ZEROVAL, BB(4)
      REAL FSYMHT, ASIZE, ASHARP, BARB, SKIPSCL, ANNSCL
      CHARACTER*(*) COPS
      CHARACTER*80 STRINGS(9)
      INTEGER STRILEN(9)
      INTEGER ISTYLE
      LOGICAL HAVDEV, GCHANGE, TXTCON, DOBB
#ifdef PORTF77
      REAL RANF
#endif
C
      INTEGER LCOPS, IBEG, IEND, ILEN, ISTKTOP, ISTKPOP, I, J, IOP
      INTEGER NOPS, JUNK, IERR, NS1, ISTKPTR, ISTACK, ISTKPO2, ISTKPO3
      INTEGER ISTKNEW, IREG, NEWELEM, IARG, IOEN, IOST, IMPOS, NFMT
      INTEGER ISTKPO4
      REAL ARG, DOMLIM, CEILING, V, FLOOR, MPI
      PARAMETER( NOPS=90 )
      PARAMETER( MPI=3.14159265359 )
      CHARACTER*4 OPNAMES(NOPS)
      INTEGER MINSTK(NOPS), OPLEN(NOPS)
      CHARACTER*20 COP
      CHARACTER*80 EMSG, MARKER
      CHARACTER*5 VFMT
      LOGICAL RFROMC, CLOSED, VALDFMT, TRPDIV0
      INTEGER LNBC
      REAL X, Y, XO, YO, ROP, STRING, ZEROTST, SFSYMHT, LFSYMHT
      SAVE
      DATA X/0.0/, Y/0.0/
      DATA OPNAMES/    '+',    '-',    '*',    '/',    'P',
     +                'R/',   'R-',  'SIN',  'COS',  'TAN',
     +              'ASIN', 'ACOS', 'ATAN',  'CHS', 'SQRT',
     +                '**',  'RCP',  'INT', 'FRAC',  'FLR',
     +              'CEIL', 'SWAP', 'RAND', 'SETX',  'LOG',
     +              'LG10', 'LOG2',  'EXP', 'SINH', 'COSH',
     +              'TANH',  'MIN',  'MAX',  'DUP', 'DUMP',
     +               'STO',  'RCL',  'ABS', 'SIGN',    'M',
     +                 'D', 'HDSH', 'VDSH', 'XLIN', 'PTHO',
     +              'PTHC',  'ODD', 'ELEM',  'POP', 'XLOG',
     +              'SEED',  'MOD', 'I1IJ', 'I0IJ',    'T',
     +               'TVF',  'TVI',   'TS',   'TM',   'TC',
     +                'TH',   'TA',  'TSC',  'TEC', 'TLEN',
     +                'PE',   'GT',   'LT',   'LE',   'GE',
     +                'EQ',   'NE',  'NOT',  'SEL',  'IDX',
     +              'SETY',    'C',    'A',  'BOX',   'PC',
     +                 '#',    '=',    '&',    'S',  'ROT',
     +               'TRN',  'SCL',   'R2D', 'D2R',  'LAB'/
C 1 CHARACTER SYNONMYS FOR:   RCL:#, STO:=, DUP:&, SWAP:S.
      DATA MINSTK/2, 2, 2, 2, 1,
     +            2, 2, 1, 1, 1,
     +            1, 1, 1, 1, 1,
     +            2, 1, 1, 1, 1,
     +            1, 2, 1, 1, 1,
     +            1, 1, 1, 1, 1,
     +            1, 2, 2, 1, 1,
     +            2, 1, 1, 1, 2,
     +            2, 1, 1, 3, 2,
     +            2, 1, 2, 1, 4,
     +            1, 2, 2, 2, 1,
     +            2, 2, 1, 1, 1,
     +            1, 1, 0, 0, 1,
     +            3, 2, 2, 2, 2,
     +            2, 2, 1, 3, 0,
     +            1, 3, 5, 4, 1,
     +            1, 2, 1, 2, 3,
     +            4, 4, 1, 1, 4/
      DATA OPLEN/1, 1, 1, 1, 1,
     +           2, 2, 3, 3, 3,
     +           4, 4, 4, 3, 4,
     +           2, 3, 3, 4, 3,
     +           4, 4, 4, 4, 3,
     +           4, 4, 3, 4, 4,
     +           4, 3, 3, 3, 4,
     +           3, 3, 3, 4, 1,
     +           1, 4, 4, 4, 4,
     +           4, 3, 4, 3, 4,
     +           4, 3, 4, 4, 1,
     +           3, 3, 2, 2, 2,
     +           2, 2, 3, 3, 4,
     +           2, 2, 2, 2, 2,
     +           2, 2, 3, 3, 3,
     +           4, 1, 1, 3, 2,
     +           1, 1, 1, 1, 3,
     +           3, 3, 3, 3, 3/
C
C---- THE DOMAIN OF SEVERAL MATHEMATICAL FUNCTIONS IS LIMITED TO THIS:
C---- ALSO, IF TRPDIV0, TRAP DIVIDE BY < ABS(1E-9) ELSE USE 1E-9.
#ifdef PORTF77
      DOMLIM = 1.0E38
#else
      DOMLIM = (2.0**47)-1.0
#endif
      TRPDIV0 = (ZEROVAL .EQ. 0.0)
      IF( ZEROVAL .EQ. 0.0)THEN
         ZEROTST = 1.0E-9
      ELSE
         ZEROTST = ABS(ZEROVAL)
      ENDIF
C
C---- SAVE SYMHT VALUE AS IT IS ON ENTRY, TO RESTORE ON EXIT.
      SFSYMHT = FSYMHT
      LFSYMHT = FSYMHT
C
C---- THE STACK INDEX GIVES THE TOP OCCUPIED ITEM. INITIALLY RANGE IN O.
C---- PUSH: INCREMENT ISTACK, CHECK <= NS1, PUT THINGS IN STACK[ISTACK].
C---- POP: CHECK > 0, GET THINGS FROM STACK[ISTACK], DECREMENT ISTACK.
      ISTACK = 0
      NS1 = NSTACK - 1
      IERR = 0
C
C---- SPLIT THE RPN STRING INTO TOKENS ON COMMAS.
      CALL UPCASE(COPS)
      LCOPS = LNBC(COPS,1,1)
      IBEG = 1
 1    CONTINUE
         IF( IBEG .GT. LCOPS )GOTO 2
         IEND = INDEX(COPS(IBEG:),',')
         IF( IEND .EQ. 0 )THEN
            IEND = LCOPS + 1
         ELSE
            IEND = IEND + IBEG - 1
         ENDIF
         IF( IEND .GT. IBEG )THEN
            ILEN = IEND - IBEG
            IF( ILEN .GT. 20 )GOTO 9003
            COP(1:ILEN) = COPS(IBEG:IEND)
C
C---- DEAL WITH THIS TOKEN. CHECK FOR OPERANDS FIRST.
C--- ANYTHING THAT CAN BE INTERPRETED AS A REAL NUMBER IS AN OPERAND.
C--- NUMBER : (    -- A1 ) : SET ARRAY TO A LITERAL CONSTANT.
            IF( RFROMC(COP(1:ILEN),ROP,1,JUNK) )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 10 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = ROP
 10            CONTINUE
C
C--- X MEANS PUT RANGE VALUES ON THE STACK.
C--- X : (   -- A1 ) : GET X RANGE ARRAY
            ELSE IF( (ILEN .EQ. 1) .AND. (COP(1:ILEN) .EQ. 'X') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               J = 1
               DO 11 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = STACK(J)
                  J = J + 1
 11            CONTINUE
C
C--- PI MEANS PUT 3.14159... ON THE STACK.
C--- PI : (    -- A1 ) : SET ARRAY TO PI.
            ELSE IF( (ILEN .EQ. 2) .AND. (COP(1:ILEN) .EQ. 'PI') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 12 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = MPI
 12            CONTINUE
C
C--- E MEANS PUT 2.71828 ... ON THE STACK.
C--- E : (   -- A1 ) : SET ARRAY TO E.
            ELSE IF( (ILEN .EQ. 1) .AND. (COP(1:ILEN) .EQ. 'E') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 13 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = 2.718281828459
 13            CONTINUE
C
C--- I MEANS PUT ITERATION NUMBER ON THE STACK.
C--- I : (  -- A1 ) : SET ARRAY TO CURRENT ITERATION NUMBER.
            ELSE IF( (ILEN .EQ. 1) .AND. (COP(1:ILEN) .EQ. 'I') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 14 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = ITER
 14            CONTINUE
C
C--- TWPI MEANS PUT 2*3.14159... ON THE STACK.
C--- TWPI : (  -- A1 ) : SET ARRAY TO 2 * PI.
            ELSE IF( (ILEN .EQ. 4) .AND. (COP(1:ILEN) .EQ. 'TWPI') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 15 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = 2.0*MPI
 15            CONTINUE
C
C--- PI/2 MEANS PUT 0.5*3.14159... ON THE STACK.
C--- PI/2 : (  -- A1 ) : SET ARRAY TO PI / 2.
            ELSE IF( (ILEN .EQ. 4) .AND. (COP(1:ILEN) .EQ. 'PI/2') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 16 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = 0.5*MPI
 16            CONTINUE
C
C--- NOT AN OPERAND. IS IT AN OPERATOR?
            ELSE
               IOP = 0
               IF( ILEN .GT. 4 )GOTO 302
               DO 301 I=1,NOPS
                  IF( ILEN .EQ. OPLEN(I) )THEN
                     IF( COP(1:ILEN) .EQ. OPNAMES(I)(1:ILEN) )THEN
                        IOP = I
                        GOTO 302
                     ENDIF
                  ENDIF
 301           CONTINUE
 302           CONTINUE
               IF( IOP .EQ. 0 )GOTO 9004
C
C--- IT IS A KNOWN OPERATOR. TRY TO APPLY IT.
               IF( ISTACK .LT. MINSTK(IOP) )GOTO 9001
               ISTKTOP = ISTACK * NPOINTS + 1
               ISTKPOP = ISTKTOP - NPOINTS
               ISTKPO2 = ISTKPOP - NPOINTS
               ISTKPO3 = ISTKPO2 - NPOINTS
               ISTKPO4 = ISTKPO3 - NPOINTS
               GOTO(201,202,203,204,205,
     +              206,207,208,209,210,
     +              211,212,213,214,215,
     +              216,217,218,219,220,
     +              221,222,223,224,225,
     +              226,227,228,229,230,
     +              231,232,233,234,235,
     +              236,237,238,239,240,
     +              241,242,243,244,245,
     +              246,247,248,249,250,
     +              251,252,253,254,255,
     +              256,257,258,259,260,
     +              261,262,263,264,265,
     +              266,267,268,269,270,
     +              271,272,273,274,275,
     +              276,277,278,279,280,
     +              237,236,234,222,285,
     +              286,287,288,289,290),IOP
C
C--- + : ADD ( A1 A2 -- A1 ) : A1 = A1 + A2
 201           CONTINUE
               DO 2101 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) + STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2101          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- - : SUBTRACT ( A1 A2 -- A1 ) : A1 = A1 - A2
 202           CONTINUE
               DO 2102 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) - STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2102          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- * : MULTIPLY ( A1 A2 -- A1 ) : A1 = A1 * A2
 203           CONTINUE
               DO 2103 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) * STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2103          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- / : DIVIDE ( A1 A2 -- A1 ) : A1 = A1 / A2
 204           CONTINUE
               DO 2104 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .LT. ZEROTST )THEN
                     IF( TRPDIV0 )THEN
                        GOTO 9002
                     ELSE
                        IF( ABS(STACK(ISTKPOP)) .LT. ZEROTST )THEN
                           STACK(ISTKPOP) = 1.0
                        ELSE
                           ARG = SIGN(ZEROTST,ARG)
                           STACK(ISTKPOP) = STACK(ISTKPOP) / ARG
                        ENDIF
                     ENDIF
                  ELSE
                     STACK(ISTKPOP) = STACK(ISTKPOP) / ARG
                  ENDIF
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2104          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- P  : PRINT ( -- ) : PRINT TOP OF STACK INFORMATION.
 205           CONTINUE
               IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
               CALL TXBEGIN
               WRITE(6,2105)ISTACK, STACK(ISTKTOP), NELEM,
     +                      STACK(ISTKTOP+NELEM-1)
 2105          FORMAT(1X,'TOP:',I1,' [1]:',G12.4,' ... [',I4,']:',G12.4)
               CALL TXEND
               GOTO 299
C
C--- R/ : REVERSE DIVIDE ( A1 A2 -- A1 ) : A1 = A2 / A1
 206           CONTINUE
               DO 2106 I=1,NELEM
                  ARG = STACK(ISTKPOP)
                  IF( ABS(ARG) .LT. ZEROTST )THEN
                     IF( TRPDIV0 )THEN
                        GOTO 9002
                     ELSE
                        IF( ABS(STACK(ISTKTOP)) .LT. ZEROTST )THEN
                           STACK(ISTKPOP) = 1.0
                        ELSE
                           ARG = SIGN(ZEROTST,ARG)
                           STACK(ISTKPOP) = STACK(ISTKTOP) / ARG
                        ENDIF
                     ENDIF
                  ELSE
                     STACK(ISTKPOP) = STACK(ISTKTOP) / ARG
                  ENDIF
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2106          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- R- : REVERSE SUBTRACT ( A1 A2 -- A1 ) : A1 = A2 - A1
 207           CONTINUE
               DO 2107 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKTOP) - STACK(ISTKPOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2107          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- SIN : ( A1 -- A1 ) : A1 = SIN(A1)
 208           CONTINUE
               DO 2108 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = SIN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2108          CONTINUE
               GOTO 299
C
C--- COS : ( A1 -- A1 ) : A1 = COS(A1)
 209           CONTINUE
               DO 2109 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = COS(ARG)
                  ISTKTOP = ISTKTOP + 1
 2109          CONTINUE
               GOTO 299
C
C--- TAN : ( A1 -- A1 ) : A1 = TAN(A1)
 210           CONTINUE
               DO 2110 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = TAN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2110          CONTINUE
               GOTO 299
C
C--- ASIN : ( A1 -- A1 ) : A1 = ARCSIN(A1)
 211           CONTINUE
               DO 2111 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 1.0 )GOTO 9005
                  STACK(ISTKTOP) = ASIN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2111          CONTINUE
               GOTO 299
C
C--- ACOS : ( A1 -- A1 ) : A1 = ARCCOS(A1)
 212           CONTINUE
               DO 2112 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 1.0 )GOTO 9005
                  STACK(ISTKTOP) = ACOS(ARG)
                  ISTKTOP = ISTKTOP + 1
 2112          CONTINUE
               GOTO 299
C
C--- ATAN : ( A1 -- A1 ) : A1 = ARCTAN(A1)
 213           CONTINUE
               DO 2113 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = ATAN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2113          CONTINUE
               GOTO 299
C
C--- CHS : ( A1 -- A1 ) : A1 = -A1
 214           CONTINUE
               DO 2114 I=1,NELEM
                  STACK(ISTKTOP) = -STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
 2114          CONTINUE
               GOTO 299
C
C--- SQRT : ( A1 -- A1 ) : A1 = SQRT(A1)
 215           CONTINUE
               DO 2115 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 0.0 )GOTO 9005
                  STACK(ISTKTOP) = SQRT(ARG)
                  ISTKTOP = ISTKTOP + 1
 2115          CONTINUE
               GOTO 299
C
C--- ** : ( A1 A2 -- A1 ) : A1 = A1 ** A2
 216           CONTINUE
               DO 2116 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) ** STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2116          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- RCP : ( A1 -- A1 ) : RECIPROCAL A1 = 1.0 / A1
 217           CONTINUE
               DO 2117 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .LT. 1.0E-9 )GOTO 9005
                  STACK(ISTKTOP) = 1.0 / ARG
                  ISTKTOP = ISTKTOP + 1
 2117          CONTINUE
               GOTO 299
C
C--- INT : ( A1 -- A1 ) : TRUNCATION A1 = INT(A1)
 218           CONTINUE
               DO 2118 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = INT(ARG)
                  ISTKTOP = ISTKTOP + 1
 2118          CONTINUE
               GOTO 299
C
C--- FRAC : ( A1 -- A1 ) : FRACTIONAL PART A1 = FRAC(A1)
 219           CONTINUE
               DO 2119 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  FLOOR = INT(ARG)
                  IF( ARG .LT. 0.0 )FLOOR = FLOOR - 1.0
                  STACK(ISTKTOP) = ARG - FLOOR
                  ISTKTOP = ISTKTOP + 1
 2119          CONTINUE
               GOTO 299
C
C--- FLR : ( A1 -- A1 ) : A1 = FLOOR(A1)
 220           CONTINUE
               DO 2120 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  FLOOR = INT(ARG)
                  IF( ARG .LT. 0.0 )FLOOR = FLOOR - 1.0
                  STACK(ISTKTOP) = FLOOR
                  ISTKTOP = ISTKTOP + 1
 2120          CONTINUE
               GOTO 299
C
C--- CEIL : ( A1 -- A1 ) : A1 = CEILING(A1)
 221           CONTINUE
               DO 2121 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  CEILING = INT(ARG)
                  IF( ARG .GT. 0.0 )CEILING = CEILING + 1.0
                  STACK(ISTKTOP) = CEILING
                  ISTKTOP = ISTKTOP + 1
 2121          CONTINUE
               GOTO 299
C
C--- SWAP : ( A1 A2 -- A2 A1 )
 222           CONTINUE
               DO 2122 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  STACK(ISTKTOP) = STACK(ISTKPOP)
                  STACK(ISTKPOP) = ARG
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2122          CONTINUE
               GOTO 299
C
C--- RAND : ( A1 -- A1 ) : UNI DIST RANDOMS 0 TO A1 A1 = A1 * RANDOM
 223           CONTINUE
               DO 2123 I=1,NELEM
                  STACK(ISTKTOP) = RANF() * STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
 2123          CONTINUE
               GOTO 299
C
C--- SETX : ( A1 -- A1 ) : OVERWRITE RANGE VALUES WITH STACK TOP VALUES.
 224           CONTINUE
               J = 1
               DO 2124 I=1,NELEM
                  STACK(J) = STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
                  J = J + 1
 2124          CONTINUE
               GOTO 299
C
C--- LOG : ( A1 -- A1 ) : BASE E LOGARITHM A1 = LN(A1)
 225           CONTINUE
               DO 2125 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 1.0E-29 )GOTO 9005
                  STACK(ISTKTOP) = LOG(ARG)
                  ISTKTOP = ISTKTOP + 1
 2125          CONTINUE
               GOTO 299
C
C--- LG10 : ( A1 -- A1 ) : BASE 10 LOGARITHM A1 = LOG10(A1)
 226           CONTINUE
               DO 2126 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 1.0E-29 )GOTO 9005
                  STACK(ISTKTOP) = LOG10(ARG)
                  ISTKTOP = ISTKTOP + 1
 2126          CONTINUE
               GOTO 299
C
C--- LOG2 : ( A1 -- A1 ) : BASE 2 LOGARITHM A1 = LOG2(A1)
 227           CONTINUE
               DO 2127 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 1.0E-29 )GOTO 9005
                  STACK(ISTKTOP) = 1.44269504088 * LOG(ARG)
                  ISTKTOP = ISTKTOP + 1
 2127          CONTINUE
               GOTO 299
C
C--- EXP : ( A1 -- A1 ) : A1 =  E ** A1  DOMAIN: -675.81 TO 741.66
 228           CONTINUE
               DO 2128 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 675.0 )GOTO 9005
                  STACK(ISTKTOP) = EXP(ARG)
                  ISTKTOP = ISTKTOP + 1
 2128          CONTINUE
               GOTO 299
C
C--- SINH : ( A1 -- A1 ) : A1 = SINH(A1) DOMAIN \X\ < 742.36
 229           CONTINUE
               DO 2129 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 742.0 )GOTO 9005
                  STACK(ISTKTOP) = SINH(ARG)
                  ISTKTOP = ISTKTOP + 1
 2129          CONTINUE
               GOTO 299
C
C--- COSH : ( A1 -- A1 ) : A1 = COSH(A1) DOMAIN \X\ < 742.36
 230           CONTINUE
               DO 2130 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 742.0 )GOTO 9005
                  STACK(ISTKTOP) = COSH(ARG)
                  ISTKTOP = ISTKTOP + 1
 2130          CONTINUE
               GOTO 299
C
C--- TANH : ( A1 -- A1 ) : A1 = TANH(A1) DOMAIN \X\ < 742.36
 231           CONTINUE
               DO 2131 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 742.0 )GOTO 9005
                  STACK(ISTKTOP) = TANH(ARG)
                  ISTKTOP = ISTKTOP + 1
 2131          CONTINUE
               GOTO 299
C
C--- MIN : ( A1 A2 -- A1 ) : A1 = MIN(A1,A2)
 232           CONTINUE
               DO 2132 I=1,NELEM
                  STACK(ISTKTOP) = MIN(STACK(ISTKPOP),STACK(ISTKTOP))
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2132          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- MAX : ( A1 A2 -- A1 ) : A1 = MAX(A1,A2)
 233           CONTINUE
               DO 2133 I=1,NELEM
                  STACK(ISTKTOP) = MAX(STACK(ISTKPOP),STACK(ISTKTOP))
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2133          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- DUP : ( A1 -- A1 A1 ) : DUPLICATE TOP OF STACK
 234           CONTINUE
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKNEW = ISTACK * NPOINTS + 1
               DO 2134 I=1,NELEM
                  STACK(ISTKNEW) = STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
                  ISTKNEW = ISTKNEW + 1
 2134          CONTINUE
               GOTO 299
C
C--- DUMP : ( -- ) : PRINT ALL STACK LEVELS.
 235           CONTINUE
               IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
               CALL TXBEGIN
               WRITE(6,2435)NELEM, NPOINTS, NWORDS, NSTACK
 2435          FORMAT(1X,'NELEM:',I5,' NPOINTS:',I5,' NWORDS:',I5,
     +                ' NSTACK:',I5)
               WRITE(6,2335)ISTACK
 2335          FORMAT(1X,'ISTACK = ',I2,' LVL 0 = X')
               DO 2235 I=0,ISTACK
                  ISTKPTR = I * NPOINTS + 1
                  WRITE(6,2135)I, STACK(ISTKPTR), NELEM,
     +                         STACK(ISTKPTR+NELEM-1)
 2235          CONTINUE
 2135          FORMAT(1X,'LVL:',I1,' [1]:',G12.4,' ... [',I4,']:',G12.4)
               CALL TXEND
               GOTO 299
C
C--- STO : ( A1 C2 -- A1 ) : STORE A1[1] IN REGISTER C2
 236           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               MEMS(IREG) = STACK(ISTKPOP)
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- RCL : ( A1 -- C1 ) : RECALL CONST VALUE A1 FROM REGISTER INT(A1)
 237           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               DO 2137 I=1,NELEM
                  STACK(ISTKTOP) = MEMS(IREG)
                  ISTKTOP = ISTKTOP + 1
 2137          CONTINUE
               GOTO 299
C
C--- ABS : ( A1 -- A1 ) : A1 = ABS(A1)
 238           CONTINUE
               DO 2138 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  STACK(ISTKTOP) = ABS(ARG)
                  ISTKTOP = ISTKTOP + 1
 2138          CONTINUE
               GOTO 299
C
C--- SIGN : ( A1 -- A1 ) : A1 = (A1 < 0) ? -1 : 1
 239           CONTINUE
               DO 2139 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  STACK(ISTKTOP) = SIGN(1.0,ARG)
                  ISTKTOP = ISTKTOP + 1
 2139           CONTINUE
               GOTO 299
C
C--- M : ( C1 C2 -- ) : MOVE TO (A1[1],A2[1])
 240           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               Y = STACK(ISTKTOP)
               X = STACK(ISTKPOP)
               IF( DOBB )THEN
                 BB(1) = MIN(BB(1),X)
                 BB(2) = MAX(BB(2),X)
                 BB(3) = MIN(BB(3),Y)
                 BB(4) = MAX(BB(4),Y)
               ELSE
                 CALL OFF2(X,Y)
               ENDIF
               ISTACK = ISTACK - 2
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               GOTO 299
C
C--- D : ( C1 C2 -- ) : DRAW TO (A1[1],A2[1])
 241           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               Y = STACK(ISTKTOP)
               X = STACK(ISTKPOP)
               IF( DOBB )THEN
                 BB(1) = MIN(BB(1),X)
                 BB(2) = MAX(BB(2),X)
                 BB(3) = MIN(BB(3),Y)
                 BB(4) = MAX(BB(4),Y)
               ELSE
                  CALL ON2(X,Y)
               ENDIF
               ISTACK = ISTACK - 2
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               GOTO 299
C
C--- HDSH : ( A1 -- A1 ) : DRAW RELATIVE (1,0) IF A1[I] > 0 ELSE MOVE
 242           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               DO 2142 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  X = X + 1.0
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     IF( ARG .GT. 0 )THEN
                        CALL ON2(X,Y)
                     ELSE
                        CALL OFF2(X,Y)
                     ENDIF
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2142          CONTINUE
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               GOTO 299
C
C--- VDSH : ( A1 -- A1 ) : DRAW RELATIVE (0,1) IF A1[I] > 0 ELSE MOVE
 243           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               DO 2143 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  Y = Y + 1.0
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     IF( ARG .GT. 0 )THEN
                        CALL ON2(X,Y)
                     ELSE
                        CALL OFF2(X,Y)
                     ENDIF
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2143          CONTINUE
               IF( .NOT. DOBB)GCHANGE = .TRUE.
               GOTO 299
C
C--- XLIN : ( C1 C2 C3 -- ) : X = A1[1] TO A2[1] IN A3[1] LINEAR STEPS
 244           CONTINUE
               NEWELEM = INT(STACK(ISTKTOP))
               IF( NEWELEM .LT. 2 )GOTO 9007
               IF( NEWELEM .GT. NPOINTS )GOTO 9009
               RBASE = 1
               RSTART = STACK(ISTKPO2)
               RSTOP = STACK(ISTKPOP)
               CALL LINSPC(STACK,NEWELEM,RSTART,RSTOP)
               NELEM = NEWELEM
               ISTACK = ISTACK - 3
               GOTO 299
C
C--- PTHO, PTHC : ( A1 A2 -- ) : DRAW POLYLINE X=A1,Y=A2, OPEN/CLOSED
 245           CONTINUE
               CLOSED = .FALSE.
               GOTO 2145
 246           CONTINUE
               CLOSED = .TRUE.
 2145          CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               X = STACK(ISTKPOP)
               Y = STACK(ISTKTOP)
               XO = X
               YO = Y
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),X)
                  BB(2) = MAX(BB(2),X)
                  BB(3) = MIN(BB(3),Y)
                  BB(4) = MAX(BB(4),Y)
               ELSE
                  CALL OFF2(X,Y)
               ENDIF
               ISTKTOP = ISTKTOP + 1
               ISTKPOP = ISTKPOP + 1
               DO 2245 I=2,NELEM
                  X = STACK(ISTKPOP)
                  Y = STACK(ISTKTOP)
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     CALL ON2(X,Y)
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
                  ISTKPOP = ISTKPOP + 1
 2245          CONTINUE
               IF( CLOSED )THEN
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     CALL ON2(XO,YO)
                  ENDIF
                  X = XO
                  Y = YO
               ENDIF
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               ISTACK = ISTACK - 2
               GOTO 299
C
C--- ODD : ( A1 -- A1 ) : A1 = 1 WHERE A1 IS ODD ELSE 0
 247           CONTINUE
               DO 2147 I=1,NELEM
                  IARG = INT(STACK(ISTKTOP))
                  IF( 2*(IARG/2) .EQ. IARG )THEN
                     STACK(ISTKTOP) = 0
                  ELSE
                     STACK(ISTKTOP) = 1
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2147           CONTINUE
                GOTO 299
C
C--- ELEM : ( A1 C2 : A1 C2 ) : C2 = A1[C2]
 248            CONTINUE
                I = MAX(1,MIN(NELEM,INT(STACK(ISTKTOP))))
                V = STACK(ISTKPOP+I-1)
                DO 2148 I=1,NELEM
                   STACK(ISTKTOP) = V
                   ISTKTOP = ISTKTOP + 1
 2148           CONTINUE
                GOTO 299
C
C--- POP : ( A1 -- ) : POP THE STACK
 249            CONTINUE
                ISTACK = ISTACK - 1
                GOTO 299
C
C--- XLOG : ( C1 C2 C3 C4 -- ) : X = C1**C2 TO C1**C3 IN C4 STEPS
 250           CONTINUE
               NEWELEM = INT(STACK(ISTKTOP))
               IF( NEWELEM .LT. 2 )GOTO 9007
               IF( NEWELEM .GT. NPOINTS )GOTO 9009
               RBASE = STACK(ISTKPO3)
               RSTART = STACK(ISTKPO2)
               RSTOP = STACK(ISTKPOP)
               CALL LOGSPC(STACK,NEWELEM,RSTART,RSTOP,RBASE)
               NELEM = NEWELEM
               ISTACK = ISTACK - 4
               GOTO 299
C
C--- SEED : ( C1 -- ) : SET RANDOM NUMBER SEED TO A1[1]
 251           CONTINUE
               CALL RANSET(STACK(ISTKTOP))
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- MOD : ( A1 A2 -- A1 ) : A1 = MOD(A1,A2) OR A1 = A1 % A2
 252           CONTINUE
               DO 2152 I=1,NELEM
                  STACK(ISTKTOP) = MOD(STACK(ISTKTOP),STACK(ISTKPOP))
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2152          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- I0IJ : ( C1 C2 -- C1 C2 ) : C1'=MOD(C1,C2), C2'=(C1/C2)
C--- I1IJ : ( C1 C2 -- C1 C2 ) : C1'=MOD(C1,C2)+1, C2'=(C1/C2)+1
 253           CONTINUE
               I = INT(STACK(ISTKTOP))
               IF( I .LE. 0 )GOTO 9005
               J = INT(STACK(ISTKPOP))
               IF( J .LE. 0 )GOTO 9005
               ARG = MOD(J-1,I) + 1
               V = (J-1) / I + 1
               GOTO 2253
 254           CONTINUE
               I = INT(STACK(ISTKTOP))
               IF( I .LE. 0 )GOTO 9005
               J = INT(STACK(ISTKPOP))
               IF( J .LE. 0 )GOTO 9005
               ARG = MOD(J-1,I)
               V = (J-1) / I
 2253          CONTINUE
               DO 2153 I=1,NELEM
                  STACK(ISTKPOP) = ARG
                  STACK(ISTKTOP) = V
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2153          CONTINUE
               GOTO 299
C
C--- T : ( C1 -- ) : DRAW CONTENTS OF STRING REGISTER C1 AS TEXT.
 255           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               IF( STRILEN(IREG) .EQ. 0 )GOTO 9010
               IF( .NOT. DOBB )THEN
                  CALL OFF2(X,Y-0.5*LFSYMHT)
                  CALL SYMTXT(STRINGS(IREG)(1:STRILEN(IREG)))
                  CALL OFF2(X,Y)
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TVF : ( C1 C2 -- C1 ) : DRAW C1 AS TEXT USING FORMAT STRING IN C2.
C--- TVI : ( C1 C2 -- C1 ) : DRAW INT(C1) AS TEXT, AS PER TVF.
 256           CONTINUE
 257           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               IF( STRILEN(IREG) .EQ. 0 )GOTO 9010
               IF( .NOT. VALDFMT(STRINGS(IREG)(1:STRILEN(IREG))) )
     +            GOTO 9011
               IF( .NOT. DOBB )THEN
                  IF( IOP .EQ. 56 )THEN
                     CALL OFF2(X,Y-0.5*LFSYMHT)
                     CALL RNUM(STACK(ISTKPOP),
     +                         STRINGS(IREG)(1:STRILEN(IREG)))
                     CALL OFF2(X,Y)
                  ELSE
                     CALL OFF2(X,Y-0.5*LFSYMHT)
                     CALL INUM(INT(STACK(ISTKPOP)),
     +                         STRINGS(IREG)(1:STRILEN(IREG)))
                     CALL OFF2(X,Y)
                  ENDIF
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TS : ( C1 -- ) : DRAW SYMBOL WITH CODE NUMBER C1
C--- TM : ( C1 -- ) : DRAW MARKER WITH CODE NUMBER C1
C--- TC : ( C1 -- ) : DRAW CHARACTER FROM CUR ALPHABET WITH CODE C1
 258           CONTINUE
               VFMT = ' '
               WRITE(VFMT,2158)INT(STACK(ISTKTOP))
 2158          FORMAT('*:',I2.2)
               NFMT = 4
               GOTO 2260
 259           CONTINUE
               VFMT = ' '
               WRITE(VFMT,2159)INT(STACK(ISTKTOP))
 2159          FORMAT('*::',I2.2)
               NFMT = 5
               GOTO 2260
 260           CONTINUE
               VFMT = ' '
               WRITE(VFMT,2160)INT(STACK(ISTKTOP))
 2160          FORMAT('*V',I2.2)
               NFMT = 4
 2260          CONTINUE
               IF( .NOT. DOBB )THEN
                  CALL OFF2(X,Y-0.5*LFSYMHT)
                  CALL SYMTXT(VFMT(1:NFMT))
                  CALL OFF2(X,Y)
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TH : ( C1 -- ) : SET TEXT/MARKER/SYMBOL HEIGHT
 261           CONTINUE
               CALL SYMHT(STACK(ISTKTOP))
               CALL MARKHT(STACK(ISTKTOP))
               LFSYMHT = STACK(ISTKTOP)
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TA : ( C1 -- ) : SET TEXT DRAWING ANGLE IN DEGREES CCW
 262           CONTINUE
               CALL SYMANG(STACK(ISTKTOP))
               GOTO 299
C
C--- TSC : ( -- ) : SET TEXT START CONTINUATION
 263           CONTINUE
               CALL SYMCON
               TXTCON = .TRUE.
               GOTO 299
C
C--- TEC : ( -- ) : SET TEXT END CONTINUATION
 264           CONTINUE
               CALL ENSYMC
               TXTCON = .FALSE.
               GOTO 299
C
C--- TLEN : ( C1 -- C1 ) : GET THE LENGTH IN BOUNDS UNITS OF A STRING
 265           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               IF( STRILEN(IREG) .EQ. 0 )GOTO 9010
               V = STRING(STRINGS(IREG)(1:STRILEN(IREG)))
               DO 2165 I=1,NELEM
                  STACK(ISTKTOP) = V
                  ISTKTOP = ISTKTOP + 1
 2165          CONTINUE
               GOTO 299
C
C--- PE : ( A1 C2 C3 -- A1 ): PRINT RANGE OF TOS ELEMENTS FREE FORMAT
 266           CONTINUE
               IOST = MAX(1,MIN(NELEM,INT(STACK(ISTKPOP))))
               IOEN = MAX(IOST,MIN(NELEM,INT(STACK(ISTKTOP))))
               CALL TXBEGIN
               DO 2166 I=IOST,IOEN
                  ARG = STACK(ISTKPO2+I-1)
                  WRITE(6,*)'TOS[',I,'] (OF ',NELEM,') = ',ARG
 2166          CONTINUE
               CALL TXEND
               GOTO 299
C
C--- GT : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 > A2) ? 1 : 0 ;
C--- LT : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 < A2) ? 1 : 0 ;
C--- LE : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 <= A2) ? 1 : 0 ;
C--- GE : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 >= A2) ? 1 : 0 ;
C--- EQ : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 == A2) ? 1 : 0 ;
C--- NE : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 != A2) ? 1 : 0 ;
 267           CONTINUE
               IARG = 1
               GOTO 2367
 268           CONTINUE
               IARG = 2
               GOTO 2367
 269           CONTINUE
               IARG = 3
               GOTO 2367
 270           CONTINUE
               IARG = 4
               GOTO 2367
 271           CONTINUE
               IARG = 5
               GOTO 2367
 272           CONTINUE
               IARG = 6
 2367          CONTINUE
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKNEW = ISTACK * NPOINTS + 1
               DO 2167 I=1,NELEM
                  STACK(ISTKNEW) = 0
                  ARG = STACK(ISTKPOP)
                  V = STACK(ISTKTOP)
                  GOTO(2267,2268,2269,2270,2271,2272),IARG
 2267             CONTINUE
                  IF(ARG .GT. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2268             CONTINUE
                  IF(ARG .LT. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2269             CONTINUE
                  IF(ARG .LE. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2270             CONTINUE
                  IF(ARG .GE. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2271             CONTINUE
                  IF(ARG .EQ. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2272             CONTINUE
                  IF(ARG .NE. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2467             CONTINUE
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
                  ISTKNEW = ISTKNEW + 1
 2167          CONTINUE
               GOTO 299
C
C--- NOT : ( A1 -- A1 ) : A1 = (A1 == 0) ? 1 : 0 ;
 273           CONTINUE
               DO 2173 I=1,NELEM
                  IF( STACK(ISTKTOP) .EQ. 0.0 )THEN
                     STACK(ISTKTOP) = 1.0
                  ELSE
                     STACK(ISTKTOP) = 0.0
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2173          CONTINUE
               GOTO 299
C
C--- SEL : ( A1 A2 A3 -- A1 A2 A3 ) : A3 = (A3 == 0) ? A1 : A2 ;
 274           CONTINUE
               DO 2174 I=1,NELEM
                  IF( STACK(ISTKTOP) .EQ. 0.0 )THEN
                     STACK(ISTKTOP) = STACK(ISTKPO2)
                  ELSE
                     STACK(ISTKTOP) = STACK(ISTKPOP)
                  ENDIF
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
                  ISTKNEW = ISTKNEW + 1
 2174          CONTINUE
               GOTO 299
C
C--- IDX : ( -- A1 ) : SET A1 TO THE ARRAY INDEX.
 275           CONTINUE
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKNEW = ISTACK * NPOINTS + 1
               DO 2175 I=1,NELEM
                  STACK(ISTKNEW) = I
                  ISTKNEW = ISTKNEW + 1
 2175          CONTINUE
               GOTO 299
C
C--- SETY : ( A1 -- A1 ) : OVERWRITE GRAPH Y VALUES WITH STACK TOP VALS.
 276           CONTINUE
               J = NPOINTS + 1
               DO 2176 I=1,NELEM
                  STACK(J) = STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
                  J = J + 1
 2176          CONTINUE
               GOTO 299
C
C--- C : ( C1 C2 C3 -- ) : DRAW CIRCLE, CENTER C1,C2 RADIUS C3.
 277           CONTINUE
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),STACK(ISTKPO2)-STACK(ISTKTOP))
                  BB(2) = MAX(BB(2),STACK(ISTKPO2)+STACK(ISTKTOP))
                  BB(3) = MIN(BB(3),STACK(ISTKPOP)-STACK(ISTKTOP))
                  BB(4) = MAX(BB(4),STACK(ISTKPOP)+STACK(ISTKTOP))
               ELSE
                  CALL CIRCLE(STACK(ISTKPO2), STACK(ISTKPOP),
     +                        STACK(ISTKTOP))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 3
               GOTO 299
C
C--- A : ( C1 C2 C3 C4 C5 -- ) : DRAW ARC, CTR C1,C2 RADIUS C3, C4 TO C5
 278           CONTINUE
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),STACK(ISTKPO4)-STACK(ISTKPO2))
                  BB(2) = MAX(BB(2),STACK(ISTKPO4)+STACK(ISTKPO2))
                  BB(3) = MIN(BB(3),STACK(ISTKPO3)-STACK(ISTKPO2))
                  BB(4) = MAX(BB(4),STACK(ISTKPO3)+STACK(ISTKPO2))
               ELSE
                  CALL CIRARC(STACK(ISTKPO4), STACK(ISTKPO3),
     +                        STACK(ISTKPO2), STACK(ISTKPOP),
     +                        STACK(ISTKTOP))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 5
               GOTO 299
C
C--- BOX : ( C1 C2 C3 C4 -- ) : DRAW RECTANGLE, B,L C1,C2 W,H C3,C4
 279           CONTINUE
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),STACK(ISTKPO3))
                  BB(2) = MAX(BB(2),STACK(ISTKPO3)+STACK(ISTKPOP))
                  BB(3) = MIN(BB(3),STACK(ISTKPO2))
                  BB(4) = MAX(BB(4),STACK(ISTKPO2)+STACK(ISTKTOP))
               ELSE
                  CALL RECT(STACK(ISTKPO3),STACK(ISTKPO2),0.0,
     +                      STACK(ISTKPOP),STACK(ISTKTOP))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 4
               GOTO 299
C
C--- PC : ( C1 -- C1 ) : PRINT C1 (TOS A[1]), FREE FORMAT.
 280           CONTINUE
               CALL TXBEGIN
               WRITE(6,*)'C1 = ',STACK(ISTKTOP)
               CALL TXEND
               GOTO 299
C
C--- ROT: ( A1 A2 C3 -- A1 A2 ) : ROTATE X=A1,Y=A2 BY C3 RADIANS.
 285           CONTINUE
               ARG = STACK(ISTKTOP)
               XO = COS(ARG)
               YO = SIN(ARG)
               DO 2851 I=1,NELEM
                  X = STACK(ISTKPO2)
                  Y = STACK(ISTKPOP)
                  STACK(ISTKPO2) = X * XO - Y * YO
                  STACK(ISTKPOP) = X * YO + Y * XO
                  ISTKPOP = ISTKPOP + 1
                  ISTKPO2 = ISTKPO2 + 1
 2851          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TRN: ( A1 A2 C3 C4 -- A1 A2 ) : TRANSLATE X=A1, Y=A2 BY C3,C4
 286           CONTINUE
               XO = STACK(ISTKPOP)
               YO = STACK(ISTKTOP)
               DO 2861 I=1,NELEM
                  X = STACK(ISTKPO3)
                  Y = STACK(ISTKPO2)
                  STACK(ISTKPO3) = X + XO
                  STACK(ISTKPO2) = Y + YO
                  ISTKPO3 = ISTKPO3 + 1
                  ISTKPO2 = ISTKPO2 + 1
 2861          CONTINUE
               ISTACK = ISTACK - 2
               GOTO 299
C
C--- SCL: ( A1 A2 C3 C4 -- A1 A2 ) : SCALE X=A1, Y=A2 BY C3,C4
 287           CONTINUE
               XO = STACK(ISTKPOP)
               YO = STACK(ISTKTOP)
               DO 2871 I=1,NELEM
                  X = STACK(ISTKPO3)
                  Y = STACK(ISTKPO2)
                  STACK(ISTKPO3) = X * XO
                  STACK(ISTKPO2) = Y * YO
                  ISTKPO3 = ISTKPO3 + 1
                  ISTKPO2 = ISTKPO2 + 1
 2871          CONTINUE
               ISTACK = ISTACK - 2
               GOTO 299
C
C--- R2D: ( C1 -- C1 ) : RADIANS TO DEGREES.
 288           CONTINUE
               V = STACK(ISTKTOP)
               DO 2881 I=1,NELEM
                  STACK(ISTKTOP) = V * 180.0 / MPI
                  ISTKTOP = ISTKTOP + 1
 2881          CONTINUE               
               GOTO 299
C
C--- D2R: ( C1 -- C1 ) : DEGREES TO RADIANS.
 289           CONTINUE
               V = STACK(ISTKTOP)
               DO 2891 I=1,NELEM
                  STACK(ISTKTOP) = V * MPI / 180.0
                  ISTKTOP = ISTKTOP + 1
 2891          CONTINUE               
               GOTO 299
C
C--- LAB: ( C1 C2 C3 C4 C5 -- ) : LABEL AT (C1,C2), LEN C3, ANG C4, SR C5 
 290           CONTINUE
               I = INT(STACK(ISTKTOP))
               I = MIN(9,I)
               ARG = STACK(ISTKPOP)
               V = STACK(ISTKPO2)
               Y = STACK(ISTKPO3)
               X = STACK(ISTKPO4)
               IF( I. LE. 0 )THEN
                  CALL GLABEL(X, Y, V, ARG, ' ', FSYMHT, .TRUE.,
     +                 ISTYLE, ASIZE, ASHARP, BARB, SKIPSCL, ANNSCL )
               ELSE
                  IF( STRILEN(I) .GT. 0 )THEN
                     CALL GLABEL(X, Y, V, ARG,
     +                    STRINGS(I)(1:STRILEN(I)),
     +                    FSYMHT, .TRUE.,
     +                    ISTYLE, ASIZE, ASHARP, BARB, SKIPSCL, ANNSCL )
                  ENDIF
               ENDIF
               ISTKTOP = ISTKTOP - 5
               GOTO 299
C
C--- END OF OPERATOR SWITCH.
 299           CONTINUE
C
C--- END OF OPERAND OR OPERATOR.
            ENDIF
C
C--- END OF NON-ZERO TOKEN LENGTH.
         ENDIF
C
C--- LOOK FOR THE NEXT TOKEN.
         IBEG = IEND + 1
         GOTO 1
C
C--- NO MORE TOKENS.
 2    CONTINUE
      CALL SYMHT(SFSYMHT)   
      EVAL = IERR
      RETURN
C
C--- ERROR MESSAGES.
 9000 CONTINUE
      EMSG = 'STACK OVERFLOW'
      IERR = 1
      GOTO 9990
 9001 CONTINUE
      EMSG = 'STACK UNDERFLOW'
      IERR = 2
      GOTO 9990
 9002 CONTINUE
      EMSG = 'DIVIDE BY ZERO'
      IERR = 3
      GOTO 9990
 9003 CONTINUE
      EMSG = 'TOKEN TOO LONG'
      IERR = 4
      GOTO 9990
 9004 CONTINUE
      EMSG = 'UNKNOWN OPERATOR'
      IERR = 5
      GOTO 9990
 9005 CONTINUE
      EMSG = 'DOMAIN ERROR'
      IERR = 6
      GOTO 9990
 9006 CONTINUE
      EMSG = 'INVALID REGISTER NUMBER'
      IERR = 7
      GOTO 9990
 9007 CONTINUE
      EMSG = 'EVALUATION RANGE MUST HAVE 2 OR MORE STEPS'
      IERR = 8
      GOTO 9990
 9008 CONTINUE
      EMSG = 'GRAPHICS DEVICE MUST BE OPEN FOR THIS'
      IERR = 9
      GOTO 9990
 9009 CONTINUE
      EMSG = 'NEVAL CANNOT EXCEED NPOINTS'
      IERR = 10
      GOTO 9990
 9010 CONTINUE
      EMSG = 'EMPTY STRING REGISTER'
      IERR = 11
      GOTO 9990
 9011 CONTINUE
      EMSG = 'INVALID FORMAT STRING'
      IERR = 12
      GOTO 9990
 9990 CONTINUE
      CALL TXBEGIN
      WRITE(6,9991)EMSG(1:LNBC(EMSG,1,1))
      MARKER = ' '
      IF( IBEG .LT. 72 )THEN
         WRITE(6,9991)COPS(1:LCOPS)
 9991    FORMAT(1X,A)
         MARKER(IBEG:IBEG) = '!'
         WRITE(6,9991)MARKER(1:IBEG)
      ELSE
         IOST = MAX(1,IBEG-36)
         IOEN = MIN(LCOPS,IBEG+36)
         IF( (IBEG-36) .LT. 0 )THEN
            IMPOS = 37 + (IBEG - 36)
         ELSE
            IMPOS = 37
         ENDIF
         WRITE(6,9993)COPS(IOST:IOEN)
         MARKER(IMPOS:IMPOS) = '!'
         WRITE(6,9993)MARKER(1:IMPOS+1)
 9993    FORMAT(1X,'...',A,'...')
      ENDIF
      IF( IERR .EQ. 6 )THEN
         WRITE(6,9992)ARG
 9992    FORMAT(1X,'ARGUMENT CAUSING DOMAIN ERROR: ',G13.6)
      ENDIF
      CALL TXEND
      CALL SYMHT(SFSYMHT)   
      EVAL = IERR
      RETURN
      END
C
      SUBROUTINE PATH( XARR, YARR, N, CLOSED )
C-------------------------------------------------
C DRAW A PATH (STRAIGHT LINE SEGMENTS) IN BOUNDS COORDINATES
C USING THE CONTENTS OF THE POINTS ARRAYS (GENERATED BY EVAL()).
C--------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL XARR(N), YARR(N)
      LOGICAL CLOSED
C---
      INTEGER I
C
      CALL OFF2(XARR(1),YARR(1))
      DO 1 I=2,N
         CALL ON2(XARR(I),YARR(I))
 1    CONTINUE
      IF( CLOSED )CALL ON2(XARR(1),YARR(1))
      RETURN
      END
C
      INTEGER FUNCTION EXPROC( RPN, PROCEXP, PROC, PROCLEN, NREGS )
C--------------------------------------------------
C EXPAND AN RPN STRING BY REPLACING ALL ,@N, SEQUENCES
C WITH THE CONTENTS OF PROC REGISTER PROC(N).
C--------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NREGS, PROCLEN(NREGS)
      CHARACTER*(*) RPN, PROCEXP, PROC(NREGS)
C---
      INTEGER INPOS, OUTPOS, LRPN, LPROC, IREG
      INTEGER LNBC
      CHARACTER*80 MARKER
      CHARACTER*9 REGNAME
      SAVE
      DATA REGNAME/'123456789'/
C
      LRPN = LNBC(RPN,1,1)
      INPOS = 0
      OUTPOS = 0
C
C--- LOOK AT EACH CHARACTER OF RPN. COPY TO OUTPUT UNLESS @A
 1    CONTINUE
      INPOS = INPOS + 1
      IF( INPOS .GT. LRPN )GOTO 2
      IF( RPN(INPOS:INPOS) .NE. '@' )THEN
         OUTPOS = OUTPOS + 1
         PROCEXP(OUTPOS:OUTPOS) = RPN(INPOS:INPOS)
C
C--- IF @ DECODE NEXT INPUT CHARACTER AS A SINGLE DIGIT.
      ELSE
         INPOS = INPOS + 1
         IF( INPOS .GT. LRPN )THEN
            CALL TXBEGIN
            WRITE(6,100)
            CALL TXEND
            GOTO 900
         ENDIF
         IREG = INDEX(REGNAME,RPN(INPOS:INPOS))
         IF( IREG .EQ .0 )THEN
            CALL TXBEGIN
            WRITE(6,100)
            CALL TXEND
            GOTO 900
         ENDIF
C
C--- INSERT THE CONTENTS OF PROC REGISTER IREG.
C--- PROCEXP CANNOT OVERFLOW DUE TO THE SIZES OF IT AND PROC REGISTERS.
         LPROC = PROCLEN(IREG)
         IF( LPROC .EQ. 0 )THEN
            CALL TXBEGIN
            WRITE(6,101)IREG
            CALL TXEND
            GOTO 900
         ENDIF
         OUTPOS = OUTPOS + 1
         PROCEXP(OUTPOS:OUTPOS+LPROC-1) = PROC(IREG)(1:LPROC)
         OUTPOS = OUTPOS + LPROC - 1
      ENDIF
C
C--- GET THE NEXT CHARACTER FROM RPN (IF ANY).
      GOTO 1
 2    CONTINUE
C
C--- RETURN THE LENGTH OF PROCEXP.
      EXPROC = OUTPOS
      RETURN
C
C--- DEAL WITH ERRORS.
 900  CONTINUE
      CALL TXBEGIN
      WRITE(6,102)RPN(1:LRPN)
      MARKER = ' '
      MARKER(INPOS:INPOS) = '!'
      WRITE(6,102)MARKER(1:INPOS)
      CALL TXEND
      EXPROC = 0
      RETURN
C
 102  FORMAT(1X,A)
 101  FORMAT(1X,'RPN ERROR: NOT INSERTING ZERO LENGTH PROC: ',I1)
 100  FORMAT(1X,'RPN ERROR: @ MUST BE FOLLOWED BY A DIGIT.')
      END
C
      LOGICAL FUNCTION SETREGS( PARAMS, REG, NREGS )
C----------------------------------------
C SPLIT PROCEDURE ARGUMENTS IN PARAMS ON COMMAS AND SET THE
C FIRST NUM-ARGS REGISTERS WITH THE NUMERIC VALUES.
C----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) PARAMS
      INTEGER NREGS
      REAL REG(NREGS)
C
      LOGICAL RFROMC
      REAL ROP
      INTEGER LPARAMS, IBEG, IEND, ILEN, IREG, JUNK
      INTEGER LNBC
C
      SETREGS = .TRUE.
      CALL UPCASE(PARAMS)
      IREG = 1
      LPARAMS = LNBC(PARAMS,1,1)
      IBEG = 1
 1    CONTINUE
      IF( IBEG .GT. LPARAMS )GOTO 2
      IEND = INDEX(PARAMS(IBEG:),',')
      IF( IEND .EQ. 0 )THEN
         IEND = LPARAMS + 1
      ELSE
         IEND = IEND + IBEG - 1
      ENDIF
      IF( IEND .GT. IBEG )THEN
         ILEN = IEND - IBEG
         IF( ILEN .GT . 20 )GOTO 900
         IF( RFROMC(PARAMS(IBEG:IEND-1),ROP,1,JUNK) )THEN
            IF( (INDEX(PARAMS(IBEG:IEND-1),'.') .EQ. 0) .AND.
     +           (INDEX(PARAMS(IBEG:IEND-1),'E') .EQ. 0) )THEN
               REG(IREG) = INT(ROP)
            ELSE
               REG(IREG) = ROP
            ENDIF
            IREG = IREG + 1
         ELSE
            CALL TXBEGIN
            WRITE(6,101)PARAMS(IBEG:IEND),IREG
 101        FORMAT(1X,'CANNOT PARSE ',A,' TO NUMERIC FOR REGISTER ',I2)
            CALL TXEND
            SETREGS = .FALSE.
            RETURN
         ENDIF
      ENDIF
      IBEG = IEND + 1
      GOTO 1
 2    CONTINUE
      RETURN
C
C--- DEAL WITH ERRORS.
 900  CONTINUE
      CALL TXBEGIN
      WRITE(6,100)
 100  FORMAT(1X,'EVAL ARG LIST: ARGUMENT TOO LONG.')
      CALL TXEND
      SETREGS = .FALSE.
      RETURN
      END
C
      LOGICAL FUNCTION BBEMPTY( BB )
C----------------------------------------
C RETURN .TRUE. IF BB HAS THE EMPTY BOUNDING BOX PATTERN, ELSE .FALSE.
C NOTE: DO NOT WORRY ABOUT FP CONSTANTS TOO BIG FOR IEEE SINGLE
C PRECISION - THEY ARE REPLACED DURING PRE-PROCESSING IF NEEDED.
C----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL BB(4)
C
      BBEMPTY = (BB(1) .GT. 1.0E299) .AND. (BB(4) .LT. -1.0E299)
      RETURN
      END
C
      INTEGER FUNCTION LSYSTEM( NRULES, NITER, ANGLE,
     +                          STRINGS, STRILEN, REGS )
C-----------------------------------------
C GENERATE AND DRAW AN L-SYSTEM.
C THE AXIOM IS IN STRING REGISTER 1.
C THE RULES ARE IN STRING REGISTERS 2 ... 9 WITH NRULES DEFINED.
C THE ANGLE FOR TURNS IS ANGLE.
C-----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NRULES, NITER, STRILEN(9)
      REAL ANGLE, REGS(9)
      CHARACTER*80 STRINGS(9)
C
      INTEGER NSUBST, NVALID, NSTACK
      PARAMETER(NSUBST=9, NVALID=NSUBST+5, NSTACK=20)
      INTEGER I, J, K, INLUN, OUTLUN, TMPLUN, IPASS, ISTK
      REAL XSTK(NSTACK), YSTK(NSTACK), ASTK(NSTACK), CANGLE
      REAL XPOS, YPOS, XNEW, YNEW, XLO, XHI, YLO, YHI, DANGLE, DX, DY
      LOGICAL CCSUB
      CHARACTER*(NVALID) CVALID
      CHARACTER*(NSUBST) CSUBST
      CHARACTER*1 CC
C
C--- CHECK FORMAT OF THE AXIOM AND RULES
C
      LSYSTEM = 0
      CVALID = 'F:ABCDEMXY+-[]'
      CSUBST = 'ABCDEFMXY'
      IF( STRILEN(1) .EQ. 0 )THEN
         CALL TXBEGIN
         WRITE(6,*)'AXIOM (STRING REGISTER 1) IS EMPTY'
         CALL TXEND
         LSYSTEM = 1
         RETURN
      ENDIF
      DO 3 K=1,STRILEN(1)
         IF( INDEX(CVALID, STRINGS(1)(K:K)) .EQ. 0 )THEN
            CALL TXBEGIN
            WRITE(6,*)'INVALID CHAR ',STRINGS(1)(K:K),' IN AXIOM'
            CALL TXEND
            LSYSTEM = 5
            RETURN
         ENDIF
 3    CONTINUE
      DO 1 I=1,NRULES
         J = I + 1
         IF( STRILEN(J) .LT. 3 )THEN
            CALL TXBEGIN
            WRITE(6,*)'RULE ',I,' (STRING REG ',J,') IS EMPTY OR SHORT'
            CALL TXEND
            LSYSTEM = 2
            RETURN
         ENDIF
         IF( STRINGS(J)(2:2) .NE. ':' )THEN
            CALL TXBEGIN
            WRITE(6,*)'VARIABLE AND SUBSTITUTION MUST HAVE COLON BTW'
            CALL TXEND
            LSYSTEM = 3
            RETURN
         ENDIF
         DO 2 K=1,STRILEN(J)
            IF( INDEX(CVALID, STRINGS(J)(K:K)) .EQ. 0 )THEN
               CALL TXBEGIN
               WRITE(6,*)'INVALID CHAR ',STRINGS(J)(K:K),' IN RULE ',I
               CALL TXEND
               LSYSTEM = 4
               RETURN
            ENDIF
 2       CONTINUE
 1    CONTINUE
C
C--- OPEN TWO SCRATCH FILES ON LUNS 20 AND 21
C
      OPEN(UNIT=20,STATUS='SCRATCH',ERR=5)
      REWIND(UNIT=20)
      GOTO 6
 5    CONTINUE
      CALL TXBEGIN
      WRITE(6,*)'FAILED TO OPEN SCRATCH FILE ON LUN 20'
      CALL TXEND
      LSYSTEM = 6
      RETURN
 6    CONTINUE
      OPEN(UNIT=21,STATUS='SCRATCH',ERR=7)
      REWIND(UNIT=21)
      GOTO 8
 7    CONTINUE
      CLOSE(UNIT=20)
      CALL TXBEGIN
      WRITE(6,*)'FAILED TO OPEN SCRATCH FILE ON LUN 21'
      CALL TXEND
      LSYSTEM = 7
      RETURN
 8    CONTINUE
      OUTLUN = 20
      INLUN = 21
C
C--- INSERT THE AXIOM INTO SCRATCH FILE 1
C
      DO 10 I=1,STRILEN(1)
         WRITE(OUTLUN,100)STRINGS(1)(I:I)
 100     FORMAT(A1)
 10   CONTINUE
      REWIND(UNIT=OUTLUN)
C
C--- APPLY PRODUCTION RULES NITER TIMES.
C
      DO 11 J=1,NITER
         TMPLUN = INLUN
         INLUN = OUTLUN
         OUTLUN = TMPLUN
         REWIND(UNIT=INLUN)
         REWIND(UNIT=OUTLUN)
C
C--- READ EACH CHAR OF INLUN, CHECK RULES FOR SUBSTITUTIONS. APPLY THEM.
C
 12      CONTINUE
         READ(INLUN,100,END=13)CC
         CCSUB = .FALSE.
         DO 14 I=2,NRULES+1
            IF( CC .EQ. STRINGS(I)(1:1) )THEN
               DO 15 K=3,STRILEN(I)
                  WRITE(OUTLUN,100)STRINGS(I)(K:K)
 15            CONTINUE
               CCSUB = .TRUE.
            ENDIF
 14      CONTINUE
         IF( .NOT. CCSUB )THEN
            WRITE(OUTLUN,100)CC
         ENDIF
         GOTO 12
 13      CONTINUE
 11   CONTINUE
C
C--- THE FINAL PRODUCTION IS IN OUTLUN. REWIND IT AND DRAW IT.
C
      DO 90 IPASS=1,2
         REWIND(UNIT=OUTLUN)
         XPOS = REGS(1)
         YPOS = REGS(2)
         CANGLE = 3.141592653 * REGS(3) / 180.0
         DANGLE = 3.141592653 * ANGLE / 180.0
         ISTK = 1
         IF( IPASS .EQ. 1 )THEN
            XLO = XPOS
            YLO = YPOS
            XHI = XPOS
            YHI = YPOS
         ELSE
            CALL OFF2(XPOS, YPOS)
         ENDIF
 20      CONTINUE
            READ(OUTLUN,100,END=21)CC
C           WRITE(6,*)CC
            IF( (CC .EQ. 'F') .OR. (CC .EQ. 'M') )THEN
               XNEW = XPOS + COS(CANGLE)
               YNEW = YPOS + SIN(CANGLE)
               IF( IPASS .EQ. 2 )THEN
                  IF( CC .EQ. 'F' )THEN
                     CALL ON2(XNEW, YNEW)
                  ELSE
                     CALL OFF2(XNEW, YNEW)
                  ENDIF
               ELSE
                  XLO = MIN(XLO, XNEW)
                  YLO = MIN(YLO, YNEW)
                  XHI = MAX(XHI, XNEW)
                  YHI = MAX(YHI, YNEW)
               ENDIF
               XPOS = XNEW
               YPOS = YNEW
            ELSE IF( CC .EQ. '+' )THEN
               CANGLE = CANGLE + DANGLE
            ELSE IF( CC .EQ. '-' )THEN
               CANGLE = CANGLE - DANGLE
            ELSE IF( CC .EQ. '[' )THEN
               IF( ISTK .EQ. NSTACK )THEN
                  CALL TXBEGIN
                  WRITE(6,*)'LSYSTEM - STACK OVERFLOW'
                  CALL TXEND
                  LSYSTEM = 9
                  GOTO 99
               ELSE
                  XSTK(ISTK) = XPOS
                  YSTK(ISTK) = YPOS
                  ASTK(ISTK) = CANGLE
                  ISTK = ISTK + 1
               ENDIF
            ELSE IF( CC .EQ. ']' )THEN
               IF( ISTK .EQ. 1 )THEN
                  CALL TXBEGIN
                  WRITE(6,*)'LSYSTEM - STACK UNDERFLOW'
                  CALL TXEND
                  LSYSTEM = 10
                  GOTO 99
               ELSE
                  ISTK = ISTK - 1
                  XPOS = XSTK(ISTK)
                  YPOS = YSTK(ISTK)
                  CANGLE = ASTK(ISTK)
                  IF( IPASS .EQ. 2 )THEN
                     CALL OFF2(XPOS, YPOS)
                  ENDIF
               ENDIF
            ENDIF
            GOTO 20
 21      CONTINUE
         IF( IPASS .EQ. 1 )THEN
C            CALL TXBEGIN
C            WRITE(6,*)'SETTING BOUNDS TO: ',XLO,XHI,YLO,YHI,' +5%'
C            CALL TXEND
            DX = 0.05 * (XHI - XLO)
            DY = 0.05 * (YHI - YLO)
            CALL BOUNDS(XLO-DX,XHI+DX,YLO-DY,YHI+DY)
         ENDIF
 90   CONTINUE
C
C--- CLEAN UP AND RETURN.
C
 99   CONTINUE
      CLOSE(UNIT=20,ERR=30)
 30   CONTINUE
      CLOSE(UNIT=21,ERR=31)
 31   CONTINUE
      RETURN
      END
C
      SUBROUTINE LDPROC(PRNAME, IPREG, PREGS, IDEV, NDEVS, HAVDEV,
     +     PATHNAM, FULLNAM)
C------------------------------------------------
C TRY TO FIND PRNAME IN GPLPROC. IF FOUND, TRY TO LOAD PROCEDURE INTO
C PROCEDURE REGISTER IPREG
C------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) PRNAME, PATHNAM, FULLNAM
      INTEGER IPREG, IDEV, NDEVS
      CHARACTER*80 PREGS(9)
      LOGICAL HAVDEV
C---
      INTEGER IPFERR, LNBC, LPRNAME, ILINE, LLINE, IFNE
      CHARACTER*80 LINE
      INTEGER MAXFNL
#ifdef PORTF77
      PARAMETER( MAXFNL=72 )
#else
      PARAMETER( MAXFNL=7 )
#endif       
C
C--- GET THE PROCEDURES LIBRARY FILE AS LOCAL.
C
#ifndef PORTF77
      CALL PF('GET','GPLPROC','GPLPROC','NA','IGNR','RC',IPFERR)
#else
      IPFERR = 0
#endif
      IF( IPFERR .NE.0 )THEN
         CALL TXBEGIN
         WRITE(6,*)'CANNOT GET GPLPROC, ERROR = ',IPFERR
         CALL TXEND
         RETURN
      ENDIF
C
C--- OPEN GPLPROC
C
      CALL MKFULNM('GPLPROC',PATHNAM,FULLNAM,MAXFNL,IFNE)
      OPEN(UNIT=30,FILE=FULLNAM(1:IFNE),STATUS='OLD',ERR=1)
      GOTO 2
 1    CONTINUE
      CALL TXBEGIN
      WRITE(6,*)'CANNOT OPEN ',FULLNAM
      CALL TXEND
      RETURN
 2    CONTINUE
      REWIND(UNIT=30)
C
C--- LOOK FOR THE PROCEDURE NAME
C
      CALL UPCASE(PRNAME)
      ILINE = 1
      LPRNAME = LNBC(PRNAME,1,1)
 3    CONTINUE
      READ(30,100,END=4,ERR=5)LINE
 100  FORMAT(A)
      CALL UPCASE(LINE)
      LLINE = LNBC(LINE,1,1)
      IF( LLINE .EQ. LPRNAME )THEN
         IF( LINE(1:LLINE) .EQ. PRNAME(1:LPRNAME) )THEN
            READ(30,100,END=6,ERR=5)LINE
            PREGS(IPREG) = LINE
            GOTO 99
         ENDIF
      ENDIF
      ILINE = ILINE + 1
      GOTO 3
C
C--- DID NOT FIND PROCEDURE CALLED PRNAME
C
 4    CONTINUE
      CALL TXBEGIN
      WRITE(6,*)'PROCEDURE ',PRNAME(1:LPRNAME),' NOT FOUND'
      CALL TXEND
      GOTO 99
C
C--- ERROR READING GPLPROC
C
 5    CONTINUE
      CALL TXBEGIN
      WRITE(6,*)'ERROR READING GPLPROC AT LINE ',ILINE
      CALL TXEND
      GOTO 99
C
C--- PROCEDURE NAME NOT FOLLOWED BY PROCEDURE
C
 6    CONTINUE
      CALL TXBEGIN
      WRITE(6,*)'MISSING PROCEDURE BODY AT LINE ',ILINE
      CALL TXEND
      GOTO 99
C
C--- CLOSE GPLPROC AND RETURN
C
 99   CONTINUE
      CLOSE(UNIT=30,ERR=98)
 98   CONTINUE
      RETURN
      END
C
      SUBROUTINE HTBOX(TEXT, IANGLE, XC, YC, W, H, WI, DH, XBL, XBH,
     +     LHORIZ, LVERT, LINBOX, LFIXED, FSYMHT, LOUTBOX, FSYMHTL)
C------------------------------------
C HATCHED TEXT BOX.
C THIS MAIN PURPOSE OF THIS IS TO PROVIDE A "PRIMITIVE" ELEMENT
C FOR DRAWING BLOCK DIAGRAMS.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) TEXT
      REAL XC, YC, W, H, WI, DH, XBL, XBH, FSYMHT, FSYMHTL
      INTEGER IANGLE
      LOGICAL LHORIZ, LINBOX, LVERT, LFIXED, LOUTBOX
C
      INTEGER MAXLINL, MAXLINS
      PARAMETER( MAXLINL=30, MAXLINS=5 )
      REAL XL, YL, XH, YH, XLI, YLI, XHI, YHI, XP, DXI, TWIDTH, ADJWID
      REAL ADJHI, XPE, YP, YPE, YCUR, ADJHIL, ADJWIL
      REAL STRING
      INTEGER NOCC, NNBC, LNBC, NLINES, IS, IE, NTEXT, LLEN, I, LMAX
      INTEGER ILMAX, L
      CHARACTER*(MAXLINL) LINES(MAXLINS)
C
C FIND THE OUTER BOX CORNERS
      XL = XC - 0.5 * W
      YL = YC - 0.5 * H
      XH = XC + 0.5 * W
      YH = YC + 0.5 * H
C
C SPLIT TEXT INTO LINES AT BACKSLASHES. COUNT LINES.
      NTEXT = LNBC(TEXT,1,0)
      IF( NTEXT .EQ. 0 )GOTO 51
      NLINES = 0
      IS = 1
 10   CONTINUE
      IS = NNBC(TEXT, IS, 0)
      IF( IS .EQ. 0 )GOTO 11
      NLINES = NLINES + 1
      IE = NOCC(TEXT,'\\',IS,NTEXT)
      LLEN = MIN(MAXLINL-1, IE-IS)
      IF( IE .EQ. NTEXT )LLEN = LLEN + 1
      IF( LLEN .EQ. 0 )THEN
         LINES(NLINES) = ' '
      ELSE
         LINES(NLINES) = TEXT(IS:IS+LLEN-1)
      ENDIF
      IF( (NLINES .EQ. MAXLINS) .OR. (IE .EQ. NTEXT) )GOTO 11
      IS = IE + 1
      GOTO 10
 11   CONTINUE
C
C FIND THE LONGEST LINE.
      ILMAX = 0
      LMAX = 0
      DO 20 I=1,NLINES
         L = LEN(LINES(I)(1:LNBC(LINES(I),1,1)))
         IF( L .GT. LMAX )THEN
            ILMAX = I
            LMAX = L
         ENDIF
 20   CONTINUE
C
C TEXT WIDTH AND HEIGHT, ADJWID AND ADJHI.
C THIS IS USED TO FIND THE INNER BOX X COORDS IF FIXED.
C THEY ARE FOUND DIRECTLY FROM WI IF SCALING THE TEXT.
      TWIDTH = STRING(LINES(ILMAX)(1:LNBC(LINES(ILMAX),1,1)))
      IF( LFIXED )THEN
         IF( WI .GT. 0.5 )THEN
            FSYMHTL = H / (WI + 0.05 * H)
         ENDIF
         CALL SYMHT(FSYMHTL)
         ADJWID = FSYMHTL * TWIDTH + 0.03 * W
         ADJHI = FSYMHTL + 0.05 * H
         XLI = XC - 0.5 * ADJWID
         XHI = XC + 0.5 * ADJWID
         ADJWID = ADJWID - 0.03 * W
      ELSE
         XLI = XC - 0.5 * WI
         XHI = XC + 0.5 * WI
         DXI = XHI - XLI
         ADJWID = DXI - 0.05 * DXI
         ADJHI = ADJWID / TWIDTH
      ENDIF
C
C FINALISE INNER BOX Y
      YLI = YC - 0.5 * ADJHI * NLINES
      YHI = YC + 0.5 * ADJHI * NLINES
C
C SET AREAS WE CAN AND CANNOT DRAW IN.
 51   CONTINUE
      CALL PANE(XL,XH,YL,YH)
      IF(NTEXT .GT. 0 )CALL BLANK(XLI,XHI,YLI,YHI)
C
C DRAW OUTER AND MAYBE INNER BOX BOUNDARIES (ANNOT CSG).
      IF( LOUTBOX )CALL OPANE
      IF( LINBOX .AND. (NTEXT .GT. 0) )CALL OBLANK
C
C DRAW HATCHING. (GENERAL CSG).
      IF( LHORIZ )THEN
         XP = XL - ABS(IANGLE * DH)
 1       CONTINUE
         IF( XP .GT. (XH + ABS(IANGLE * DH)) )GOTO 2
         CALL OFF2(XP,YL-0.001)
         XPE = XP + IANGLE * DH
         CALL ON2(XPE,YH+0.001)
         XP = XP + DH
         GOTO 1
 2       CONTINUE
      ENDIF
      IF( LVERT )THEN
         YP = YL - ABS(IANGLE * DH)
 3       CONTINUE
         IF( YP .GT. (YH + ABS(IANGLE * DH)) )GOTO 4
         CALL OFF2(XL-0.001,YP)
         YPE = YP + IANGLE * DH
         CALL ON2(XH+0.001,YPE)
         YP = YP + DH
         GOTO 3
 4       CONTINUE
      ENDIF
      IF( NTEXT .EQ. 0 )GOTO 52
C
C ENABLE DRAWING IN THE INNER BOX.
      CALL ENBLNK
C
C DRAW TEXT IN THE INNER BOX (TEXT CSG).
      IF( LFIXED )ADJHI = ADJHI - 0.05 * H
      YCUR = YC + 0.5 * (NLINES-1) * ADJHI - 0.5 * FSYMHTL
      DO 30 I=1,NLINES
         TWIDTH = STRING(LINES(I)(1:LNBC(LINES(I),1,1)))
         IF( LFIXED )THEN
            ADJWIL = FSYMHTL * TWIDTH
         ELSE
            ADJWIL = ADJWID
            ADJHIL = ADJWID / TWIDTH
            CALL SYMHT(ADJHIL)
         ENDIF
         CALL OFF2(XC-ADJWIL/2,YCUR)
         CALL SYMTXT(LINES(I)(1:LNBC(LINES(I),1,1)))
         YCUR = YCUR - ADJHI
 30   CONTINUE
C
C RESTORE THE ORIGINAL SYMHT WHICH MAY HAVE BEEN ADJUSTED HERE.
 52   CONTINUE
      CALL SYMHT(FSYMHT)
C
C ALLOW DRAWING ANYWHERE IN BOUNDS AGAIN.
      CALL ENPANE
C
      RETURN
      END
C
      SUBROUTINE ARROWL( X1, Y1, X2, Y2, SMODE, EMODE,
     +     ASIZE, ASHARP, BARB, ISTYLE, CANNOT,
     +     SKIPSCL, ANNSCL, FSYMHT)
C------------------------------------
C DRAW A LINE (X1,Y1) TO (X2,Y2) WITH VARIOUS OPTIONAL DECORATIONS.
C THE START DECORATIONS ARE CONTROLLED BY SMODE AND THE END DECORATIONS
C BY EMODE. VALID OPTIONS ARE:
C  0 : NO DECORATION
C  1 : SKIP (A "HUMP" THAT CAN APPEAR TO SKIP OVER ANOTHER LINE).
C  2 : ARROW
C THE ARROWS AND SKIPS ARE AUTOMATICALLY ORIENTED APPROPRIATE TO BEING
C AT THE START OR END OF THE LINE.
C THE STYLE OF ARROW HAS THE FOLLOWING APPEARENCE CONTROLS:
C  ASIZE : ARROW SIZE (MAX LENGTH IN BOUNDS UNITS, MAYBE AUTO ADJUSTED).
C  ASHARP : ARROW SHARPNESS (0.5 (FLATTEST) TO 5 (SHARPEST), 2 GOOD).
C  BARB : HOW LONG THE BARBS ARE FOR BARBED ARROW STYLE. 0.3 GOOD.
C  ISTYLE : 0 : OPEN, 1 : CLOSED, 2 : BARBED.
C A (SHORT!) ANNOTATION FOR THE LINE CAN BE SUPPLIED IN CANNOT.
C IF THIS IS ALL BLANK, NO ANNOTATION IS DRAWN. OTHERWISE, THE TEXT
C IN CANNOT IS DRAWN IN A CIRCLE IN THE MIDDLE OF THE LINE.
C THE SIZE OF "SKIPS" IS SET AS A FRACTION OF ASIZE BY SKIPSCL.
C THE SIZE OF THE ANNOTATION IS SET AS A FRACTION OF ASIZE BY ANNSCL.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL X1, Y1, X2, Y2, ASIZE, ASHARP, FSYMHT, BARB, SKIPSCL, ANNSCL
      INTEGER SMODE, EMODE, ISTYLE
      CHARACTER*(*) CANNOT
C
      REAL LLEN, DX, DY, TARW, NX, NY, XPE, YPE, XPS, YPS
      REAL XC, YC, ASHARPL, XS, YS, ASIZEL, TWIDTH, CSIZE
      REAL SKIPTAB(5), DXS, DYS, BARBL
      INTEGER LNBC, NANNOT, I
      REAL STRING
      REAL MAXART, CSHRINK
      PARAMETER( MAXART=0.33, CSHRINK=0.7 )
      SAVE SKIPTAB
      DATA SKIPTAB/0.0000,0.4375,0.7500, 0.9375, 1.0000/
C
C KEEP ARROW "SHARPNESS" AND ARROW "BARB" WITHIN REASONABLE LIMITS.
      ASHARPL = MAX(0.5, MIN(5.0, ASHARP))
      BARBL = MAX(0.05, MIN(0.95, BARB))
C      print *,asize,asharp,barb,istyle,skipscl,annscl
C
C FIND LINE DELTAS AND LENGTH. IF VERY SHORT, DO NOTHING.
      DX = X2 - X1
      DY = Y2 - Y1
      LLEN = SQRT(DX**2 + DY**2)
      IF( LLEN .LT. 1E-4 )RETURN
C
C IF THE ARROW SIZE IS LONGER THAN A FRACTION OF THE LENGTH, REDUCE IT.
      IF( ASIZE .GT. (MAXART*LLEN) )THEN
         ASIZEL = MAXART * LLEN
      ELSE
         ASIZEL = ASIZE
      ENDIF
C
C FIND LINE T PARAM FOR ARROW SIZE. FIND UNIT NORMAL TO LINE.
      TARW = MIN( ASIZEL / LLEN, MAXART )
      NX = DY / LLEN
      NY = DX / LLEN
C
C START AND END POINTS OF THE "MAIN" LINE. MAY BE UPDATED.
      XPS = X1
      YPS = Y1
      XPE = X2
      YPE = Y2
C
C START DECORATIONS.
C
      IF( SMODE .EQ. 1 )THEN
C
C DRAW A SKIP AT THE START.
         XPS = X1 + TARW * DX * SKIPSCL
         YPS = Y1 + TARW * DY * SKIPSCL
         DXS = (X1 - XPS) / 4.0
         DYS = (Y1 - YPS) / 4.0
         XC = XPS
         YC = YPS
         DO 2 I=1,5
            XS = XC - NX * SKIPTAB(I) * ASIZEL / ASHARPL * SKIPSCL
            YS = YC + NY * SKIPTAB(I) * ASIZEL / ASHARPL * SKIPSCL
            IF( I .EQ. 1 )THEN
               CALL OFF2(XS,YS)
            ELSE
               CALL ON2(XS,YS)
            ENDIF
            XC = XC + DXS
            YC = YC + DYS
 2       CONTINUE
C
      ELSE IF( SMODE .EQ. 2 )THEN
C
C DRAW AN ARROW AT THE START.
         XPS = X1 + TARW * DX
         YPS = Y1 + TARW * DY
         XC = XPS + ASIZEL * NX / ASHARPL
         YC = YPS - ASIZEL * NY / ASHARPL
         XS = XC
         YS = YC
         CALL OFF2(XC,YC)
         CALL ON2(X1,Y1)
         XC = XPS - ASIZEL * NX / ASHARPL
         YC = YPS + ASIZEL * NY / ASHARPL
         CALL ON2(XC,YC)
         IF( ISTYLE .EQ. 1 )THEN
C           CLOSED ARROW.
            CALL ON2(XS,YS)
         ELSE IF( ISTYLE .EQ. 2 )THEN
C           BARBED ARROW.
            XPS = X1 + (TARW - BARBL * TARW) * DX
            YPS = Y1 + (TARW - BARBL * TARW) * DY
            CALL ON2(XPS,YPS)
            CALL ON2(XS,YS)
         ELSE
            XPS = X1
            YPS = Y1
         ENDIF
      ENDIF
C
C END DECORATIONS.
C
      IF( EMODE .EQ. 1 )THEN
C
C DRAW A SKIP AT THE END.
         XPE = X2 - TARW * DX * SKIPSCL
         YPE = Y2 - TARW * DY * SKIPSCL
         DXS = (X2 - XPE) / 4.0
         DYS = (Y2 - YPE) / 4.0
         XC = XPE
         YC = YPE
         DO 1 I=1,5
            XS = XC - NX * SKIPTAB(I) * ASIZEL / ASHARPL * SKIPSCL
            YS = YC + NY * SKIPTAB(I) * ASIZEL / ASHARPL * SKIPSCL
            IF( I .EQ. 1 )THEN
               CALL OFF2(XS,YS)
            ELSE
               CALL ON2(XS,YS)
            ENDIF
            XC = XC + DXS
            YC = YC + DYS
 1       CONTINUE
C
      ELSE IF( EMODE .EQ. 2 )THEN
C
C DRAW ARROW AT END.
         XPE = X2 - TARW * DX
         YPE = Y2 - TARW * DY
         XC = XPE + ASIZEL * NX / ASHARPL
         YC = YPE - ASIZEL * NY / ASHARPL
         XS = XC
         YS = YC
         CALL OFF2(XC,YC)
         CALL ON2(X2,Y2)
         XC = XPE - ASIZEL * NX / ASHARPL
         YC = YPE + ASIZEL * NY / ASHARPL
         CALL ON2(XC,YC)
         IF( ISTYLE .EQ. 1 )THEN
C           CLOSED ARROW.
            CALL ON2(XS,YS)
         ELSE IF( ISTYLE .EQ. 2 )THEN
C           BARBED ARROW.
            XPE = X2 - (TARW - BARBL * TARW) * DX
            YPE = Y2 - (TARW - BARBL * TARW) * DY               
            CALL ON2(XPE,YPE)
            CALL ON2(XS,YS)
         ELSE
            XPE = X2
            YPE = Y2
         ENDIF
      ENDIF
C
C IS THE LINE ANNOTATED? IF SO, PUT THE ANNOTATION IN A CIRCLE
C IN THE MIDDLE OF THE LINE. DRAW THE JOINING LINE IN 2 HALVES.
      NANNOT = LNBC(CANNOT,1,0)
      IF( NANNOT .GT. 0 )THEN
         ASIZEL = ASIZEL * ANNSCL
         TARW = 0.5 * ASIZEL / LLEN
         XC = X1 + 0.5 * DX
         YC = Y1 + 0.5 * DY
         CALL CIRCLE(XC,YC,0.5*ASIZEL)
         XS = X1 + (0.5-TARW) * DX
         YS = Y1 + (0.5-TARW) * DY
         CALL OFF2(XPS,YPS)
         CALL ON2(XS,YS)
         XS = X1 + (0.5+TARW) * DX
         YS = Y1 + (0.5+TARW) * DY
         CALL OFF2(XS,YS)
         CALL ON2(XPE,YPE)
         TWIDTH = STRING(CANNOT(1:NANNOT))
         CSIZE = CSHRINK * ASIZEL / TWIDTH
         CALL SYMHT(CSIZE)
         CALL OFF2(XC-0.5*CSHRINK*ASIZEL,YC-0.5*CSIZE)
         CALL SYMTXT(CANNOT(1:NANNOT))
         CALL SYMHT(FSYMHT)
C
C DRAW LINE JOINING ARROW HEADS OR SKIPS, APPROPRIATE TO STYLE.
      ELSE
         CALL OFF2(XPS,YPS)
         CALL ON2(XPE,YPE)
      ENDIF
C
      RETURN
      END
C
      SUBROUTINE DECLPT( PDESC, T, X, Y, A, IERR )
C------------------------------------
C PARSE A DECORATED LINE POINT SPECIFICATION.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) PDESC
      INTEGER T, IERR
      REAL X, Y
      CHARACTER*(*) A
C
      INTEGER LPDESC, IC, ICA
      INTEGER NOCC
      CHARACTER*1 TC
C
C GET THE DESCRIPTION LENGTH AND CHECK IT IS SANE.
      LPDESC = LEN(PDESC)
      IERR = 0
      IF( LPDESC .LT. 4 )THEN
         IERR = 1
         CALL TXBEGIN
         WRITE(6,100)
 100     FORMAT(1X,'POINT DESC TOO SHORT.')
         CALL TXEND
         RETURN
      ENDIF
C
C GET THE DECORATION TYPE.
      TC = PDESC(1:1)
      CALL UPCASE(TC)
      IF( TC .EQ. 'P' )THEN
         T = 0
      ELSE IF( TC .EQ. 'S' )THEN
         T = 1
      ELSE IF( TC .EQ. 'A' )THEN
         T = 2
      ELSE
         IERR = 2
         CALL TXBEGIN
         WRITE(6,101)
 101     FORMAT(1X,'UNKNOWN TYPE IN POINT DESC.')
         CALL TXEND
         RETURN
      ENDIF
C
C TRY TO GET THE X COORDINATE.
      IC = NOCC(PDESC,',',2,0)
      IF( IC .EQ. 0 )THEN
         IERR = 3
         CALL TXBEGIN
         WRITE(6,102)
 102     FORMAT(1X,'NO COMMA IN POINT DESC.')
         CALL TXEND
         RETURN
      ENDIF
      IF( .NOT. RFROMC(PDESC,X,2,IC-1) )THEN
         IERR = 4
         CALL TXBEGIN
         WRITE(6,103)
 103     FORMAT(1X,'INVALID X IN POINT DESC.')
         CALL TXEND
         RETURN
      ENDIF
C
C SEE IF THERE IS A SECOND COMMA. IF SO GET THE ANNOTATION
C STRING THAT SHOULD FOLLOW IT. ELSE SET ANNOTATION BLANK.
      ICA = NOCC(PDESC,',',IC+1,LPDESC)
      IF( ICA .NE. LPDESC )THEN
         A = PDESC(ICA+1:LPDESC)
         ICA = ICA - 1
      ELSE
         A = ' '
      ENDIF
C
C GET THE Y COORDINATE.
      IF( .NOT. RFROMC(PDESC,Y,IC+1,ICA) )THEN
         IERR = 5
         CALL TXBEGIN
         WRITE(6,104)
 104     FORMAT(1X,'INVALID Y IN POINT DESC.')
         CALL TXEND
         RETURN
      ENDIF
C
      RETURN
      END
C
      SUBROUTINE DECLINE( DESC,
     +     IARTYPE, ARSIZE, ARSHARP, ARBARB, ANSKPSL, ANSCALE, FSYMHT )
C------------------------------------
C DRAW A DECORATED LINE DESCRIBED BY THE STRING DESC.
C EACH POINT IS DESCRIBED BY: <T>X,Y[,A] WHERE
C T GIVES THE DECORATION TYPE:
C P=PLAIN, A=ARROW, S=SKIP
C X,Y ARE BOUNDS COORDINATES FOR THE POINT.
C A IS AN OPTIONAL TEXT LABEL FOR THE LINE SEGMENT.
C POINT DESCRIPTIONS ARE SEPARATED BY > OR : CHARACTERS.
C THERE MUST BE AT LEAST 2 POINT DESCRIPTIONS IN DESC.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) DESC
      INTEGER IARTYPE
      REAL ARSIZE, ARSHARP, ARBARB, ANSKPSL, ANSCALE, FSYMHT
C
      INTEGER MAXPTS
      PARAMETER( MAXPTS=10 )
C
      INTEGER PTSTRT(MAXPTS), NPTS, IE, IS, I, IOFF
      INTEGER LDESC, SMODE, EMODE, IERRS, IERRE, IN, IEU, INU
      REAL XS, YS, XE, YE
      CHARACTER*5 ANNOT
      INTEGER NOCC, LNBC
C
C FIND START OF EACH POINT DESCRIPTION IN DESC.
      LDESC = LNBC(DESC,1,0)
      IF( LDESC .EQ. 0 )RETURN
      PTSTRT(1) = 1
      NPTS = 1
      IS = 1
 1    CONTINUE
      IE = NOCC(DESC,':>',IS,LDESC)
      IF( (IE .EQ. LDESC) .AND. (NPTS .EQ. 1) )THEN
         CALL TXBEGIN
         WRITE(6,100)
 100     FORMAT(1X,'ONLY A SINGLE POINT IN A DECORATED LINE.')
         CALL TXEND
         RETURN
      ENDIF
      IS = IE + 1
      IF( NPTS .LT. MAXPTS )THEN
         NPTS = NPTS + 1
         PTSTRT(NPTS) = IS
      ELSE
         CALL TXBEGIN
         WRITE(6,101)MAXPTS
 101     FORMAT(1X,'TOO MANY PTS FOR DECORATED LINE. MAX: ',I3)
         CALL TXEND
         RETURN
      ENDIF
      IF( IE .EQ. LDESC )GOTO 2
      GOTO 1
 2    CONTINUE
C
C STEP OVER SUCCESSIVE PAIRS OF POINTS. PARSE THEM.
C DRAW A DECORATED LINE FOR EACH POINT PAIR.
      DO 3 I=1,NPTS-2
         IS = PTSTRT(I)
         IE = PTSTRT(I+1)
         IN = PTSTRT(I+2)
         INU = IN
         IOFF = 2
         IEU = IE - IOFF
         IF( I .EQ. (NPTS-2) )IOFF = 1
         INU = IN - IOFF
         CALL DECLPT(DESC(IS:IEU), SMODE, XS, YS, ANNOT, IERRS )
         CALL DECLPT(DESC(IE:INU), EMODE, XE, YE, ANNOT, IERRE )
         CALL ARROWL(XS,YS, XE,YE, SMODE, EMODE, 
     +     ARSIZE, ARSHARP, ARBARB, IARTYPE, ANNOT,
     +     ANSKPSL, ANSCALE, FSYMHT)
 3    CONTINUE
      RETURN
      END
C
      SUBROUTINE GLABEL( GX, GY, BL, ANGLE, TEXT, FSYMHT, LUBC,
     + IARTYPE, ARSIZE, ARSHARP, ARBARB, ANSKPSL, ANSCALE )
C------------------------------------
C LABEL A POINT ON A GRAPH (GX,GY) BY POINTING AN
C ARROW AT IT. THE LENGTH OF THE ARROW IS BL IN BOUNDS UNITS.
C IT IS ROTATED ANGLE DEGREES (FROM +X). THE TEXT IS PLACED
C APPROPRIATELY AT THE END OF THIS ARROW IN A BOX.
C FSYMHT IS THE CURRENT SYMBOL HEIGHT.
C LUBC IS .TRUE. IF (GX,GY) IS IN BOUNDS COORDS INSTEAD OF GRAPH.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL GX, GY, BL, ANGLE, FSYMHT
      CHARACTER*(*) TEXT
      LOGICAL LUBC
      INTEGER IARTYPE
      REAL ARSIZE, ARSHARP, ARBARB, ANSKPSL, ANSCALE
C
      REAL BX, BY, EX, EY, SBW, SBH, XBL, YBL, DX, DY, TW, TX, TY
      REAL STRING
      INTEGER LNBC
C
C FIND WHERE THE GRAPH COORDINATE IS IN BOUNDS SPACE.
      IF( LUBC )THEN
         BX = GX
         BY = GY
      ELSE
         CALL GRTOAC(GX, GY, BX, BY)
      ENDIF
C
C FIND THE BOUNDS COORDINATE OF THE OTHER END OF THE LINE.
C TREAT THIS AS THE CENTER OF A BOX THAT ENCLOSES THE TEXT.
      EX = BL * COS(ANGLE * 6.283 / 360.0) + BX
      EY = BL * SIN(ANGLE * 6.283 / 360.0) + BY
C
C IF THE TEXT IS ENTIRELY BLANK, JUST DRAW THE ARROW.
      IF( LNBC(TEXT,1,0) .EQ. 0 )GOTO 1
C
C GET THE WIDTH AND HEIGHT OF A BOX FOR THE TEXT.
      SBH = 1.05 * FSYMHT
      SBW = SBH * STRING(TEXT)
C
C BASED ON ANGLE, WORK OUT HOW TO DISPLACE THE BOX SO THAT
C EX,EY TOUCHES AN APPROPRIATE EDGE OF THE BOX.
      ANGLE = MIN(360.0, MAX(0.0, ANGLE))
      IF( ANGLE .LT. 45.0 )THEN
         DX = 0.5 * SBW
         DY = (ANGLE / 90.0) * SBH
      ELSE IF( ANGLE .LT. 135.0 )THEN
         DX = (90.0 - ANGLE) / 90.0 * SBW
         DY = 0.5 * SBH
      ELSE IF( ANGLE .LT. 225.0 )THEN
         DX = -0.5 * SBW
         DY = (180.0 - ANGLE) / 90.0 * SBH
      ELSE IF( ANGLE .LT. 315.0 )THEN
         DX = (ANGLE - 270.0) / 90.0 * SBW
         DY = -0.5 * SBH
      ELSE
         DX = 0.5 * SBW
         DY = (ANGLE - 360.0) / 90.0 * SBH
      ENDIF
C
C DRAW THE TEXT ENCLOSING BOX.
      XBL = EX - 0.5 * SBW + DX
      YBL = EY - 0.5 * SBH + DY
      CALL RECT(XBL,YBL,0.0,SBW,SBH)
C
C DRAW THE TEXT.
      TX = XBL + 0.5 * SBW
      TY = YBL + 0.5 * SBH
      TW = FSYMHT * STRING(TEXT)
      TX = TX - 0.5 * TW
      TY = TY - 0.5 * FSYMHT
      CALL OFF2(TX, TY)
      CALL SYMTXT(TEXT)
C
C DRAW THE ARROW.
 1    CONTINUE
      CALL ARROWL(BX, BY, EX, EY, 2, 0,
     +     ARSIZE, ARSHARP, ARBARB, IARTYPE, ' ',
     +     ANSKPSL, ANSCALE, FSYMHT)
C
      RETURN
      END
C
      INTEGER FUNCTION SRTCMP( A1, A2 )
C------------------------------------
C COMPARE TWO CHARACTER VARIABLES.
C RETURN 0 IF A1 .EQ. A2.
C RETURN -1 IF A1 .LT. A2 LEXICALLY.
C RETURN +1 IF A1 .GT. A2 LEXICALLY.
C IF STRINGS MATCH UP TO THE LENGTH OF THE
C SHORTEST, THE SHORTER IS .LT. THE LONGER.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) A1, A2
C
      INTEGER LA1, LA2, I
      INTEGER LNBC
C
C CHECK IF ONE OR BOTH STRINGS ARE ENTIRELY BLANK.
C IF SO, ANY NON-BLANK IS .GT. THAN THE BLANK ONE.
      LA1 = LNBC(A1,1,0)
      LA2 = LNBC(A2,1,0)
      IF( (LA1 .EQ. 0) .AND. (LA2 .EQ. 0) )THEN
         SRTCMP = 0
         RETURN
      ELSE IF( (LA1 .EQ. 0) .AND. (LA2 .GT. 0) )THEN
         SRTCMP = -1
         RETURN
      ELSE IF( (LA1 .GT. 0) .AND. (LA2 .EQ. 0) )THEN
         SRTCMP = 1
         RETURN
      ENDIF
C
C COMPARE CHARACTER BY CHARACTER OVER THE MINIMUM OF THE LENGTHS.
      DO 1 I=1,MIN(LA1,LA2)
         IF( A1(I:I) .NE. A2(I:I) )GOTO 2
 1    CONTINUE
C
C EQUAL OVER THE SHARED LENGTH. DECIDE BASED ON LENGTH.
      IF( LA1 .EQ. LA2 )THEN
         SRTCMP = 0
      ELSE IF( LA1 .LT. LA2 )THEN
         SRTCMP = -1
      ELSE
         SRTCMP = 1
      ENDIF
      RETURN
C
C SOME CHARACTER IN SHARED LENGTH DIFFERS. DECIDE BASED ON THAT.
 2    CONTINUE
      IF( A1(I:I) .LT. A2(I:I) )THEN
         SRTCMP = -1
      ELSE
         SRTCMP = 1
      ENDIF
      RETURN
      END
C
      SUBROUTINE SORTIDX( SARRAY, N, INDEXS )
C------------------------------------
C CREATE AND SORT AN ARRAYS OF INDICES INTO AN ARRAY OF
C N CHARACTER STRINGS, SARRAY(N).
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      CHARACTER*(*) SARRAY(N)
      INTEGER INDEXS(N)
C
      INTEGER I, J, JG, GAP, ITEMP
      INTEGER SRTCMP
C
      DO 1 I=1,N
         INDEXS(I) = I
 1    CONTINUE
C
C---- FOR( GAP=N/2; GAP > 0; GAP = GAP/2 )
      GAP = N / 2
 2    CONTINUE
         IF( GAP .LE. 0 )GOTO 3
C
C----    FOR( I=GAP+1; I <= N; I = I + 1 )
         I = GAP + 1
 4       CONTINUE
            IF( I .GT. N )GOTO 5
C
C----       FOR( J=I-GAP; J > 0; J -= GAP )
            J = I - GAP
 6          CONTINUE
            IF( J .LE. 0 )GOTO 7
               JG = J + GAP
C
C---- COMPARE AARRAY(J) AND AARRAY(JG)
C---- SWAP IF AARRAY(JG) > AARRAY(J).
               IF( SRTCMP(SARRAY(INDEXS(J)),
     +              SARRAY(INDEXS(JG))) .LE. 0 )GOTO 7
               ITEMP = INDEXS(J)
               INDEXS(J) = INDEXS(JG)
               INDEXS(JG) = ITEMP
               J = J - GAP
               GOTO 6
 7          CONTINUE
            I = I + 1
            GOTO 4
 5       CONTINUE
         GAP = GAP / 2
         GOTO 2
 3    CONTINUE
      RETURN
      END
C
      SUBROUTINE VERSION( OUTSTR )
C------------------------------------
C GET THE VERSION NUMBER OF GPLOT.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*4 OUTSTR
C
      OUTSTR = '0.76'
      RETURN
      END
C
      SUBROUTINE GETVRI( OUTSTR )
C------------------------------------
C GET SOME VERSION, OS AND RUN TIME INFORMATION.
C OUTPUT VARIES BY OPERATING SYSTEM.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*80 OUTSTR
C
      CHARACTER*4 VERSTR
C
#ifdef UNIX
      INTEGER DMY(3)
      CALL IDATE(DMY)
      CALL VERSION(VERSTR)
      WRITE(OUTSTR,100)VERSTR, DMY(1), DMY(2), DMY(3)
 100  FORMAT('GPLOT V',A4,' FOR UNIX-LIKE SYSTEMS. RUN DATE: ',
     +     I2,'/',I2.2,'/',I4)
#endif
#ifndef PORTF77
      CHARACTER*10 DATE
      CALL VERSION(VERSTR)
      WRITE(OUTSTR,100)VERSTR, DATE()
 100  FORMAT('GPLOT V',A4,' FOR CDC NOS 2.8.7  RUN DATE: ',A10)
#endif
C
      RETURN
      END
C
      SUBROUTINE MKFULNM( FILENAM, PATHNAM, FULLNAM, MAXFNL, IFNE )
C------------------------------------
C POTENTIALLY ADD A PATH NAME AS A PREFIX TO A FILE NAME AND
C AND RETURN THE RESULT. RETURN THE LENGTH OF THE FULL NAME
C WITHOUT TRAILING BLANKS.
C THIS JUST RETURNS FILENAM ON NOS, WHERE LONGER PATHS ARE
C MEANINGLESS.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) FILENAM, PATHNAM, FULLNAM
      INTEGER MAXFNL, IFNE
C
      INTEGER LFILE, LPATH, LFULL, LUSED
      INTEGER LNBC
C
      FULLNAM = ' '
#ifdef UNIX
      LFILE = LNBC(FILENAM,1,1)
      LPATH = LNBC(PATHNAM,1,0)
      LFULL = LEN(FULLNAM)
      LUSED = LFILE + LPATH + 1
      IF( LUSED .GT. LFULL )THEN
         CALL TXBEGIN
         WRITE(6,100)
 100     FORMAT(1X,'WARNING: FILE PATH + NAME TOO LONG. PATH IGNORED.')
         CALL TXEND
      ENDIF
      IF( (LPATH .EQ. 0) .OR. (LUSED .GT. LFULL) )THEN
         FULLNAM = FILENAM
      ELSE
         FULLNAM(1:LPATH) = PATHNAM(1:LPATH)
         LPATH = LPATH + 1
         FULLNAM(LPATH:LPATH) = '/'
         LPATH = LPATH + 1
         FULLNAM(LPATH:LUSED) = FILENAM(1:LFILE)
      ENDIF
#else
      FULLNAM = FILENAM
#endif
      IFNE = MIN(LNBC(FULLNAM,1,1), MAXFNL)
C
      RETURN
      END
#ifdef PORTF77
C     WARNING - DO NOT LEAVE A BLANK LINE BEFORE
C     THE IFDEF OR FTN5 WILL COMPLAIN.
C     NOR A COMMENT LINE!
      INTEGER FUNCTION LOCF(D)
C----
C     PRETEND TO RETURN ADDRESS OF D. ALWAYS RETURN 0.
C----
      REAL D
C
      LOCF = 0
      RETURN
      END

      SUBROUTINE CMMFRF(IFWA)
C----
C     PRETEND TO FREE MEMORY AT ADDRESS IFWA. DO NOTHING.
C----
      INTEGER IFWA
C
      RETURN
      END

      SUBROUTINE CMMGFS(I1,I0,NAVAIL)
C----
C     PRETEND TO RETURN THE NUMBER OF AVAIALBLE WORDS.
C     DO NOTHING. FOR PORTF77, NAVAIL IS
C     SET TO THE MAXIMUM AVAILABLE AND THIS IS NOT CALLED.
C----
      INTEGER I0, I1, NAVAIL
C
      RETURN
      END

      SUBROUTINE CMMALF(NWORDS,I0,I00,IFWA)
C----
C     PRETEND TO DYNAMICALLY ALLOCATE NWORDS OF MEMORY.
C     RETURN THE START ADDRESS IN IFWA (ALWAYS 0).
C----
      INTEGER NWORDS, I0, I00, IFWA
C
      IFWA = 0
      RETURN
      END
#endif
