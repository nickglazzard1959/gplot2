      PROGRAM GPLOT(INPUT=/80,OUTPUT=/132,TAPE7=INPUT,TAPE6=OUTPUT)
C ===================================================
C  GPLOT - DIMFILM BASED INTERACTIVE PLOTTING PROGRAM
C ===================================================
      IMPLICIT LOGICAL (A-Z)
      INTEGER NCMDS, NDEVS, MAXARG, NGRD, MAXDEP
      INTEGER NSTY, NPOL, NHIST, MAXSTK, NREGS
      INTEGER NFONTS, NGSTY
      PARAMETER( NCMDS=78, NDEVS=5, MAXARG=6, NGRD=4, MAXDEP=5 )
      PARAMETER( NSTY=4, NPOL=3, NHIST=5, MAXSTK=9, NREGS=9, NGSTY=3 )
      PARAMETER( NFONTS=24 )
C
C COMMAND CODES.
C
      INTEGER KDEV, KMAXPT, KCOL, KWID, KMARK
      INTEGER KCLR, KMOVE, KDRAW, KTEXT, KREAD
      INTEGER KXYPT, KXYLN, KXYAUT, KXRAN, KYRAN
      INTEGER KXYSAM, KXLIN, KYLIN, KXLOG, KYLOG
      INTEGER KXYGRD, KOBEY, KEXIT, KHELP, KBOUND
      INTEGER KTIT, KXLAB, KYLAB, KTEST, KSTYLE
      INTEGER KGET, KSTAT, KANNOT, KFLOG, KINTERP
      INTEGER KEBASM, KHIST, KHISTMD, KPANE, KUNP
      INTEGER KPANEO, KBLNK, KUNBL, KBLNKO, KFILL
      INTEGER KROUTE, KEVAL, KERNG, KPATH, KGRMOVE
      INTEGER KGRDRAW, KNSTACK, KIEVAL, KPROC, KSTO
      INTEGER KRCL, KCANVAS, KCTEXT, KFONT, KLFONT
      INTEGER KSYMHT, KSYMANG, KSTRING, KZERO, KGSTY
      INTEGER KRYLAB, KGRIGHT, KGAXCUT, KCIRC, KARC
      INTEGER KRECT, KCRECT, KBSTAR, KBEND, KBSET
      INTEGER KLSYS, KLDPROC, KTXBOX
      PARAMETER( KDEV=1, KMAXPT=2, KCOL=3, KWID=4, KMARK=5 )
      PARAMETER( KCLR=6, KMOVE=7, KDRAW=8, KTEXT=9, KREAD=10 )
      PARAMETER( KXYPT=11, KXYLN=12, KXYAUT=13, KXRAN=14, KYRAN=15 )
      PARAMETER( KXYSAM=16, KXLIN=17, KYLIN=18, KXLOG=19, KYLOG=20 )
      PARAMETER( KXYGRD=21, KOBEY=22, KEXIT=23, KHELP=24, KBOUND=25 )
      PARAMETER( KTIT=26, KXLAB=27, KYLAB=28, KTEST=29, KSTYLE=30 )
      PARAMETER( KGET=31, KSTAT=32, KANNOT=33, KFLOG=34, KINTERP=35 )
      PARAMETER( KEBASM=36, KHIST=37, KHISTMD=38, KPANE=39, KUNP=40 )
      PARAMETER( KPANEO=41, KBLNK=42, KUNBL=43, KBLNKO=44, KFILL=45 )
      PARAMETER( KROUTE=46, KEVAL=47, KERNG=48, KPATH=49, KGRMOVE=50 )
      PARAMETER( KGRDRAW=51, KNSTACK=52, KIEVAL=53, KPROC=54, KSTO=55 )
      PARAMETER( KRCL=56, KCANVAS=57, KCTEXT=58, KFONT=59, KLFONT=60 )
      PARAMETER( KSYMHT=61, KSYMANG=62, KSTRING=63, KZERO=64, KGSTY=65 )
      PARAMETER( KRYLAB=66, KGRIGHT=67, KGAXCUT=68, KCIRC=69, KARC=70 )
      PARAMETER( KRECT=71, KCRECT=72, KBSTAR=73, KBEND=74, KBSET=75 )
      PARAMETER( KLSYS=76, KLDPROC=77, KTXBOX=78 )
C
C DEVICE CODES.
C
      INTEGER KDGT, KDTK, KDEC, KDEB, KSVG
      PARAMETER( KDGT=1, KDTK=2, KDEC=3, KDEB=4, KSVG=5 )
C
C GRID MODE CODES.
C
      INTEGER KGNO, KGX, KGY, KGXY
      PARAMETER( KGNO=1, KGX=2, KGY=3, KGXY=4 )
C
C LINE STYLE CODES.
C
      INTEGER KSOLID, KDASH, KDOT, KDSHDOT
      PARAMETER( KSOLID=1, KDASH=2, KDOT=3, KDSHDOT=4 )
C
C INTERPOLATION MODES.
C
      INTEGER KILIN, KICUB, KIQUIN
      PARAMETER( KILIN=1, KICUB=2, KIQUIN=3 )
C
C HISTOGRAM MODES.
C
      INTEGER KHABUT, KHABUTS, KHLINE, KHWID, KHWIDS
      PARAMETER( KHABUT=1, KHABUTS=2, KHLINE=3, KHWID=4, KHWIDS=5)
C
C GRAPH STYLES.
C
      INTEGER KGNORM, KGOPEN, KGAXES
      PARAMETER( KGNORM=1, KGAXES=2, KGOPEN=3 )
C
C LIMITS AND DEFAULTS
C
      INTEGER MAXPTS, NDEFPTS
      PARAMETER( MAXPTS=10000, NDEFPTS=1000 )
C
C VARIABLES.
C
      CHARACTER*15 CMDS(NCMDS)
      CHARACTER*125 DCMDS(NCMDS)
      CHARACTER*6 DEVNAM(NDEVS)
      CHARACTER*72 DDEVS(NDEVS)
      CHARACTER*4 GRDNAM(NGRD)
      CHARACTER*80 ARGS(MAXARG), KEY, VALUE
      CHARACTER*80 OBPSTK(MAXDEP)
      CHARACTER*7 STYNAM(NSTY)
      CHARACTER*7 POLNAM(NPOL)
      CHARACTER*7 GSTYNAM(NGSTY)
      CHARACTER*20 HISTNAM(NHIST)
      INTEGER NARGS(NCMDS), NDARGS(NCMDS)
      INTEGER INUNIT, IDEV, MARKNUM, INTERPM
      CHARACTER*80 INLINE, CMD, ARGSTR, CCLINE
      CHARACTER*80 TITLE, XLABEL, YLABEL, ROUTE, RYLABEL
      LOGICAL HAVARG, OBCARD, HAVDATA, HAVDEV, HAVYE, AUTOGET, SLIDE
      LOGICAL HAVTIT, HAVXLAB, HAVYLAB, DOGRID, HAVXE, LBLNK, HAVRLAB
      LOGICAL DOXYAUT, DOXRAN, DOYRAN, HAVAX, KEEPAX, LPANE, DORIGHT
      LOGICAL DOXLOG, DOYLOG, DEBUGON, HAVCCL, QUIET, LASYME, TXTCON
      LOGICAL HAVFLOG, DOANNOT, GCHANGE, DOGRON, DOBB
      REAL RED, GRN, BLU, WID, XLO, YLO, XHI, YHI, XPOS, YPOS
      REAL PXL, PXH, PYL, PYH, BXL, BXH, BYL, BYH, GXPOS, GYPOS
      REAL RBASE, RSTART, RSTOP
      REAL F1, F2, F3, F4, F5, WHIST, FBW, SHDSPC, WHISTIN, TWD, TWIDTH
      INTEGER NEVAL, NSTACK, ITER, IREG, INT1, I, IDOGRID, NINTERP
      INTEGER IHIST, IENUNIT, ISTAT, IDEP, JCMT, IEND, ISTART, IECMD
      INTEGER ISARG, ICMD, ICARGS, IEARG, IE, IWANT, IPFERR, NDATA
      INTEGER IGRID, ISTY, IFNE, INTM, IHMD, ITERST, ITEREN, NWORDS
      INTEGER IAP, LEXPROC, ITERIN, IARG, NAVAIL, IGSTY, INT2
      CHARACTER*80 PROC(NREGS), STRINGS(NREGS)
      CHARACTER PROCEXP*(NREGS*80)
      INTEGER PROCLEN(NREGS), STRILEN(NREGS)
      REAL MEMS(NREGS)
      CHARACTER*1 CFONMK
      CHARACTER*30 FONTNAM(NFONTS)
      INTEGER FONTNUM(NFONTS), IDXABT1, IDXABT2, IDXABT3, IDXSYMB
      INTEGER IDXMARK, IFONT
      REAL FSYMHT, FSYMANG, ZEROVAL, AXCX0, AXCY0, BB(4)
      LOGICAL BBEMPTY, SEVERR
C
C VARIABLES FOR DYNAMIC MEMORY POINT STORAGE
C
      REAL DA(1)
      INTEGER NPOINTS, IFWA, IOFF, IXOFF, IYOFF, IAOFF, IBOFF
C
C FUNCTIONS.
C
      INTEGER LOOKUP, NNBC, NBC, LNBC, EVAL, EXPROC, IGETOT, NOCC
      INTEGER LSYSTEM
      LOGICAL IFROMC, RFROMC, GETYN
      REAL EOF, STRING
C
C SET UP MAIN COMMAND NAMES
C
      CMDS(KDEV) = 'DEVICE'
      CMDS(KMAXPT) = 'MAXPOINTS'
      CMDS(KCOL) = 'COLOUR'
      CMDS(KWID) = 'WIDTH'
      CMDS(KMARK) = 'MARKER'
      CMDS(KCLR) = 'CLEAR'
      CMDS(KMOVE) = 'MOVE'
      CMDS(KDRAW) = 'DRAW'
      CMDS(KTEXT) = 'TEXT'
      CMDS(KREAD) = 'READ'
      CMDS(KXYPT) = 'XYPOINT'
      CMDS(KXYLN) = 'XYLINE'
      CMDS(KXYAUT) = 'XYAUTO'
      CMDS(KXRAN) = 'XRANGE'
      CMDS(KYRAN) = 'YRANGE'
      CMDS(KXYSAM) = 'XYSAME'
      CMDS(KXLIN) = 'XLINEAR'
      CMDS(KYLIN) = 'YLINEAR'
      CMDS(KXLOG) = 'XLOG'
      CMDS(KYLOG) = 'YLOG'
      CMDS(KXYGRD) = 'GRID'
      CMDS(KOBEY) = 'OBEY'
      CMDS(KEXIT) = 'EXIT'
      CMDS(KHELP) = 'HELP'
      CMDS(KBOUND) = 'BOUNDS'
      CMDS(KTIT) = 'TITLE'
      CMDS(KXLAB) = 'XLABEL'
      CMDS(KYLAB) = 'YLABEL'
      CMDS(KTEST) = 'MEMTEST'
      CMDS(KSTYLE) = 'STYLE'
      CMDS(KGET) = 'GET'
      CMDS(KSTAT) = 'STATUS'
      CMDS(KANNOT) = 'ANNOTATE'
      CMDS(KFLOG) = 'LOGFILE'
      CMDS(KINTERP) = 'INTERPOLATE'
      CMDS(KEBASM) = 'ASYMYERRORBARS'
      CMDS(KHIST) = 'XYHISTOGRAM'
      CMDS(KHISTMD) = 'HISTSTYLE'
      CMDS(KPANE) = 'PANE'
      CMDS(KUNP) = 'UNPANE'
      CMDS(KPANEO) = 'PANEOUTLINE'
      CMDS(KBLNK) = 'BLANK'
      CMDS(KUNBL) = 'UNBLANK'
      CMDS(KBLNKO) = 'BLANKOUTLINE'
      CMDS(KFILL) = 'FILL'
      CMDS(KROUTE) = 'ROUTE'
      CMDS(KEVAL) = 'EVAL'
      CMDS(KERNG) = 'ERANGE'
      CMDS(KPATH) = 'PATH'
      CMDS(KGRMOVE) = 'GRMOVE'
      CMDS(KGRDRAW) = 'GRDRAW'
      CMDS(KNSTACK) = 'NSTACK'
      CMDS(KIEVAL) = 'ITEVAL'
      CMDS(KPROC) = 'PROC'
      CMDS(KSTO) = 'STO'
      CMDS(KRCL) = 'RCL'
      CMDS(KCANVAS) = 'CANVAS'
      CMDS(KCTEXT) = 'CTEXT'
      CMDS(KFONT) = 'FONT'
      CMDS(KLFONT) = 'LISTFONT'
      CMDS(KSYMHT) = 'SYMHT'
      CMDS(KSYMANG) = 'SYMANG'
      CMDS(KSTRING) = 'STRING'
      CMDS(KZERO) = 'ZEROVAL'
      CMDS(KGSTY) = 'GSTYLE'
      CMDS(KRYLAB) = 'RYLABEL'
      CMDS(KGRIGHT) = 'RIGHTANNOT'
      CMDS(KGAXCUT) = 'AXCUT'
      CMDS(KCIRC) = 'CIRCLE'
      CMDS(KARC) = 'ARC'
      CMDS(KRECT) = 'RECT'
      CMDS(KCRECT) = 'CRECT'
      CMDS(KBSTAR) = 'BBSTART'
      CMDS(KBEND) = 'BBEND'
      CMDS(KBSET) = 'BBSET'
      CMDS(KLSYS) = 'LSYSTEM'
      CMDS(KLDPROC) = 'LOADPROC'
      CMDS(KTXBOX) = 'BOXTEXT'
C
C DEVICE NAMES.
C
      DEVNAM(KDGT) = 'GTERM'
      DEVNAM(KDTK) = 'TEK4K'
      DEVNAM(KDEC) = 'EPSCOL'
      DEVNAM(KDEB) = 'EPSBIN'
      DEVNAM(KSVG) = 'SVG'
C
C GRID MODE NAMES.
C
      GRDNAM(KGNO) = 'NONE'
      GRDNAM(KGX) = 'XAXIS'
      GRDNAM(KGY) = 'YAXIS'
      GRDNAM(KGXY) = 'BOTH'
C
C LINE STYLE NAMES.
C
      STYNAM(KSOLID) = 'SOLID'
      STYNAM(KDASH) = 'DASH'
      STYNAM(KDOT) = 'DOT'
      STYNAM(KDSHDOT) = 'DASHDOT'
C
C INTERPOLATION MODE NAMES.
C
      POLNAM(KILIN) = 'LINEAR'
      POLNAM(KICUB) = 'CUBIC'
      POLNAM(KIQUIN) = 'QUINTIC'
C
C HISTOGRAM STYLE NAMES.
C
      HISTNAM(KHABUT) = 'ABUT'
      HISTNAM(KHABUTS) = 'ABUT+SHADE'
      HISTNAM(KHLINE) = 'LINES'
      HISTNAM(KHWID) = 'WIDE'
      HISTNAM(KHWIDS) = 'WIDE+SHADE'
C
C GRAPH STYLE NAMES.
C
      GSTYNAM(KGNORM) = 'BOXED'
      GSTYNAM(KGAXES) = 'AXES'
      GSTYNAM(KGOPEN) = 'OPEN'
C
C FONT NAMES AND NUMBERS.
C ALSO SET DIMFILM DEFAULT ASSIGNMENTS IN IDXABT*,IDXSYMB,IDXMARK USING
C TABLE INDICES (IFONT).
C
      IFONT = 1
      FONTNAM(IFONT) = 'SANS.SIMPLEX'
      FONTNUM(IFONT) = 11
      IDXABT1 = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SANS.SIMPLEX.MONO'
      FONTNUM(IFONT) = 111
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SANS.SIMPLEX.GREEK'
      FONTNUM(IFONT) = 1011
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SANS.DUPLEX'
      FONTNUM(IFONT) = 12
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX'
      FONTNUM(IFONT) = 15
      IDXABT2 = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.SMALL'
      FONTNUM(IFONT) = 14
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.GREEK'
      FONTNUM(IFONT) = 1015
      IDXABT3 = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.GREEK.SMALL'
      FONTNUM(IFONT) = 1014
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.TRIPLEX'
      FONTNUM(IFONT) = 16
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.ITALIC'
      FONTNUM(IFONT) = 25
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.COMPLEX.ITALIC.SMALL'
      FONTNUM(IFONT) = 24
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SERIF.TRIPLEX.ITALIC'
      FONTNUM(IFONT) = 26
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SCRIPT.SIMPLEX'
      FONTNUM(IFONT) = 31
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'SCRIPT.COMPLEX'
      FONTNUM(IFONT) = 35
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'GOTHIC.TRIPLEX'
      FONTNUM(IFONT) = 46
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'GOTHIC.TRIPLEX.GERMAN'
      FONTNUM(IFONT) = 56
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'GOTHIC.TRIPLEX.ITALIAN'
      FONTNUM(IFONT) = 66
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'CYRILLIC.COMPLEX'
      FONTNUM(IFONT) = 2015
C
C SYMBOL NAME AND NUMBERS.
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'MATH.SMALL'
      FONTNUM(IFONT) = 8001
      IDXSYMB = IFONT
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'CARTOGRAPHIC'
      FONTNUM(IFONT) = 8002
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'ASTRONOMICAL'
      FONTNUM(IFONT) = 8003
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'ASTROLOGICAL'
      FONTNUM(IFONT) = 8004
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'MUSICAL'
      FONTNUM(IFONT) = 8005
C
C MARKER NAMES AND NUMBERS.
C
      IFONT = IFONT + 1
      FONTNAM(IFONT) = 'PRINCIPAL'
      FONTNUM(IFONT) = 9001
      IDXMARK = IFONT
C
C CHECK ON NUMBER OF FONTS.
C
      IF( IFONT .NE. NFONTS )STOP 'INTERNAL ERROR IN FONT DEFINITIONS.'
C
C COMMAND DESCRIPTIONS.
C
      DCMDS(KDEV) = 'NAME - SELECT OUTPUT DEVICE'
      DCMDS(KMAXPT) = 'NUMBER - SET MAX DATA POINTS'
      DCMDS(KCOL) = 'R G B - SET RGB COLOUR TO USE'
      DCMDS(KWID) = 'WIDTH - SET LINE WIDTH'
      DCMDS(KMARK) = 'NUMBER - SET POINT MARKER NUMBER'
      DCMDS(KCLR) = 'CLEAR DRAWING AREA.'
      DCMDS(KMOVE) = 'X Y - MOVE TO POSITION'
      DCMDS(KDRAW) = 'X Y - DRAW TO POSITION'
      DCMDS(KTEXT) = '"TEXT" - DRAW TEXT (WITH FORMAT CONTROL)'
      DCMDS(KREAD) = 'NAME XCOL YCOL [YECOL [XECOL]]' //
     +               ' - READ A DATA FILE USING COLUMNS'
      DCMDS(KXYPT) = 'DRAW XY GRAPH WITH POINTS'
      DCMDS(KXYLN) = 'DRAW XY GRAPH WITH LINES'
      DCMDS(KXYAUT) = 'FIND BOTH AXIS RANGES AUTOMATICALLY'
      DCMDS(KXRAN) = 'XLO YHI - SET X AXIS RANGE'
      DCMDS(KYRAN) = 'YLO YHI - SET Y AXIS RANGE'
      DCMDS(KXYSAM) = 'KEEP PREVIOUS XY AXIS RANGES'
      DCMDS(KXLIN) = 'USE LINEAR X AXIS'
      DCMDS(KYLIN) = 'USE LINEAR Y AXIS'
      DCMDS(KXLOG) = 'USE LOG X AXIS'
      DCMDS(KYLOG) = 'USE LOG Y AXIS'
      DCMDS(KXYGRD) = '"NONE" "X" "Y" "BOTH" - GRID GRAPH IN AXIS'
      DCMDS(KOBEY) = 'NAME - READ COMMANDS FROM FILE.'
      DCMDS(KEXIT) = 'EXIT GPLOT'
      DCMDS(KHELP) = 'SHOW THIS HELP'
      DCMDS(KBOUND) = 'XL XH YL YH - SET PLOT BOUNDS'
      DCMDS(KTIT) = '"TEXT" - SET TITLE'
      DCMDS(KXLAB) = '"TEXT" - SET X AXIS LABEL'
      DCMDS(KYLAB) = '"TEXT" - SET Y AXIS LABEL'
      DCMDS(KTEST) = 'TEST DYNAMIC MEMORY. GENERATE PLOT TEST DATA.'
      DCMDS(KSTYLE) = '"SOLID" "DASH" "DOT" "DASHDOT" - LINE STYLE.'
      DCMDS(KGET) = 'NAME - GET AN INDIRECT PERMANENT FILE.'
      DCMDS(KSTAT) = 'DISPLAY STATUS INFORMATION.'
      DCMDS(KANNOT) = '"ON" "OFF" - TURN GRAPH ANNOTATION ON/OFF.'
      DCMDS(KFLOG) = 'NAME - OPEN A COMMAND LOG FILE.'
      DCMDS(KINTERP) = '"LINEAR" "CUBIC" "QUINTIC" [N] - INTERPOLATE.'
      DCMDS(KEBASM) = '"ON" "OFF" - ASYMETTRIC Y ERROR BARS (OFF '//
     +                'FOR X AND Y ERROR BARS).'
      DCMDS(KHIST) = 'DRAW XY HISTOGRAM'
      DCMDS(KHISTMD) = '"ABUT" "ABUT+SHADE" "LINES" "WIDE" '//
     +                 '"WIDE+SHADE" [WIDTH] - HISTOGRAM STYLE.'
      DCMDS(KPANE) = 'XL XH YL YH - SET PANE (CLIPPING) AREA.'
      DCMDS(KUNP) = 'STOP USING ANY PANE.'
      DCMDS(KPANEO) = 'OUTLINE THE PANE.'
      DCMDS(KBLNK) = 'XL XH YL YH - SET BLANK AREA.'
      DCMDS(KUNBL) = 'STOP USING ANY BLANK AREA.'
      DCMDS(KBLNKO) = 'OUTLINE THE BLANK AREA.'
      DCMDS(KFILL) = 'FILL SCREEN WITH COLOUR (DEV. DEP.).'
      DCMDS(KROUTE) = 'SET ROUTE TO SEND EPS FILES TO.'
      DCMDS(KEVAL) = 'RPN - EVALUATE FUNCTION USING AN RPN NOTATION.'
      DCMDS(KERNG) = 'BASE START STOP N - SET A RANGE OF X '//
     +               'VALUES FOR EVAL. BASE 1 IS LINEAR.'
      DCMDS(KPATH) = 'C OR O - DRAW A POLYLINE IN BOUNDS COORDINATES.'
      DCMDS(KGRMOVE) = 'X Y - MOVE TO GRAPH COORDS (X,Y)'
      DCMDS(KGRDRAW) = 'X Y - DRAW TO GRAPH COORDS (X,Y)'
      DCMDS(KNSTACK) = 'N - SET STACK SIZE (MIN. 4)'
      DCMDS(KIEVAL) = 'START END STEP RPN - ITERATED EVALUATION '//
     +                'OVER START TO END BY STEP, ITERATION IN I.'
      DCMDS(KPROC) = 'N RPN - STORE RPN CODE STRING IN PROC REGISTER N.'
      DCMDS(KSTO) = 'N X - STORE X IN MEMORY REGISTER N.'
      DCMDS(KRCL) = 'N - DISPLAY CONTENTS OF MEMORY REGISTER N.'
      DCMDS(KCANVAS) = 'XL XH YL YH - SET BOUNDS AND PANE.'
      DCMDS(KCTEXT) = 'W "TEXT" - TEXT H CENTERED ON CUR XPOS,YPOS.'//
     +                ' W WIDTH IN USER UNITS, 0 FOR DEFAULT.'
      DCMDS(KFONT) = 'SET FONTNAME - SET FONT/SYMBOL/MARKER TO USE.'//
     +               ' SET: 1 2 3 S M FOR 3 ALPHABETS, SYMBOL, MARKER.'
      DCMDS(KLFONT) = 'LIST AVAILABLE FONTS'
      DCMDS(KSYMHT) = 'TEXT/SYMBOL/MARKER HEIGHT IN USER BOUNDS UNITS.'
      DCMDS(KSYMANG) = 'TEXT DRAWING ANGLE WRT X AXIS (CCW DEGREES).'
      DCMDS(KSTRING) = 'N "TEXT" - SET CONTENTS OF STRING REGISTER N.'
      DCMDS(KZERO) = 'V - SET ZERO TRAP VALUE FOR EVAL (DEFL 1E-9).'
      DCMDS(KGSTY) = '"NORMAL" "OPEN" - SET OVERALL GRAPHING STYLE.'
      DCMDS(KRYLAB) = '"LABEL" - RIGHT HAND EDGE LABEL.'
      DCMDS(KGRIGHT) = '"ON" "OFF" - DO RIGHT EDGE ANNOTATION (IF '//
     +                 'ANNOTATE OFF).'
      DCMDS(KGAXCUT) = 'X Y - SET POINT THRU WHICH AXES ARE DRAWN.'
      DCMDS(KCIRC) = 'X Y R - CIRCLE, CENTER X,Y RADIUS R.'
      DCMDS(KARC) = 'X Y R A1 A2 - CIRCULAR ARC, CENTER X,Y RADIUS R '//
     +                 'ANGLE A1 TO A2.'
      DCMDS(KRECT) = 'X Y W H - RECTANGLE AT X,Y WIDTH W HEIGHT H.'
      DCMDS(KCRECT) = 'X Y W H - RECTANGLE CENTER X,Y WIDTH W HEIGHT H.'
      DCMDS(KBSTAR) = 'EVAL/ITEVAL FIND GRAPHICS BOUNDING BOX ONLY.'
      DCMDS(KBEND) = 'EVAL/ITEVAL RETURN TO RENDERING GRAPHICAL ITEMS.'
      DCMDS(KBSET) = 'SET BOUNDS TO BOUNDING BOX (IF ANY).'
      DCMDS(KLSYS) = 'NRULES NITER ANGLE - DEFINE AND DRAW AN L-SYSTEM.'
      DCMDS(KLDPROC) = 'N NAME - LOAD PROCEDURE NAME INTO REGISTER N.'
      DCMDS(KTXBOX) = '"TEXT" - DRAW TEXT IN A BOX. (TEST ONLY).'
C
C DEVICE DESCRIPTIONS.
C
      DDEVS(KDGT) = 'GTERM COLOUR GRAPHICS TERMINAL'
      DDEVS(KDTK) = 'TEKTRONIX 4014 GRAPHICS TERMINAL'
      DDEVS(KDEC) = 'NAME - COLOUR EPS FILE'
      DDEVS(KDEB) = 'NAME - BLACK/WHITE EPS FILE'
      DDEVS(KSVG) = 'NAME - SVG FILE'
C
C NUMBER OF ARGUMENTS REQUIRED FOR EACH COMMAND.
C
      NARGS(KDEV) = 1
      NARGS(KMAXPT) = 1
      NARGS(KCOL) = 3
      NARGS(KWID) = 1
      NARGS(KMARK) = 1
      NARGS(KCLR) = 0
      NARGS(KMOVE) = 2
      NARGS(KDRAW) = 2
      NARGS(KTEXT) = 1
      NARGS(KREAD) = 3
      NARGS(KXYPT) = 0
      NARGS(KXYLN) = 0
      NARGS(KXYAUT) = 0
      NARGS(KXRAN) = 2
      NARGS(KYRAN) = 2
      NARGS(KXYSAM) = 0
      NARGS(KXLIN) = 0
      NARGS(KYLIN) = 0
      NARGS(KXLOG) = 0
      NARGS(KYLOG) = 0
      NARGS(KXYGRD) = 1
      NARGS(KOBEY) = 1
      NARGS(KEXIT) = 0
      NARGS(KHELP) = 0
      NARGS(KBOUND) = 4
      NARGS(KTIT) = 1
      NARGS(KXLAB) = 1
      NARGS(KYLAB) = 1
      NARGS(KTEST) = 0
      NARGS(KSTYLE) = 1
      NARGS(KGET) = 1
      NARGS(KSTAT) = 0
      NARGS(KANNOT) = 1
      NARGS(KFLOG) = 1
      NARGS(KINTERP) = 2
      NARGS(KEBASM) = 1
      NARGS(KHIST) = 0
      NARGS(KHISTMD) = 1
      NARGS(KPANE) = 4
      NARGS(KUNP) = 0
      NARGS(KPANEO) = 0
      NARGS(KBLNK) = 4
      NARGS(KUNBL) = 0
      NARGS(KBLNKO) = 0
      NARGS(KFILL) = 0
      NARGS(KROUTE) = 1
      NARGS(KEVAL) = 1
      NARGS(KERNG) = 4
      NARGS(KPATH) = 1
      NARGS(KGRMOVE) = 2
      NARGS(KGRDRAW) = 2
      NARGS(KNSTACK) = 1
      NARGS(KIEVAL) = 4
      NARGS(KPROC) = 2
      NARGS(KSTO) = 2
      NARGS(KRCL) = 1
      NARGS(KCANVAS) = 4
      NARGS(KCTEXT) = 2
      NARGS(KFONT) = 2
      NARGS(KLFONT) = 0
      NARGS(KSYMHT) = 1
      NARGS(KSYMANG) = 1
      NARGS(KSTRING) = 2
      NARGS(KZERO) = 1
      NARGS(KGSTY) = 1
      NARGS(KRYLAB) = 1
      NARGS(KGRIGHT) = 1
      NARGS(KGAXCUT) = 2
      NARGS(KCIRC) = 3
      NARGS(KARC) = 5
      NARGS(KRECT) = 4
      NARGS(KCRECT) = 4
      NARGS(KBSTAR) = 0
      NARGS(KBEND) = 0
      NARGS(KBSET) = 0
      NARGS(KLSYS) = 3
      NARGS(KLDPROC) = 2
      NARGS(KTXBOX) = 1
C
C DEFAULT STATE ON START UP.
C NO DATA READ YET. NO DEVICE OPENED. ETC.
C
C---- DATA AND ERROR BAR STATE
      HAVDATA = .FALSE.
      HAVYE = .FALSE.
      HAVXE = .FALSE.
      LASYME = .TRUE.
C---- DEVICE STATE
      SLIDE = .TRUE.
      HAVDEV = .FALSE.
      IDEV = 0
C---- ANNOTATION STATE
      DOANNOT = .TRUE.
      HAVTIT = .FALSE.
      HAVXLAB = .FALSE.
      HAVYLAB = .FALSE.
      HAVRLAB = .FALSE.
      DOXYAUT = .TRUE.
      DOXRAN = .FALSE.
      DOYRAN = .FALSE.
      MARKNUM = 3
      IDOGRID = 1
      HAVAX = .FALSE.
      KEEPAX = .FALSE.
      DOXLOG = .FALSE.
      DOYLOG = .FALSE.
      IGSTY = KGNORM
      DORIGHT = .FALSE.
      AXCX0 = 0.0
      AXCY0 = 0.0
C---- BOUNDS STATE
      XLO = 0.0
      XHI = 1.0
      YLO = 0.0
      YHI = 1.0
C---- PANE STATE
      PXL = 0.0
      PXH = 1.0
      PYL = 0.0
      PYH = 1.0
      LPANE = .FALSE.
C---- BLANK STATE
      BXL = 0.0
      BXH = 1.0
      BYL = 0.0
      BYH = 1.0
      LBLNK = .FALSE.
C---- PLOT AND GRAPH CURRENT COORDINATES
      XPOS = 0.0
      YPOS = 0.0
      GXPOS = 0.0
      GYPOS = 0.0
C---- DEBUGGING STATE
      DEBUGON = .FALSE.
      QUIET = .TRUE.
C---- LOG FILE STATE
      HAVFLOG = .FALSE.
C---- INTERPOLATION STATE
      INTERPM = KILIN
      NINTERP = 5
C---- HISTOGRAM STATE
      IHIST = KHABUT
      WHIST = 1.0
C---- OPTIONS STATE
      AUTOGET = .FALSE.
      ROUTE = 'NONE'
C---- XRANGE AND EVAL
      NEVAL = 0
      RSTART = 0.0
      RSTOP = 1.0
      RBASE = 1.0
      ZEROVAL = 1.0E-9
      BB(1) = 1.0E300
      BB(2) = -1.0E300
      BB(3) = 1.0E300
      BB(4) = -1.0E300
      DOBB = .FALSE.
      SEVERR = .FALSE.
C---- PROCEDURE REGISTERS
      DO 65 I=1,NREGS
         PROC(I) = ' '
         PROCLEN(I) = 0
         MEMS(I) = 0.0
         STRINGS(I) = ' '
         STRILEN(I) = 0
 65   CONTINUE
C---- TEXT/SYMBOL DRAWING (APART FROM FONTS, SEE ABOVE).
      FSYMHT = 1.0 / 50.0
      FSYMANG = 0.0
      TXTCON = .FALSE.
C
C STARTUP ANNOUNCEMENT.
C
      WRITE(6,66)
  66  FORMAT(1X,'===========================================')
      WRITE(6,100)
 100  FORMAT(1X,'GPLOT INTERACTIVE PLOTTING PROGRAM. V0.59')
      WRITE(6,66)
      WRITE(6,177)
 177  FORMAT(1X,'BASED ON ULCC DIMFILM BY JOHN GILBERT.')
      WRITE(6,178)
 178  FORMAT(1X,'WRITTEN FOR CDC NOS 2.8 BY NICK GLAZZARD.')
      WRITE(6,179)
 179  FORMAT(1X,'SOME DEVICE & PARSING CODE BY ADRIAN CLARK.')
      WRITE(6,66)
C
C  ALLOCATE SPACE FOR DATA TO BE PLOTTED (DYNAMICALLY).
C
      NPOINTS = NDEFPTS
      NSTACK = 8
      NWORDS = NSTACK * NPOINTS
      CALL CMMALF(NWORDS,0,0,IFWA)
      IOFF = IFWA - LOCF(DA(1))
      IXOFF = IOFF + 1
      IYOFF = IXOFF + NPOINTS
      IAOFF = IYOFF + NPOINTS
      IBOFF = IAOFF + NPOINTS
      WRITE(6,400)NPOINTS
 400  FORMAT(1X,'ALLOCATED SPACE FOR ',I5,' DATA POINTS.')
C
C WARN ABOUT DEVICE COMMAND DELAY.
C OUTPUT IS ONLY FLUSHED ON A READ, SO DOING IT HERE IS BEST.
C
      WRITE(6,9777)
 9777 FORMAT(1X,'NOTE: OPENING DEVICE, LOADING FONTS WILL TAKE ',
     +          'TIME. ALLOW 6 SECS.')
C
C ATTACH THE FONT FILE DIRECTLY FROM THE PROGRAM.
C
      CALL PF('ATTACH','DADIMFO','DADIMFO')
      WRITE(6,9778)
 9778 FORMAT(1X,'ATTACHED FONT FILE DADIMFO.')
C
C ESTABLISH AN INITIAL EVALUATION RANGE, ETC.
C
      RBASE = 1.0
      RSTART = 0.0
      RSTOP = 1.0
      NEVAL = 101
      CALL LINSPC(DA(IXOFF),NEVAL,RSTART,RSTOP)
C
C PARSE ANY COMMAND LINE ARGUMENTS.
C OBEY=NAME - START BY EXECUTING GPLOT COMMANDS IN FILE NAME.
C PARM=STRING - PARAMETERS TO PASS TO AN OBEY FILE ($A B C$).
C QUIET=Y/N - TURN OFF SOME OUTPUT
C DEBUG=Y/N - TURN ON DEBUGGING
C SLIDE=Y/N - USE SLIDE LAYOUT MODE (DEFAULT)
C NOTE THAT STRINGS WITH SPACES CAN BE SPECIFIED ON THE CONTROL
C CARD BY ENCLOSING THEM WITH $S. E.G. $A STRING WITH SPACES$
C
      INUNIT = 7
      IENUNIT = 7
      CCLINE = ' '
      HAVCCL = .FALSE.
 5000 CONTINUE
C---- GET THE NEXT PARAMETER. STOP WHEN THERE ARE NO MORE.
         CALL GETPARM( KEY, VALUE, ISTAT )
         IF( ISTAT .EQ. -1 )GOTO 5001
            IF( ISTAT .EQ. 1 )THEN
C---- DEAL WITH KEY WORDS WITH NO VALUES
               WRITE(6,2176)KEY(1:LNBC(KEY,1,1))
 2176          FORMAT(1X,'UNKNOWN KEY ONLY CONTROL CARD OPTION ',A)
            ELSE
C---- DEAL WITH KEY=VALUE PARAMETERS.
               IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'OBEY' )THEN
                  INUNIT = 8
                  IENUNIT = 8
                  CALL ADDSTR(CCLINE,'OBEY',.FALSE.,.FALSE.)
                  CALL ADDSTR(CCLINE,VALUE,.TRUE.,.FALSE.)
                  HAVCCL = .TRUE.
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'PARM' )THEN
C                 CALL ADDSTR(CCLINE,VALUE,.TRUE.,.TRUE.)
                  CALL ADDSTR(CCLINE,VALUE,.TRUE.,.FALSE.)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'DEBUG' )THEN
                  DEBUGON = GETYN(VALUE)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'QUIET' )THEN
                  QUIET = GETYN(VALUE)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'GET' )THEN
                  AUTOGET = GETYN(VALUE)
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'SLIDE' )THEN
                  SLIDE = GETYN(VALUE)
               ELSE
                  WRITE(6,2177)KEY(1:LNBC(KEY,1,1))
 2177             FORMAT(1X,'UNKNOWN KEY-VAL CONTROL CARD OPTION ',A)
               ENDIF
            ENDIF
         GOTO 5000
 5001 CONTINUE
C
C NO COMMANDS HAVE YET BEEN ISSUED THAT HAVE DRAWN ANYTHING.
C TRACK THIS SO WE CAN FORCE ALL DRAWN THINGS TO BE VISIBLE WHEN
C NEEDED, BUT NOT OTHERWISE.
C
      GCHANGE = .FALSE.
C
C MAIN COMMAND LOOP. READ COMMAND FROM CURRENT INPUT FILE.
C IF HAVCCL, INSERT CCLINE IN TO INLINE WITHOUT A READ JUST ONCE.
C THIS LETS A COMMAND SPECIFIED ON THE CONTROL CARD BE EXECUTED.
C
   1  CONTINUE
      IDEP = INUNIT - IENUNIT
      IF( HAVCCL )THEN
         INLINE = CCLINE
         HAVCCL = .FALSE.
      ELSE
C
C IF THE OBEY FILE STACK DEPTH IS 0, WE ARE READING FROM INPUT.
C IN THAT CASE, FLUSH ANY GRAPHICS COMMANDS AND SWITCH TO TEXT
C MODE ON THE DEVICE (IF THAT IS MEANINGFUL FOR THAT DEVICE).
C
         IF( IDEP .EQ. 0 .AND. HAVDEV )THEN
            CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         ENDIF
         READ(INUNIT,101,ERR=998,END=1000)INLINE
 101     FORMAT(A)
         CALL UPCASE(INLINE)
C
C IF AT OBEY FILE DEPTH 0 (INTERACTIVE), WRITE TO ANY LOG FILE,
C
         IF( IDEP .EQ. 0 .AND. HAVFLOG )THEN
            WRITE(3,3000)INLINE(1:LNBC(INLINE,1,1))
 3000       FORMAT(A)
         ENDIF
C
C IF THE FIRST CHARACTERS ON THE LINE ARE 'C ', TREAT AS COMMENT.
C IGNORE ANYTHING ON A LINE AFTER A SEMI-COLON.
C
         IF( INLINE(1:2) .EQ. 'C ' )GOTO 1
         JCMT = INDEX(INLINE,';')
         IF( JCMT .GT. 0 )INLINE(JCMT:) = ' '
C
C AFTER THE READ, SWITCH BACK TO GRAPHICS MODE (IF MEANINGFUL).
C
         IF( IDEP .EQ. 0 .AND. HAVDEV )THEN
            CALL GOGRAF(IDEV,NDEVS)
         ENDIF
      ENDIF
      GOTO 900
C
C END OF CURRENT INPUT FILE. POP OBEY FILE STACK. EXIT IF EMPTY.
C WHEN RETURNING TO INTERACTIVE LEVEL, MAKE ANY DRAWING VISIBLE.
C
 1000 CONTINUE
      IF( INUNIT .GT. IENUNIT )THEN
         CLOSE(UNIT=INUNIT,ERR=1001)
 1001    CONTINUE
         INUNIT = INUNIT - 1
         IF( (INUNIT-IENUNIT) .EQ. 0 )THEN
            SEVERR = .FALSE.
            IF( GCHANGE )THEN
               IF(HAVDEV)CALL MAKEVIS(IDEV,NDEVS)
               GCHANGE = .FALSE.
            ENDIF
         ENDIF
C
C IF UNWINDING OBEY FILES AFTER AN EVAL ERROR, REPEAT UNTIL INTERACTIVE.
C
         IF( SEVERR )GOTO 1000
         GOTO 1
      ELSE
         GOTO 2
      ENDIF
C
C GET COMMAND AND ANY TRAILING ARGUMENT STRING.
C
 900  CONTINUE
      IEND = LNBC(INLINE,1,0)
      IF( IEND .EQ. 0 )GOTO 1
      ISTART = NNBC(INLINE,1,0)
      IF( ISTART .EQ. 0 )GOTO 1
      IECMD = NBC(INLINE,ISTART,IEND+1)
      CMD = INLINE(ISTART:IECMD-1)
      IF( IECMD .NE. IEND )THEN
         ISARG = NNBC(INLINE,IECMD,0)
         IF( ISARG .EQ. 0 )THEN
            HAVARG = .FALSE.
            ARGSTR = ' '
         ELSE
            HAVARG = .TRUE.
            ARGSTR = INLINE(ISARG:IEND)
         ENDIF
      ELSE
         HAVARG = .FALSE.
         ARGSTR = ' '
      ENDIF
C
C LOOKUP THE COMMAND
C
      ICMD = LOOKUP(CMDS,NCMDS,CMD,.FALSE.,.TRUE.)
      IF(ICMD .EQ. 0 )THEN
         IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         WRITE(6,102)
 102     FORMAT(1X,'UNKNOWN COMMAND. TRY HELP.')
      ELSE IF( ICMD .LT. 0 )THEN
         IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         WRITE(6,103)
 103     FORMAT(1X,'AMBIGUOUS COMMAND. TRY HELP.')
      ELSE
C
C CHECK ARGUMENTS PRESENT IF REQUIRED, NOT IF NOT.
C
         IF( HAVARG .AND. NARGS(ICMD) .EQ. 0 )THEN
            IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,120)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 120        FORMAT(1X,'COMMAND ',A,' SHOULD HAVE NO ARGUMENTS')
            GOTO 1
         ENDIF
         IF( .NOT. HAVARG .AND. NARGS(ICMD) .GT. 0 )THEN
            IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,121)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),NARGS(ICMD)
 121        FORMAT(1X,'COMMAND ',A,' SHOULD HAVE ',I1,' ARGUMENTS')
            GOTO 1
         ENDIF
C
C IF READING AN OBEY FILE, IF IT HAS PARAMETERS, DO PARAMETER
C SUBSTITUTION. CONVERT ' TO " IN ARGS AFTER SUBSTITUTION.
C
         IF( IDEP .GT. 0 )THEN
            IPFERR = 0
            CALL PARSUB(OBPSTK(IDEP),ARGSTR,LNBC(ARGSTR,1,1),IPFERR)
            IF( IPFERR .NE. 0 )THEN
               SEVERR = .TRUE.
               GOTO 1000
            ENDIF
            CALL QUOTS2D(ARGSTR)
         ENDIF
C
C DIVIDE ARGUMENT STRING IN TO SEPARATE ARGUMENTS.
C ALLOW DOUBLE QUOTES TO ENCLOSE ARGUMENTS WITH SPACES.
C
         ICARGS = 0
         IF( HAVARG )THEN
            ISARG = 1
            DO 129 ICARGS=1,MAXARG
               IF( ARGSTR(ISARG:ISARG) .EQ. '"' )THEN
                  IEARG = NOCC(ARGSTR,'"',ISARG+1,0)
                  IF( IEARG .EQ. 0 )THEN
                     WRITE(6,123)
 123                 FORMAT(1X,'UNMATCHED QUOTE')
                     GOTO 1
                  ENDIF
                  ARGS(ICARGS) = ARGSTR(ISARG+1:IEARG-1)
               ELSE
                  IEARG = NBC(ARGSTR,ISARG,IEND)
                  ARGS(ICARGS) = ARGSTR(ISARG:IEARG)
               ENDIF
               IF( IEARG .EQ. IEND )GOTO 130
               ISARG = NNBC(ARGSTR,IEARG+1,0)
               IF( ISARG .EQ. 0 )GOTO 130
 129        CONTINUE
         ENDIF
 130     CONTINUE
C
C CHECK CORRECT NUMBER OF ARGUMENTS FOR COMMAND.
C ALLOW 1 OR 2 ARGUMENTS FOR DEVICE, HISTSTYLE AND OBEY AS SPECIAL CASES
C ALLOW 3, 4 0R 5 ARGUMENTS FOR READ AS A SPECIAL CASE.
C
         IF( ICARGS .NE. NARGS(ICMD) )THEN
            IF( ICMD .EQ. KDEV .OR. ICMD .EQ. KOBEY .OR.
     +          ICMD .EQ. KREAD .OR. ICMD .EQ. KHISTMD )THEN
               IF( ICMD .EQ. KREAD )THEN
                  IF( ICARGS .LT. 3 .OR. ICARGS .GT. 5 )THEN
                     IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
                     WRITE(6,124)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),3,5
                     GOTO 1
                  ENDIF
               ELSE
                  IF( ICARGS .GT. 2 )THEN
                     IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
                     WRITE(6,124)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),1,2
 124                 FORMAT(1X,'COMMAND ',A,' REQUIRES ',I1,' TO ',
     +                         I1,' ARGUMENTS')
                     GOTO 1
                  ENDIF
               ENDIF
            ELSE
               IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
               WRITE(6,121)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1)),
     +         NARGS(ICMD)
               GOTO 1
            ENDIF
         ENDIF
C
C DISPLAY THE ARGUMENTS FOR DEBUG PURPOSES (AFTER ANY SUBSTS).
C
         IF( DEBUGON )THEN
            IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            DO 888 IARG=1,ICARGS
               WRITE(6,8881)IARG,ARGS(IARG)(1:LNBC(ARGS(IARG),1,1))
 8881          FORMAT(1X,'ARG NUM=',I2,' ARG=',A)
 888        CONTINUE
            IF(HAVDEV)CALL GOGRAF(IDEV,NDEVS)
         ENDIF
C
C EXECUTE THE COMMAND
C
         IF( .NOT. QUIET )THEN
            IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,140)(IDEP+1),
     +         CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 140        FORMAT(1X,'--(',I1,')--> ',A)
            IF(HAVDEV)CALL GOGRAF(IDEV,NDEVS)
         ENDIF
         GOTO(201,202,203,204,205,206,207,208,209,210,
     +        211,212,213,214,215,216,217,218,219,220,
     +        221,222,223,224,225,226,227,228,229,230,
     +        231,232,233,234,235,236,237,238,239,240,
     +        241,242,243,244,245,246,247,248,249,250,
     +        251,252,253,254,255,256,257,258,259,260,
     +        261,262,263,264,265,266,267,268,269,270,
     +        271,272,273,274,275,276,277,278),ICMD
C
C DEVICE
 201     CONTINUE
         IF( HAVDEV )THEN
            CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2016)
 2016       FORMAT(1X,'DEVICE ALREADY SET. CANNOT REPLACE.')
            GOTO 299
         ENDIF
         IDEV = LOOKUP(DEVNAM,NDEVS,ARGS(1),.FALSE.,.TRUE.)
         IF( IDEV .EQ. 0 )THEN
            WRITE(6,2019)
 2019       FORMAT(1X,'UNKNOWN DEVICE. TRY HELP.')
         ELSE IF( IDEV .LT. 0 )THEN
            WRITE(6,2018)
 2018       FORMAT(1X,'AMBIGUOUS DEVICE. TRY HELP.')
         ELSE
            GOTO(2011,2012,2013,2014,2015),IDEV
C---- GTERM DEVICE
 2011       CONTINUE
            CALL DGTERM
            CALL GTWIDTH(2.0)
            GOTO 2017
C---- TEK4K DEVICE
 2012       CONTINUE
            CALL DTEK4K
            GOTO 2017
C---- EPSCOL DEVICE
 2013       CONTINUE
            IF( ICARGS .NE. 2 )THEN
               WRITE(6,9010)
 9010          FORMAT(1X,'DEVICE NEEDS A FILE NAME.')
               GOTO 299
            ENDIF
            IE = LNBC(ARGS(2),1,1)
            CALL EPSNAM(ARGS(2)(1:IE))
            CALL DEPCOL
            GOTO 2017
C---- EPSBIN DEVICE
 2014       CONTINUE
            IF( ICARGS .NE. 2 )THEN
               WRITE(6,9010)
               GOTO 299
            ENDIF
            IE = LNBC(ARGS(2),1,1)
            CALL EPSNAM(ARGS(2)(1:IE))
            CALL DEPBIN
            GOTO 2017
C---- SVG DEVICE
 2015       CONTINUE
            IF( ICARGS .NE. 2 )THEN
               WRITE(6,9010)
               GOTO 299
            ENDIF
            IE = LNBC(ARGS(2),1,1)
            CALL SVGNAM(ARGS(2)(1:IE))
            CALL DSVGCL
            GOTO 2017
 2017       CONTINUE
C---- COMMON INITIALIZATION
            HAVDEV = .TRUE.
            IF( SLIDE )CALL GRCONA
            IF( QUIET )CALL NOCHCK
            CALL BOUNDS(0.0,1.0,0.0,1.0)
            CALL LINSF(1.0)
            CALL RGB(1.0,0.0,0.0)
            CALL SETFR(1.0,0.0,0.13)
            CALL AUTOXY
            CALL LDSYM(8001)
            CALL LDMARK(9001)
            CALL GFLUSH(IDEV,NDEVS,.FALSE.)
         ENDIF
         GOTO 299
C
C MAXPOINTS. FREE AND RE-ALLOCATE POINT DATA STORE.
 202     CONTINUE
         IF( IFROMC(ARGS(1),IWANT,1,NEWPOS) )THEN
            IF(IWANT .LT. 10 .OR. IWANT .GT. MAXPTS )THEN
               IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
               WRITE(6,2021)IWANT,MAXPTS
 2021          FORMAT(1X,I7,' POINTS .LT. 10 OR .GT. ',I6,' INVALID.')
               GOTO 299
            ENDIF
            NPOINTS = IWANT
            CALL CMMFRF(IFWA)
            CALL CMMGFS(1,0,NAVAIL)
            WRITE(6,2023)NAVAIL
 2023       FORMAT(1X,'WORDS AVAILABLE: ',I6,' INCLUDING 1000 EXCESS.')
            NWORDS = NSTACK * NPOINTS
            IF( NWORDS .GT. (NAVAIL-1000) )THEN
               WRITE(6,2024)NSTACK,NPOINTS,NWORDS,NAVAIL-1000
 2024          FORMAT(1X,'NSTACK:',I6,' NPOINTS:',I6,' = ',I6,' WORDS,',
     +                ' EXCEEDS MAX AVAIL:',I6)
               NWORDS = NAVAIL - 1000
               NPOINTS = NWORDS / NSTACK
               WRITE(6,2025)NPOINTS
 2025          FORMAT(1X,'ALLOCATING MAXIMUM. NPOINTS = ',I6)
            ENDIF
            CALL CMMALF(NWORDS,0,0,IFWA)
            IOFF = IFWA - LOCF(DA(1))
            IXOFF = IOFF + 1
            IYOFF = IXOFF + NPOINTS
            IAOFF = IYOFF + NPOINTS
            IBOFF = IAOFF + NPOINTS
            WRITE(6,400)NPOINTS
            HAVDATA = .FALSE.
            IF( NEVAL .GT. NPOINTS )NEVAL = 0
         ELSE
            IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2022)
 2022       FORMAT(1X,'EXPECTED AN INTEGER.')
         ENDIF
         GOTO 299
C
C COLOUR
 203     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         RED = F1
         GRN = F2
         BLU = F3
         CALL RGB(MAX(0.01,RED),MAX(0.01,GRN),MAX(0.01,BLU))
         GCHANGE = .TRUE.
         GOTO 299
C
C WIDTH
 204     CONTINUE
         IF( .NOT.HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         WID = F1
         CALL LINSF(WID)
         GCHANGE = .TRUE.
         GOTO 299
C
C MARKER
 205     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),INT1,1,LNBC(ARGS(1),1,1)) )
     +      GOTO 9093
         MARKNUM = INT1
         IF( MARKNUM .LT. 3 .OR. MARKNUM .GT. 25 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2052)
 2052       FORMAT(1X,'MARK NUMBERS 3 (DEF) TO 25 ONLY DEFINED.')
            MARKNUM = 3
         ENDIF
         GOTO 299
 2051    CONTINUE
         IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         WRITE(6,2022)
         GOTO 299
C
C CLEAR (FRAME)
 206     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL FRAME
         GCHANGE = .TRUE.
         CALL GFLUSH(IDEV,NDEVS,.FALSE.)
         GOTO 299
C
C MOVE
 207     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         XPOS = F1
         YPOS = F2
         CALL OFF2(XPOS,YPOS)
         GCHANGE = .TRUE.
         GOTO 299
C
C DRAW
 208     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         XPOS = F1
         YPOS = F2
         CALL ON2(XPOS,YPOS)
         GCHANGE = .TRUE.
         GOTO 299
C
C TEXT
 209     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL SYMTXT( ARGS(1)(1:LNBC(ARGS(1),1,1)) )
         GCHANGE = .TRUE.
         GOTO 299
C READ
 210     CONTINUE
         NDATA = 0
         NEVAL = 0
         HAVDATA = .FALSE.
         HAVYE = .FALSE.
         HAVXE = .FALSE.
         IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         IF(AUTOGET)THEN
            IF( ARGS(1)(1:LNBC(ARGS(1),1,1)) .NE. 'HERE' )THEN
               CALL PF('GET',ARGS(1),ARGS(1),'NA','IGNR','RC',IPFERR)
               IF( IPFERR .NE.0 )THEN
                  IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
                  WRITE(6,2101)IPFERR
 2101             FORMAT(1X,'PFERROR ',I4,' OCCURRED.')
                  WRITE(6,2102)ARGS(1)(1:LNBC(ARGS(1),1,1))
 2102             FORMAT(1X,'DOES INDIRECT FILE ',A,' EXIST?')
               ENDIF
            ENDIF
         ENDIF
         CALL DOREAD(ARGS(1),ARGS(2),ARGS(3),DA(IXOFF),DA(IYOFF),
     +               NPOINTS,NDATA,ISTAT,INUNIT,
     +               ARGS(4),ARGS(5),DA(IAOFF),DA(IBOFF),ICARGS)
         IF( ISTAT .EQ. 1 .AND. NDATA .GT. 0 )THEN
            HAVDATA = .TRUE.
            IF( ICARGS .GE. 4 )HAVYE = .TRUE.
            IF( ICARGS .EQ. 5 )HAVXE = .TRUE.
            IF( HAVYE .AND. HAVXE .AND. LASYME )THEN
               CALL AREPACK(DA(IXOFF),DA(IYOFF),DA(IAOFF),DA(IBOFF),
     +                      NDATA)
            ELSE IF( HAVYE .OR. HAVXE )THEN
               CALL REPACK(DA(IXOFF),DA(IYOFF),DA(IAOFF),DA(IBOFF),
     +                     NDATA)
            ENDIF
         ENDIF
         IF(HAVDEV)CALL GOGRAF(IDEV,NDEVS)
         GOTO 299
C
C XYPOINT
C XYLINE
C XYHISTOGRAM
 211     CONTINUE
 212     CONTINUE
 237     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. HAVDATA )GOTO 9095
C---- SET AXIS MODES AND RANGES.
         IF( .NOT. KEEPAX )THEN
            IF( DOXLOG )THEN
               CALL LOGX
            ELSE
               CALL LINX
            ENDIF
            IF( DOYLOG )THEN
               CALL LOGY
            ELSE
               CALL LINY
            ENDIF
            IF( DOXYAUT )THEN
               CALL AUTOXY
            ELSE IF( DOXRAN .AND. DOYRAN )THEN
               CALL XAXIS(XLO,XHI)
               CALL YAXIS(YLO,YHI)
            ELSE IF( DOXRAN )THEN
               CALL XAXIS(XLO,XHI)
               CALL AUTOY
            ELSE IF( DOYRAN )THEN
               CALL YAXIS(YLO,YHI)
               CALL AUTOX
            ELSE
               CALL AUTOXY
            ENDIF
            HAVAX = .TRUE.
         ELSE
            CALL SAMEXY
         ENDIF
C---- DRAW THE GRAPH.
         IF( ICMD .EQ. KXYPT )THEN
            IF( HAVXE .AND. HAVYE )THEN
               IF( LASYME )THEN
                  CALL PTPLTE(DA(IXOFF),DA(IAOFF),NDATA,MARKNUM,1,3)
               ELSE
                  CALL PTPLTE(DA(IXOFF),DA(IYOFF),NDATA,MARKNUM,2,2)
               ENDIF
            ELSE IF( HAVYE )THEN
               CALL PTPLTE(DA(IXOFF),DA(IYOFF),NDATA,MARKNUM,1,2)
            ELSE
               CALL PTPLOT(DA(IXOFF),DA(IYOFF),NDATA,MARKNUM)
            ENDIF
         ELSE IF( ICMD .EQ. KHIST )THEN
            FBW = 0.0
            IF( IHIST .EQ. KHABUT .OR. IHIST .EQ. KHABUTS )THEN
               FBW = -1.0
            ELSE IF( IHIST .EQ. KHLINE )THEN
               FBW = 0.0
            ELSE
               FBW = WHIST
            ENDIF
            IF( IHIST .EQ. KHABUTS .OR. IHIST .EQ. KHWIDS )THEN
               SHDSPC = 0.02 * ( XHI - XLO )
               CALL SHDEGR(DA(IXOFF),DA(IYOFF),NDATA,FBW,45.0,SHDSPC)
               CALL ENPANE
            ELSE
               CALL HISTGR(DA(IXOFF),DA(IYOFF),NDATA,FBW)
            ENDIF
         ELSE
            IF( HAVXE .AND. HAVYE )THEN
               IF(DEBUGON)CALL SHOW2D(DA(IXOFF),DA(IYOFF),NDATA,2,2)
               IF( LASYME )THEN
                  IF( INTERPM .EQ. KILIN )THEN
                     CALL GRAPHE(DA(IXOFF),DA(IAOFF),NDATA,1,3)
                  ELSE IF( INTERPM .EQ. KICUB )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY3E(DA(IXOFF),DA(IAOFF),NDATA,1,3)
                  ELSE IF( INTERPM .EQ. KIQUIN )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY5E(DA(IXOFF),DA(IAOFF),NDATA,1,3)
                  ENDIF
               ELSE
                  IF( INTERPM .EQ. KILIN )THEN
                     CALL GRAPHE(DA(IXOFF),DA(IYOFF),NDATA,2,2)
                  ELSE IF( INTERPM .EQ. KICUB )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY3E(DA(IXOFF),DA(IYOFF),NDATA,2,2)
                  ELSE IF( INTERPM .EQ. KIQUIN )THEN
                     CALL INTERP(NINTERP)
                     CALL POLY5E(DA(IXOFF),DA(IYOFF),NDATA,2,2)
                  ENDIF
               ENDIF
            ELSE IF( HAVYE )THEN
               IF(DEBUGON)CALL SHOW2D(DA(IXOFF),DA(IYOFF),NDATA,1,2)
               IF( INTERPM .EQ. KILIN )THEN
                  CALL GRAPHE(DA(IXOFF),DA(IYOFF),NDATA,1,2 )
               ELSE IF( INTERPM .EQ. KICUB )THEN
                  IF( NDATA .LT. 3 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY3E(DA(IXOFF),DA(IYOFF),NDATA,1,2)
               ELSE IF( INTERPM .EQ. KIQUIN )THEN
                  IF( NDATA .LT. 5 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY5E(DA(IXOFF),DA(IYOFF),NDATA,1,2)
               ENDIF
            ELSE
               IF( INTERPM .EQ. KILIN )THEN
                  IF(DEBUGON)CALL SHOW1D(DA(IXOFF),DA(IYOFF),NDATA)
                  CALL GRAPH(DA(IXOFF),DA(IYOFF),NDATA)
               ELSE IF( INTERPM .EQ. KICUB )THEN
                  IF( NDATA .LT. 3 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY3(DA(IXOFF),DA(IYOFF),NDATA)
               ELSE IF( INTERPM .EQ. KIQUIN )THEN
                  IF( NDATA .LT. 5 )GOTO 2114
                  CALL INTERP(NINTERP)
                  CALL POLY5(DA(IXOFF),DA(IYOFF),NDATA)
               ENDIF
            ENDIF
         ENDIF
C---- ADD ANNOTATION, TICKS, GRIDS, FRAME / EDGES / AXES
         IF( DOANNOT )THEN
            IF( HAVTIT )CALL UTITLE(TITLE(1:LNBC(TITLE,1,1)))
            IF( HAVXLAB )CALL LXLAB(XLABEL(1:LNBC(XLABEL,1,1)))
            IF( HAVYLAB )CALL LYLAB(YLABEL(1:LNBC(YLABEL,1,1)))
            IF( IGSTY .EQ. KGNORM )THEN
               CALL LUXTIK
               CALL LRYTIK
               CALL LXVAL
               CALL LYVAL
            ELSE IF( IGSTY .EQ. KGOPEN )THEN
               CALL LXOPT
               CALL LYOPT
               CALL LXVAL
               CALL LYVAL
            ELSE
               CALL AXCUT(AXCX0,AXCY0)
               CALL LXATIK
               CALL LYATIK
               CALL LXAVAL
               CALL LYAVAL
            ENDIF
            GOTO(2119,2111,2112,2113),IDOGRID
 2111       CONTINUE
               CALL XGRID
               GOTO 2119
 2112       CONTINUE
               CALL YGRID
               GOTO 2119
 2113       CONTINUE
               CALL XYGRID
 2119       CONTINUE
            IF( IGSTY .EQ. KGNORM )THEN
               CALL GRFRAM
            ELSE IF( IGSTY .EQ. KGOPEN )THEN
               CALL EDGES(0011,0)
            ELSE
               CALL DRAWXA
               CALL DRAWYA
            ENDIF
         ELSE IF( DORIGHT )THEN
            IF(HAVRLAB)CALL RYLAB(RYLABEL(1:LNBC(RYLABEL,1,1)))
            CALL RYOPT
            CALL RYVAL
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
 2114    CONTINUE
         CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         WRITE(6,2115)NDATA,POLNAM(INTERPM)
 2115    FORMAT(1X,I1,' POINTS TOO FEW FOR ',A7,'INTERPOLATION.')
         GOTO 299
C
C XYAUTO
 213     CONTINUE
         KEEPAX = .FALSE.
         DOXYAUT = .TRUE.
         DOXRAN = .FALSE.
         DOYRAN = .FALSE.
         GOTO 299
C
C XRANGE
 214     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         XLO = F1
         XHI = F2
         KEEPAX = .FALSE.
         DOXYAUT = .FALSE.
         DOXRAN = .TRUE.
         GOTO 299
C
C YRANGE
 215     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         YLO = F1
         YHI = F2
         KEEPAX = .FALSE.
         DOXYAUT = .FALSE.
         DOYRAN = .TRUE.
         GOTO 299
C
C XYSAME
 216     CONTINUE
         IF( .NOT. HAVAX )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2161)
 2161       FORMAT(1X,'AXES NOT YET DETERMINED. CANNOT KEEP.')
         ELSE
            KEEPAX = .TRUE.
         ENDIF
         GOTO 299
C
C XLINEAR
 217     CONTINUE
         DOXLOG = .FALSE.
         GOTO 299
C
C YLINEAR
 218     CONTINUE
         DOYLOG = .FALSE.
         GOTO 299
C
C XLOG
 219     CONTINUE
         DOXLOG = .TRUE.
         GOTO 299
C
C YLOG
 220     CONTINUE
         DOYLOG = .TRUE.
         GOTO 299
C
C XYGRID
 221     CONTINUE
         IGRID = LOOKUP(GRDNAM,NGRD,ARGS(1),.FALSE.,.TRUE.)
         IF( IGRID .EQ. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2211)
 2211       FORMAT(1X,'UNKNOWN GRID MODE. TRY HELP.')
         ELSE IF( IGRID .LT. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2212)
 2212       FORMAT(1X,'AMBIGUOUS GRID MODE TRY HELP.')
         ELSE
            IDOGRID = IGRID
         ENDIF
         GOTO 299
C OBEY
C SAVE ANY ARGUMENT TO OBEY ON A STACK OF ARGUMENTS.
 222     CONTINUE
         IF( IDEP .EQ. MAXDEP )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2221)MAXDEP
 2221       FORMAT(1X,'OBEY NESTING OF MAX ',I1,' EXCEEDED.')
         ELSE
            IF( ICARGS .EQ. 2 )THEN
               OBPSTK(IDEP+1) = ARGS(2)
            ELSE
               OBPSTK(IDEP+1) = ' '
            ENDIF
            IF(AUTOGET)THEN
               CALL PF('GET',ARGS(1),ARGS(1),'NA','IGNR','RC',IPFERR)
               IF( IPFERR .NE. 0 )THEN
                  IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
                  WRITE(6,2101)IPFERR
                  WRITE(6,2102)ARGS(1)(1:LNBC(ARGS(1),1,1))
               ENDIF
            ENDIF
            CALL DOOBEY(ARGS(1),INUNIT,ISTAT)
         ENDIF
         GOTO 299
C
C EXIT
 223     CONTINUE
         GOTO 2
C HELP
 224     CONTINUE
         IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         CALL DOHELP(CMDS,NCMDS,DCMDS,DEVNAM,NDEVS,DDEVS)
         GOTO 299
C
C BOUNDS
 225     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            WRITE(6,2251)
 2251       FORMAT(1X,'INVALID BOUNDS SPECIFICATION.')
         ELSE
            XLO = F1
            XHI = F2
            YLO = F3
            YHI = F4
            CALL BOUNDS(XLO,XHI,YLO,YHI)
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C TITLE
 226     CONTINUE
         TITLE = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVTIT = .TRUE.
         GOTO 299
C
C XLABEL
 227     CONTINUE
         XLABEL = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVXLAB = .TRUE.
         GOTO 299
C
C YLABEL
 228     CONTINUE
         YLABEL = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVYLAB = .TRUE.
         GOTO 299
C
C MEMTEST
 229     CONTINUE
         CALL MEMTEST(NPOINTS,DA(IXOFF),DA(IYOFF),DA(IAOFF),DA(IBOFF))
         HAVDATA = .TRUE.
         NDATA = NPOINTS
         GOTO 299
C
C STYLE
 230     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         ISTY = LOOKUP(STYNAM,NSTY,ARGS(1),.FALSE.,.TRUE.)
         IF( ISTY .EQ. 0 )THEN
            CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2301)
 2301       FORMAT(1X,'UNKNOWN STYLE MODE. TRY HELP.')
         ELSE IF( ISTY .LT. 0 )THEN
            CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2302)
 2302       FORMAT(1X,'AMBIGUOUS STYLE MODE TRY HELP.')
         ELSE
            GOTO(2303,2304,2305,2306),ISTY
 2303       CONTINUE
               CALL DSHOFF
            GOTO 2309
 2304       CONTINUE
               CALL DASH
            GOTO 2309
 2305       CONTINUE
               CALL DOT
            GOTO 2309
 2306       CONTINUE
               CALL DSHDOT
            GOTO 2309
 2309       CONTINUE
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C GET
 231     CONTINUE
         CALL PF('GET',ARGS(1),ARGS(1),'NA','IGNR','RC',IPFERR)
         IF( IPFERR .NE.0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2101)IPFERR
            WRITE(6,2102)ARGS(1)(1:LNBC(ARGS(1),1,1))
         ENDIF
         GOTO 299
C
C STATUS
 232     CONTINUE
         IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         WRITE(6,*)'GPLOT STATUS:'
         WRITE(6,*)'CURRENT OBEY DEPTH = ',IDEP
         IF( AUTOGET )THEN
            WRITE(6,*)'AUTOMATIC FILE GET ON FOR READ & OBEY.'
         ELSE
            WRITE(6,*)'READ & OBEY OF LOCAL FILES. MANUAL GET REQD.'
         ENDIF
         IF( HAVDEV )THEN
            WRITE(6,*)'DEVICE = ',DEVNAM(IDEV)
         ELSE
            WRITE(6,*)'NO DEVICE OPEN YET.'
         ENDIF
         WRITE(6,*)'MAX POINTS = ',NPOINTS
         WRITE(6,*)'MAX STACK = ',NSTACK
         CALL CMMGFS(1,0,NAVAIL)
         WRITE(6,*)'AVAILABLE WORDS OF DYNAMIC MEMORY = ',NAVAIL
         IF( HAVDATA )THEN
            WRITE(6,*)'DATA POINTS READ/EVALUATED = ',NDATA
         ELSE
            WRITE(6,*)'NO DATA READ/EVALUATED YET.'
         ENDIF
         IF( NEVAL .GT. 0 )THEN
            WRITE(6,*)'RANGE STEPS = ',NEVAL
            WRITE(6,*)'RANGE BASE = ',RBASE,' (1:LINEAR, >1:LOG)'
            WRITE(6,*)'RANGE START = ',RSTART
            WRITE(6,*)'RANGE STOP = ',RSTOP
         ELSE
            WRITE(6,*)'NO FUNCTION EVALUATION RANGE ESTABLISHED.'
         ENDIF
         IF( HAVXE .AND. HAVYE )THEN
            IF( LASYME )THEN
               WRITE(6,*)'DRAWING ASYMMETRIC Y ERROR BAR DATA.'
            ELSE
               WRITE(6,*)'DRAWING Y AND X SYMMETRIC ERROR BAR DATA.'
            ENDIF
         ELSE IF( HAVYE )THEN
            WRITE(6,*)'DRAWING Y ERROR BAR DATA.'
         ELSE IF( HAVXE )THEN
            WRITE(6,*)'DRAWING X ERROR BAR DATA.'
         ELSE
            WRITE(6,*)'NO ERROR BAR DATA READ.'
         ENDIF
         IF( HAVAX )THEN
            WRITE(6,*)'AXIS RANGES HAVE BEEN DETERMINED.'
         ELSE
            WRITE(6,*)'AXIS RANGES NOT DETERMINED YET.'
         ENDIF
         IF( DOANNOT )THEN
            WRITE(6,*)'GRAPH ANNOTATION ON.'
         ELSE
            WRITE(6,*)'GRAPH ANNOTATION OFF.'
         ENDIF
         IF( DORIGHT )THEN
             WRITE(6,*)'RIGHT EDGE ANNOTATION ON.'
         ELSE
             WRITE(6,*)'RIGHT EDGE ANNOTATION OFF.'
         ENDIF
         WRITE(6,*)'INTERPOLATION = ',POLNAM(INTERPM)
         WRITE(6,*)'HISTOGRAM MODE = ',HISTNAM(IHIST)
         WRITE(6,*)'HISTOGRAM BAR WIDTH = ',WHIST
         WRITE(6,*)'GRAPH STYLE = ',GSTYNAM(IGSTY)
         WRITE(6,*)'AXES CROSS AT ',AXCX0,' , ',AXCY0
         WRITE(6,*)'BOUNDS = ',XLO,' TO ',XHI,' BY ',
     +                         YLO,' TO ',YHI
         IF( LPANE )THEN
            WRITE(6,*)'PANE = ',PXL,' TO ',PXH,' BY ',
     +                          PYL,' TO ',PYH
         ELSE
            WRITE(6,*)'NO PANE ACTIVE.'
         ENDIF
         IF( LBLNK )THEN
            WRITE(6,*)'BLANK = ',BXL,' TO ',BXH,' BY ',
     +                           BYL,' TO ',BYH
         ELSE
            WRITE(6,*)'NO BLANK AREA ACTIVE.'
         ENDIF
         WRITE(6,*)'XPOS,YPOS = ',XPOS,' , ',YPOS
         WRITE(6,*)'GXPOS,GYPOS = ',GXPOS,' , ',GYPOS
         WRITE(6,*)'MARKER NUMBER = ',MARKNUM
         IF( HAVFLOG )THEN
            WRITE(6,*)'LOG FILE IS OPEN'
         ELSE
            WRITE(6,*)'NO LOG FILE OPEN.'
         ENDIF
         DO 2321 I=1,NREGS
            IF( PROCLEN(I) .GT. 0 )THEN
               WRITE(6,*)'PROCEDURE REGISTER ',I,' CONTAINS:'
               WRITE(6,2322)PROC(I)(1:PROCLEN(I))
 2322          FORMAT(1X,A)
            ENDIF
 2321    CONTINUE
         IF( DOBB )THEN
            WRITE(6,*)'EVAL IN BOUNDING BOX ACCUMULATION MODE.'
         ELSE
            WRITE(6,*)'EVAL IN GRAPHICS RENDERING MODE.'
         ENDIF
         IF( BBEMPTY(BB) )THEN
            WRITE(6,*)'EVAL BOUNDING BOX IS EMPTY.'
         ELSE
            WRITE(6,*)'EVAL BOUNDING BOX: XLO=',BB(1),
     +                ' XHI=',BB(2),' YLO=',BB(3),' YHI=',BB(4)
         ENDIF
         WRITE(6,*)'ALPHABET 1: ',
     +             FONTNAM(IDXABT1)(1:LNBC(FONTNAM(IDXABT1),1,1))
         WRITE(6,*)'ALPHABET 2: ',
     +             FONTNAM(IDXABT2)(1:LNBC(FONTNAM(IDXABT2),1,1))
         WRITE(6,*)'ALPHABET 3: ',
     +             FONTNAM(IDXABT3)(1:LNBC(FONTNAM(IDXABT3),1,1))
         WRITE(6,*)'SYMBOLS: ',
     +             FONTNAM(IDXSYMB)(1:LNBC(FONTNAM(IDXSYMB),1,1))
         WRITE(6,*)'MARKERS: ',
     +             FONTNAM(IDXMARK)(1:LNBC(FONTNAM(IDXMARK),1,1))
         WRITE(6,*)'SYMBOL DRAWING HEIGHT, BOUNDS UNITS: ',FSYMHT
         WRITE(6,*)'SYMBOL DRAWING ANGLE, CCW WRT X AXIS, DEG: ',FSYMANG
         DO 2324 I=1,NREGS
            IF( STRILEN(I) .GT. 0 )THEN
               WRITE(6,*)'STRING REGISTER ',I,' CONTAINS:'
               WRITE(6,2322)STRINGS(I)(1:STRILEN(I))
            ENDIF
 2324    CONTINUE
         IF( TXTCON )THEN
            WRITE(6,*)'TEXT CONTINUATION ON'
         ELSE
            WRITE(6,*)'TEXT CONTINUATION OFF'
         ENDIF
         GOTO 299
C
C ANNOT
 233     CONTINUE
         DOANNOT = GETYN(ARGS(1))
         GOTO 299
C
C LOGFILE
 234     CONTINUE
         IF( HAVFLOG )THEN
            CLOSE(UNIT=3,ERR=2343)
 2343       CONTINUE
         ENDIF
         IFNE = LNBC(ARGS(1),1,1)
         IF( IFNE .GT. 7 )IFNE = 7
         OPEN(UNIT=3,FILE=ARGS(1)(1:IFNE),STATUS='NEW',ERR=2341)
         HAVFLOG = .TRUE.
         GOTO 299
 2341    CONTINUE
         IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         WRITE(6,2342)ARGS(1)(1:IFNE)
 2342    FORMAT(1X,'CANNOT CREATE LOG FILE: ',A7)
         HAVFLOG = .FALSE.
         GOTO 299
C
C INTERP
 235     CONTINUE
         INTM = LOOKUP(POLNAM,NPOL,ARGS(1),.FALSE.,.TRUE.)
         IF( INTM .EQ. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2351)
 2351       FORMAT(1X,'UNKNOWN INTERP MODE. TRY HELP.')
         ELSE IF( INTM .LT. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2352)
 2352       FORMAT(1X,'AMBIGUOUS INTERP MODE. TRY HELP.')
         ELSE
            INTERPM = INTM
         ENDIF
         IF( ICARGS .EQ. 2 )THEN
            IF( .NOT. IFROMC(ARGS(2),NINTERP,1,LNBC(ARGS(2),1,1)) )
     +          GOTO 9093
            IF(NINTERP .LT. 5)NINTERP = 5
         ENDIF
         GOTO 299
C
C ASYMYERRORBARS
 236     CONTINUE
         LASYME = GETYN(ARGS(1))
         GOTO 299
C
C HISTSTYLE
 238     CONTINUE
         IHMD = LOOKUP(HISTNAM,NHIST,ARGS(1),.FALSE.,.TRUE.)
         IF( IHMD .EQ. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2381)
 2381       FORMAT(1X,'UNKNOWN HISTOGRAM STYLE. TRY HELP.')
         ELSE IF( IHMD .LT. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2382)
 2382       FORMAT(1X,'AMBIGUOUS HISTOGRAM STYLE. TRY HELP.')
         ELSE
            IHIST = IHMD
         ENDIF
         IF( ICARGS .EQ. 2 )THEN
            IF( .NOT. RFROMC(ARGS(2),F1,1,LNBC(ARGS(2),1,1)) )
     +         GOTO 9098
            WHISTIN = F1
            IF(WHISTIN .LT. 0.0)WHISTIN = 0.0
            WHIST = WHISTIN
         ENDIF
         GOTO 299
C
C PANE
 239     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            WRITE(6,2391)
 2391       FORMAT(1X,'INVALID PANE SPECIFICATION.')
         ELSE
            PXL = F1
            PXH = F2
            PYL = F3
            PYH = F4
            CALL PANE(PXL,PXH,PYL,PYH)
         ENDIF
         LPANE = .TRUE.
         GCHANGE = .TRUE.
         GOTO 299
C
C UNPANE
 240     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL ENPANE
         LPANE = .FALSE.
         GOTO 299
C
C PANEOUTLINE
 241     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. LPANE )THEN
            CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2411)
 2411       FORMAT(1X,'WARNING - NO PANE ACTIVE.')
         ELSE
            CALL OPANE
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C BLANK
 242     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            WRITE(6,2421)
 2421       FORMAT(1X,'INVALID BLANK SPECIFICATION.')
         ELSE
            BXL = F1
            BXH = F2
            BYL = F3
            BYH = F4
            CALL BLANK(BXL,BXH,BYL,BYH)
         ENDIF
         LBLNK = .TRUE.
         GCHANGE = .TRUE.
         GOTO 299
C
C UNBLANK
 243     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL ENBLNK
         LBLNK = .FALSE.
         GOTO 299
C
C BLANKOUTLINE
 244     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. LBLNK )THEN
            CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2411)
 2441       FORMAT(1X,'WARNING - NO BLANK AREA ACTIVE.')
         ELSE
            CALL OBLANK
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C FILL
 245     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL DEVFILL(IDEV,NDEVS,RED,GRN,BLU)
         GOTO 299
C
C ROUTE
 246     CONTINUE
         CALL EPSRUT(ARGS(1)(1:LNBC(ARGS(1),1,1)))
         GOTO 299
C
C EVAL
C ITEVAL
 247     CONTINUE
         ITERST = 1
         ITEREN = 1
         ITERIN = 1
         IAP = 1
         GOTO 2473
 253     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),ITERST,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( .NOT. IFROMC(ARGS(2),ITEREN,1,LNBC(ARGS(2),1,1)) )GOTO 9093
         IF( .NOT. IFROMC(ARGS(3),ITERIN,1,LNBC(ARGS(3),1,1)) )GOTO 9093
         IAP = 4
 2473    CONTINUE
         IF( NEVAL .EQ. 0 )THEN
            IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2471)
 2471       FORMAT(1X,'NO ERANGE HAS BEEN SET.')
         ELSE
            LEXPROC = EXPROC(ARGS(IAP)(1:LNBC(ARGS(IAP),1,1)), PROCEXP,
     +                       PROC, PROCLEN, NREGS )
            IF( LEXPROC .GT. 0 )THEN
               DO 2472 ITER=ITERST,ITEREN,ITERIN
                  IF( EVAL(DA(IXOFF),NEVAL,NPOINTS,NWORDS,NSTACK,
     +                     PROCEXP(1:LEXPROC),
     +                     HAVDEV,IDEV,NDEVS,ITER,MEMS,
     +                     GCHANGE,RBASE,RSTART,RSTOP,
     +                     STRINGS, STRILEN, TXTCON,
     +                     ZEROVAL, BB, DOBB) .EQ. 0 )THEN
                     HAVDATA = .TRUE.
                     NDATA = NEVAL
                  ELSE
                     HAVDATA = .FALSE.
                     NDATA = 0
                     IF( IDEP .GT. 0 .OR. INUNIT .EQ. 8 )THEN
                        WRITE(6,2474)
 2474    FORMAT(1X,'EVAL ERROR IN SCRIPT, RETURNING TO INTERACTIVE.')
                        SEVERR = .TRUE.
                        GOTO 1000
                     ENDIF
                  ENDIF
 2472          CONTINUE
               IF( DOBB )THEN
                  IF( BBEMPTY(BB) )THEN
                     WRITE(6,*)'EVAL BOUNDING BOX IS EMPTY.'
                  ELSE
                     WRITE(6,*)'EVAL BOUNDING BOX UPDATED, XLO=',BB(1),
     +                       ' XHI=',BB(2),' YLO=',BB(3),' YHI=',BB(4)
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
         GOTO 299
C
C ERANGE
 248     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),RBASE,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),RSTART,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),RSTOP,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. IFROMC(ARGS(4),NEVAL,1,LNBC(ARGS(4),1,1)) )GOTO 9093
         IF( (NEVAL .LT. 2) .OR. (NEVAL .GT. NPOINTS) )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2481)NEVAL, NPOINTS
 2481       FORMAT(1X, 'INVALID NUMBER OF PNTS, ',I6,', CUR MAX ',I6)
         ELSE
            IF( RBASE .LE. 1.0 )THEN
               CALL LINSPC(DA(IXOFF),NEVAL,RSTART,RSTOP)
            ELSE
               CALL LOGSPC(DA(IXOFF),NEVAL,RSTART,RSTOP,RBASE)
            ENDIF
         ENDIF
         GOTO 299
C
C PATH
 249     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. HAVDATA )GOTO 9095
         IF( NDATA .GT. 1 )THEN
            CALL PATH(DA(IXOFF),DA(IYOFF),NDATA,(ARGS(1)(1:1).EQ.'C'))
            GCHANGE = .TRUE.
         ENDIF
         GOTO 299
C
C GRMOVE
 250     CONTINUE
         DOGRON = .FALSE.
         GOTO 2502
 251     CONTINUE
         DOGRON = .TRUE.
 2502    CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         GXPOS = F1
         GYPOS = F2
         IF( DOGRON )THEN
            CALL GRON(GXPOS,GYPOS)
         ELSE
            CALL GROFF(GXPOS,GYPOS)
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C NSTACK
 252     CONTINUE
         IF( IFROMC(ARGS(1),IWANT,1,NEWPOS) )THEN
            IF(IWANT .LT. 4 .OR. IWANT .GT. MAXSTK )THEN
               IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
               WRITE(6,2521)IWANT,MAXSTK
 2521          FORMAT(1X,I7,' NSTACK .LT. 4 OR .GT. ',I2,' INVALID.')
               GOTO 299
            ENDIF
            NSTACK = IWANT
            CALL CMMFRF(IFWA)
            CALL CMMGFS(1,0,NAVAIL)
            WRITE(6,2523)NAVAIL
 2523       FORMAT(1X,'WORDS AVAILABLE: ',I6,' INCLUDING 1000 EXCESS.')
            NWORDS = NSTACK * NPOINTS
            IF( NWORDS .GT. (NAVAIL-1000) )THEN
               WRITE(6,2524)NSTACK,NPOINTS,NWORDS,NAVAIL-1000
 2524          FORMAT(1X,'NSTACK:',I6,' NPOINTS:',I6,' = ',I6,' WORDS,',
     +                ' EXCEEDS MAX AVAIL:',I6)
               NWORDS = NAVAIL - 1000
               NPOINTS = NWORDS / NSTACK
               WRITE(6,2525)NPOINTS
 2525          FORMAT(1X,'ALLOCATING MAXIMUM. NPOINTS = ',I6)
            ENDIF
            CALL CMMALF(NWORDS,0,0,IFWA)
            IOFF = IFWA - LOCF(DA(1))
            IXOFF = IOFF + 1
            IYOFF = IXOFF + NPOINTS
            IAOFF = IYOFF + NPOINTS
            IBOFF = IAOFF + NPOINTS
            WRITE(6,2526)NSTACK
 2526       FORMAT(1X,'ALLOCATED SPACE FOR ',I2,' STACK LEVELS.')
            HAVDATA = .FALSE.
            IF( NEVAL .GT. NPOINTS )NEVAL = 0
         ELSE
            GOTO 9093
         ENDIF
         GOTO 299
C
C ITEVAL - 253 - SEE 247 EVAL.
C
C PROC
 254     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            WRITE(6,2541)IREG
 2541       FORMAT(1X,I3,' IS NOT A VALID REGISTER NUMBER.')
         ELSE
            PROC(IREG) = ARGS(2)
            PROCLEN(IREG) = LNBC(ARGS(2),1,0)
         ENDIF
         GOTO 299
C
C STO
 255     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            WRITE(6,2541)IREG
         ELSE
            IF( .NOT. RFROMC(ARGS(2),F1,1,LNBC(ARGS(2),1,1)) )GOTO 9098
            MEMS(IREG) = F1
         ENDIF
         GOTO 299
C
C RCL
 256     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            WRITE(6,2541)IREG
         ELSE
            WRITE(6,2561)IREG, MEMS(IREG)
 2561       FORMAT(1X,'MEMS(',I1,') = ', G13.6)
         ENDIF
         GOTO 299
C
C CANVAS
 257     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(2),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(3),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(4),1,1)) )GOTO 9098
         IF( F1 .GE. F2 .OR. F3 .GE. F4 )THEN
            WRITE(6,2571)
 2571       FORMAT(1X,'INVALID CANVAS SPECIFICATION.')
         ELSE
            XLO = PXL = F1
            XHI = PXH = F2
            YLO = PYL = F3
            YHI = PYH = F4
            CALL BOUNDS(XLO,XHI,YLO,YHI)
            CALL PANE(PXL,PXH,PYL,PYH)
         ENDIF
         LPANE = .TRUE.
         GCHANGE = .TRUE.
         GOTO 299
C CTEXT
 258     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         TWD = F1
         TWIDTH = STRING( ARGS(2)(1:LNBC(ARGS(2),1,1)) )
         IF( TWD .GT. 0.0 )THEN
            CALL SYMHT(TWD/TWIDTH)
            TWIDTH = TWD
         ENDIF
         CALL OFF2(XPOS-TWIDTH/2,YPOS)
         CALL SYMTXT( ARGS(2)(1:LNBC(ARGS(2),1,1)) )
         IF( TWD .GT. 0.0 )THEN
            CALL SYMHT((XHI-XLO)/50.0)
         ENDIF
         GCHANGE = .TRUE.
         GOTO 299
C
C FONT SELECTION.
 259     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IFONT = LOOKUP(FONTNAM,NFONTS,ARGS(2)(1:LNBC(ARGS(2),1,1)),
     +                  .FALSE.,.TRUE.)
         IF( IFONT .EQ. 0 )THEN
            WRITE(6,2591)
 2591       FORMAT(1X,'UNKNOWN FONT, MARKER OR SYMBOL FONT NAME.')
         ELSE IF( IFONT .LT. 0 )THEN
            WRITE(6,2592)
 2592       FORMAT(1X,'AMBIGUOUS FONT, MARKER OR SYMBOL FONT NAME.')
         ELSE
            IF( ARGS(1)(1:1) .EQ. '1' )THEN
               IF( FONTNUM(IFONT) .GE. 8000 )GOTO 2594
               CALL LDABET(1,FONTNUM(IFONT))
               IDXABT1 = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. '2' )THEN
               IF( FONTNUM(IFONT) .GE. 8000 )GOTO 2594
               CALL LDABET(2,FONTNUM(IFONT))
               IDXABT2 = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. '3' )THEN
               IF( FONTNUM(IFONT) .GE. 8000 )GOTO 2594
               CALL LDABET(3,FONTNUM(IFONT))
               IDXABT3 = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. 'S' )THEN
               IF( FONTNUM(IFONT) .GE. 9000 .OR.
     +             FONTNUM(IFONT) .LT. 8001 )GOTO 2594
               CALL LDSYM(FONTNUM(IFONT))
               IDXSYMB = IFONT
            ELSE IF( ARGS(1)(1:1) .EQ. 'M' )THEN
               IF( FONTNUM(IFONT) .LT. 9001 )GOTO 2594
               CALL LDMARK(FONTNUM(IFONT))
               IDXMARK = IFONT
            ELSE
               WRITE(6,2593)
 2593          FORMAT(1X,'UNKNOWN FONT TYPE (NOT 1,2,3,S,M)')
            ENDIF
            GOTO 2596
 2594       CONTINUE
            WRITE(6,2595)ARGS(1)(1:1)
 2595       FORMAT(1X,'FONT INAPPROPRIATE FOR USE WITH SET: ',A)
 2596       CONTINUE
         ENDIF
         GOTO 299
C
C LIST FONTS
 260     CONTINUE
         DO 2601 I=1,NFONTS
            CFONMK = ' '
            IF( FONTNUM(I) .LT. 8001 )THEN
               IF( I .EQ. IDXABT1 )THEN
                  CFONMK = '1'
               ELSE IF( I .EQ. IDXABT2 )THEN
                  CFONMK = '2'
               ELSE IF( I .EQ. IDXABT3 )THEN
                  CFONMK = '3'
               ENDIF
               WRITE(6,2602)FONTNAM(I), 'ALPHABETIC', CFONMK
            ELSE IF( FONTNUM(I) .LT. 9000 )THEN
               IF( I .EQ. IDXSYMB )CFONMK = 'S'
               WRITE(6,2602)FONTNAM(I), 'SYMBOL', CFONMK
            ELSE
               IF( I .EQ. IDXMARK )CFONMK = 'M'
               WRITE(6,2602)FONTNAM(I), 'MARKER', CFONMK
            ENDIF
 2601    CONTINUE
 2602    FORMAT(1X,A30,A15,1X,A1)
         GOTO 299
C
C TEXT / SYMBOL / MARKER DRAWING HEIGHT.
 261     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         FSYMHT = F1
         CALL SYMHT(FSYMHT)
         CALL MARKHT(FSYMHT)
         GOTO 299
C
C TEXT / SYMBOL DRAWING ANGLE.
 262     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         FSYMANG = F1
         CALL SYMANG(FSYMANG)
         GOTO 299
C
C STRING
 263     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            WRITE(6,2541)IREG
         ELSE
            STRINGS(IREG) = ARGS(2)
            STRILEN(IREG) = LNBC(ARGS(2),1,0)
         ENDIF
         GOTO 299
C
C ZEROVAL
 264     CONTINUE
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         ZEROVAL = F1
         GOTO 299
C
C GSTYLE
 265     CONTINUE
         IARG = LOOKUP(GSTYNAM,NGSTY,ARGS(1),.FALSE.,.TRUE.)
         IF( IARG .EQ. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2651)
 2651       FORMAT(1X,'UNKNOWN GRAPH STYLE. TRY HELP.')
         ELSE IF( IARG .LT. 0 )THEN
            IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
            WRITE(6,2652)
 2652       FORMAT(1X,'AMBIGUOUS GRAPH STYLE. TRY HELP.')
         ELSE
            IGSTY = IARG
         ENDIF
         GOTO 299
C
C RYLABEL
 266     CONTINUE
         RYLABEL = ARGS(1)(1:LNBC(ARGS(1),1,1))
         HAVRLAB = .TRUE.
         GOTO 299
C
C RIGHTANNOT
 267     CONTINUE
         DORIGHT = GETYN(ARGS(1))
         GOTO 299
C
C AXCUT
 268     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         AXCX0 = F1
         AXCY0 = F2
         GOTO 299
C
C CIRCLE
 269     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         CALL CIRCLE(F1,F2,F3)
         GOTO 299
C
C ARC
 270     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(5),F5,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         CALL CIRARC(F1,F2,F3,F4,F5)
         GOTO 299
C
C RECT
C CRECT
 271     CONTINUE
 272     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. RFROMC(ARGS(1),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(2),F2,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(3),F3,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( .NOT. RFROMC(ARGS(4),F4,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( ICMD .EQ. KCRECT )THEN
            F1 = F1 - 0.5 * F3
            F2 = F2 - 0.5 * F4
         ENDIF
         CALL RECT(F1,F2,0.0,F3,F4)
         GOTO 299
C
C BBSTART - EVAL/ITEVAL TO FIND BOUNDING BOX ONLY.
 273     CONTINUE
         BB(1) = 1.0E300
         BB(2) = -1.0E300
         BB(3) = 1.0E300
         BB(4) = -1.0E300
         DOBB = .TRUE.
         WRITE(6,*)'EVAL/ITEVAL WILL ACCUMULATE BOUNDING BOX.'
         GOTO 299
C
C BBEND - EVAL/ITEVAL TO RETURN TO DRAWING GRAPHICAL ITEMS.
 274     CONTINUE
         DOBB = .FALSE.
         WRITE(6,*)'EVAL/ITEVAL WILL RENDER GRAPHICAL ITEMS.'
         GOTO 299
C
C BBSET - SET BOUNDS TO EVAL BOUNDING BOX (IF ANY).
 275     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( BBEMPTY(BB) )THEN
            WRITE(6,*)'EVAL BOUNDING BOX EMPTY. BOUNDS UNCHANGED.'
         ELSE
            XLO = BB(1)
            XHI = BB(2)
            YLO = BB(3)
            YHI = BB(4)
            CALL BOUNDS(XLO,XHI,YLO,YHI)
            GCHANGE = .TRUE.
            WRITE(6,*)'BOUNDS SET TO EVAL BOUNDING BOX.'
         ENDIF
         GOTO 299
C
C LSYSTEM
 276     CONTINUE
         IF( .NOT. IFROMC(ARGS(1),INT1,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( .NOT. IFROMC(ARGS(2),INT2,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( .NOT. RFROMC(ARGS(3),F1,1,LNBC(ARGS(1),1,1)) )GOTO 9098
         IF( LSYSTEM(INT1, INT2, F1, STRINGS, STRILEN, MEMS) .NE. 0)THEN
            IF( IDEP .GT. 0 .OR. INUNIT .EQ. 8 )THEN
               WRITE(6,2761)
 2761    FORMAT(1X,'LSYSTEM ERROR IN SCRIPT, RETURNING TO INTERACTIVE.')
               SEVERR = .TRUE.
               GOTO 1000
            ENDIF
         ENDIF
         GOTO 299
C
C LOADPROC
 277     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         IF( .NOT. IFROMC(ARGS(1),IREG,1,LNBC(ARGS(1),1,1)) )GOTO 9093
         IF( IREG .LT. 1 .OR. IREG .GT. 9 )THEN
            WRITE(6,2541)IREG
         ELSE
            CALL LDPROC(ARGS(2)(1:LNBC(ARGS(2),1,1)),IREG,PROC,IDEV,
     +                  NDEVS,HAVDEV)
            PROCLEN(IREG) = LNBC(PROC(IREG),1,0)
         ENDIF
         GOTO 299
C
C TXBOX
 278     CONTINUE
         IF( .NOT. HAVDEV )GOTO 9090
         CALL TXBOX(ARGS(1)(1:LNBC(ARGS(1),1,1)), .TRUE.)
         GOTO 299
C
C END OF COMMAND SWITCH
C IF THE GRAPHICS DISPLAY HAS BEEN CHANGED, TRY TO ENSURE THE
C CHANGES ARE MADE VISIBLE - BUT ONLY IF AT INTERACTIVE LEVEL.
 299     CONTINUE
         IF( GCHANGE .AND. IDEP .EQ. 0 )THEN
            IF(HAVDEV)CALL MAKEVIS(IDEV,NDEVS)
            GCHANGE = .FALSE.
         ENDIF
      ENDIF
C
C READ NEXT COMMAND
C
      GOTO 1
C
C HANDLE DEVICE NOT OPENED PROBLEM.
C
 9090 CONTINUE
      WRITE(6,9091)
 9091 FORMAT(1X,'DEVICE MUST BE OPEN FOR THIS COMMAND.')
      GOTO 1
C
C HANDLE INVALID INTEGER NUMBER.
C
 9093 CONTINUE
      IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
      WRITE(6,9094)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 9094 FORMAT(1X,'INVALID INTEGER NUMBER LITERAL FOR ',A,' COMMAND.')
      GOTO 1
C
C HANDLE NO DATA TO PLOT PROBLEM.
C
 9095 CONTINUE
      IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
      WRITE(6,9096)
 9096 FORMAT(1X,'NO DATA READ TO PLOT. USE READ.')
      GOTO 1
C
C HANDLE INVALID REAL NUMBER.
C
 9098 CONTINUE
      IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
      WRITE(6,9099)CMDS(ICMD)(1:LNBC(CMDS(ICMD),1,1))
 9099 FORMAT(1X,'INVALID REAL NUMBER LITERAL FOR ',A,' COMMAND.')
      GOTO 1
C
C TERMINATE. FLUSH. CLOSE. FREE DYNAMIC STORE (NOT REALLY NECESSARY).
C TRY TO PREVENT AN EMPTY LINE ACCIDENTALLY TERMINATING GPLOT.
C BUT ONLY IF INTERACTIVE (ORIGIN TYPE = 3).
C
   2  CONTINUE
      IF( (EOF(7) .NE. 0) .AND. (IGETOT() .EQ. 3) )GOTO 1
      IF( HAVDEV )THEN
         CALL GFLUSH(IDEV,NDEVS,.FALSE.)
         CALL MAKEVIS(IDEV,NDEVS)
         CALL DIMEND
      ENDIF
      CALL CMMFRF(IFWA)
      STOP 'GPLOT FINISHED.'
C
C READ ERROR HANDLER
C
 998  CONTINUE
      STOP 'ERROR READING INPUT.'
      END
C
      SUBROUTINE DOHELP(CMDS,NCMDS,DCMDS,DEVNAM,NDEVS,DDEVS)
C ----------------------------------------------------------
C OUTPUT HELP
C ----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NCMDS, NDEVS
      CHARACTER*(*) CMDS(NCMDS)
      CHARACTER*(*) DCMDS(NCMDS)
      CHARACTER*(*) DEVNAM(NDEVS)
      CHARACTER*(*) DDEVS(NDEVS)
C
      INTEGER I, L
      INTEGER LNBC
C
      WRITE(6,100)
 100  FORMAT(1X,'GPLOT HELP')
      WRITE(6,101)
 101  FORMAT(3X,'AVAILABLE COMMANDS:')
      DO 1 I=1,NCMDS
         WRITE(6,102)CMDS(I)
 102     FORMAT(5X,A)
         L = MIN(120,LNBC(DCMDS(I),1,1))
         WRITE(6,103)DCMDS(I)(1:L)
 103     FORMAT(7X,A)
   1  CONTINUE
      WRITE(6,110)
 110  FORMAT(1X)
      WRITE(6,104)
 104  FORMAT(3X,'AVAILABLE DEVICES:')
      DO 2 I=1,NDEVS
         WRITE(6,105)DEVNAM(I)
 105     FORMAT(5X,A)
         WRITE(6,106)DDEVS(I)
 106     FORMAT(7X,A)
   2  CONTINUE
      RETURN
      END
C
      SUBROUTINE DOOBEY(FNAME,INUNIT,ISTAT)
C ----------------------------------------------
C OPEN AN OBEY FILE AND PREPARE TO READ FROM IT.
C ----------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*)FNAME
      INTEGER INUNIT, ISTAT, IFNE, LNBC
C
      IFNE = LNBC(FNAME,1,1)
      IF( IFNE .GT. 7 )IFNE = 7
      OPEN(UNIT=INUNIT+1,FILE=FNAME(1:IFNE),STATUS='OLD',ERR=2221)
      INUNIT = INUNIT + 1
      REWIND(UNIT=INUNIT)
      ISTAT = 1
      RETURN
 2221 CONTINUE
      WRITE(6,2222)FNAME(1:IFNE)
 2222 FORMAT(1X,'CANNOT OPEN OBEY INPUT FILE ',A)
      ISTAT = 0
      RETURN
      END
C
      SUBROUTINE MEMTEST(N,X,Y,A,B)
C--------------------------------------
C TEST THAT DYNAMIC MEMORY IS WORKING.
C GENERATE TEST DATA.
C--------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL A(N), B(N), X(N), Y(N)
C
      INTEGER I, IX, IY, IA, IB
C
      DO 1 I=1,N
         X(I) = I
         Y(I) = I + 2 * N
         A(I) = I + 3 * N
         B(I) = I + 4 * N
  1   CONTINUE
      IX = N
      IY = 3 * N
      IA = 4 * N
      IB = 5 * N
      WRITE(6,*)'... GOT ',X(N),Y(N),A(N),B(N)
      WRITE(6,*)'... EXPECTED ',IX,IY,IA,IB
      IF((X(N).EQ.IX).AND.(Y(N).EQ.IY).AND.(A(N).EQ.IA).AND.
     +   (B(N).EQ.IB) )THEN
         WRITE(6,*)'OK - DYNAMIC ALLOCATION TEST PASSED.'
         DO 2 I=1,N
            X(I) = 3.0 * 6.283 * FLOAT(I)/N
            Y(I) = SIN(X(I))
  2      CONTINUE
         WRITE(6,*)'GENERATED TEST DATA.'
      ELSE
         WRITE(6,*)'ERROR - DYNAMIC ALLOCATION TEST FAILED.'
      ENDIF
      RETURN
      END
C
      SUBROUTINE DOREAD(FNAME,COL1,COL2,X,Y,NP,NOUT,ISTAT,IUN,
     +                  COL3,COL4,YE,XE,NARG)
C--------------------------------------------------------------
C READ X,Y DATA FROM FILE FNAME USING COLUMNS COL1, COL2.
C RETURN NUMBER OF DATA POINTS READ IN NOUT. MAX NP.
C IF FNAME=HERE, READ FROM IUN UNTIL LINE STARTING EOF FOUND.
C IF COL1=0, USE THE NUMBER OF PTS SO FAR, NOT READ COLUMN.
C--------------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) FNAME, COL1, COL2, COL3, COL4
      INTEGER NP, NOUT, ISTAT, IUN, NARG
      REAL X(NP), Y(NP), YE(NP), XE(NP)
C
      LOGICAL IFROMC, RFROMC
      LOGICAL LHERE
      CHARACTER*80 LINE
      REAL FVAL
      INTEGER IS, IE, ICOL1, ICOL2, INUN, IFNE, ICOL3, ICOL4, IECOL
      INTEGER ILNBC, ILINE, NEWPOS
      INTEGER LNBC
C
C PARSE THE COLUMN NUMBER ARGUMENTS.
C
      IF( .NOT. IFROMC(COL1,ICOL1,1,NEWPOS) )GOTO 26
      IF( .NOT. IFROMC(COL2,ICOL2,1,NEWPOS) )GOTO 26
      IF( ICOL1 .LT. 0 )GOTO 25
      IF( ICOL2 .LE. 0 )GOTO 25
      IF( NARG .GE. 4 )THEN
         IF( .NOT. IFROMC(COL3,ICOL3,1,NEWPOS) )GOTO 26
         IF( ICOL3 .LE. 0 )GOTO 25
      ENDIF
      IF( NARG .EQ. 5 )THEN
         IF( .NOT. IFROMC(COL4,ICOL4,1,NEWPOS) )GOTO 26
         IF( ICOL4 .LE. 0 )GOTO 25
      ENDIF
C
C OPEN THE DATA FILE.
C
      IFNE = LNBC(FNAME,1,1)
      IF( IFNE .GT. 7 )IFNE = 7
      IF( FNAME(1:IFNE) .EQ. 'HERE' )THEN
         LHERE = .TRUE.
         INUN = IUN
      ELSE
         LHERE = .FALSE.
         INUN = 4
         OPEN(UNIT=INUN,FILE=FNAME(1:IFNE),STATUS='OLD',ERR=9)
         REWIND(UNIT=INUN)
      ENDIF
C
C READ THE FILE LINE BY LINE.
C
      NOUT = 0
      ILINE = 0
      ISTAT = 1
 900  CONTINUE
      IF( NOUT .GE. NP )GOTO 19
      READ(INUN,102,ERR=7,END=28)LINE
 102  FORMAT(A)
      ILINE = ILINE + 1
C
C IGNORE BLANK LINES AND LINES BEGINNING WITH C IN COLUMN 1
C
      ILNBC = LNBC(LINE,1,0)
      IF( ILNBC .EQ. 0 )GOTO 900
      IF( LINE(1:1) .EQ. 'C' )GOTO 900
C
C IF IN "HERE" MODE, STOP READING IF LINE BEGINS "EOF"
C
      IF( LHERE .AND. ILNBC .EQ. 3 )THEN
         IF( LINE(1:3) .EQ. 'EOF' )GOTO 28
      ENDIF
C
C CONVERT COMMAS TO SPACES
C
      CALL DECOMMA(LINE)
C
C PARSE THE LINE FOR TWO/THREE/FOUR SPACE SEPARATED REAL NUMBERS
C
      IS = 1
      IF( ICOL1 .EQ. 0 )THEN
         FVAL = NOUT
      ELSE
         IECOL = ICOL1
         CALL GETSCOL(LINE,ICOL1,IS)
         IF( IS .EQ. 0 )GOTO 66
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
      ENDIF
      X(NOUT+1) = FVAL
      IS = 1
      IECOL = ICOL2
      CALL GETSCOL(LINE,ICOL2,IS)
      IF( IS .EQ. 0 )GOTO 66
      IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
      Y(NOUT+1) = FVAL
      IF( NARG .GE. 4 )THEN
         IS = 1
         IECOL = ICOL3
         CALL GETSCOL(LINE,ICOL3,IS)
         IF( IS .EQ. 0 )GOTO 66
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
         YE(NOUT+1) = FVAL
      ENDIF
      IF( NARG .EQ. 5 )THEN
         IS = 1
         IECOL = ICOL4
         CALL GETSCOL(LINE,ICOL4,IS)
         IF( IS .EQ. 0 )GOTO 66
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
         IF( .NOT. RFROMC(LINE,FVAL,IS,IE) )GOTO 6
         XE(NOUT+1) = FVAL
      ENDIF
      NOUT = NOUT + 1
      GOTO 900
C
C FILE READ SUCCESSFULLY.
C
  28  CONTINUE
      WRITE(6,198)ILINE, NOUT
 198  FORMAT(1X,'OK END OF FILE. LINES=',I5,' POINTS=',I5)
C
C CLOSE THE INPUT FILE. RETURN ISTAT. MAYBE AFTER ERROR.
C
  29  CONTINUE
      IF(.NOT. LHERE)CLOSE(UNIT=INUN)
      RETURN
C
C LINE PARSE ERROR.
C
  6   CONTINUE
      WRITE(6,110)ILINE
 110  FORMAT(1X,'CANNOT PARSE X,Y [YE [XE]] FROM LINE: ',I5)
      ISTAT = 0
      GOTO 29
C
C COLUMN NOT FOUND ERROR.
C
 66   CONTINUE
      WRITE(6,116)IECOL, ILINE
 116  FORMAT(1X,'CANNOT FIND COLUMN: ',I5,' IN LINE: ',I5)
      ISTAT = 0
      GOTO 29
C
C FILE READ ERROR.
C
  7   CONTINUE
      WRITE(6,111)ILINE
 111  FORMAT(1X,'FILE READ ERROR AT LINE: ',I5)
      ISTAT = 0
      GOTO 29
C
C TOO MANY DATA POINTS.
C
  19  CONTINUE
      WRITE(6,112)NOUT,ILINE
 112  FORMAT(1X,'TOO MANY DATA POINTS ',I5,' AT LINE ',I5)
      ISTAT = 0
      GOTO 29
C
C COLUMN NUMBER PARSE ERROR.
C
  26  CONTINUE
      WRITE(6,126)
 126  FORMAT(1X,'CANNOT PARSE COLUMN SPECIFIERS.')
      ISTAT = 0
      GOTO 29
C
C ILLEGAL NEGATIVE COLUMN NUMBER
C
  25  CONTINUE
      WRITE(6,125)
 125  FORMAT(1X,'ILLEGAL NEGATIVE OR NON X ZERO COLUMN NUMBER.')
      ISTAT = 0
      GOTO 29
C
C CANNOT OPEN INPUT FILE.
C
  9   CONTINUE
      WRITE(6,100)FNAME(1:IFNE)
 100  FORMAT(1X,'CANNOT OPEN DATA FILE: ',A)
      ISTAT = 0
      RETURN
      END
C
      SUBROUTINE GETSCOL(LINE,IWCOL,IS)
C---------------------------------------------------------
C FIND THE CHARACTER IS IN LINE AT WHICH COLUMN IWCOL STARTS
C "COLUMNS" ARE SPACE DELIMITED CHARACTER STRINGS OR
C SINGLE QUOTE ' PAIR DELIMITED TO ALLOW EMBEDDED SPACES.
C---------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) LINE
      INTEGER IWCOL, IS
C
      LOGICAL QUOTED
      INTEGER ICOL
      INTEGER NOCC, NBC, NNBC
C
C NO COLUMN FOUND YET. LOOK FOR THE FIRST (NEXT) COLUMN.
      ICOL = 0
  1   CONTINUE
C FIND NEXT NON BLANK. IF NONE, THERE IS NO NEXT COLUMN.
      IS = NNBC(LINE,IS,0)
      IF( IS .EQ. 0 )RETURN
C IF THE NON-BLANK IS A SINGLE QUOTE, USE THAT AS THE COLUMN
C TERMINATOR INSTEAD OF SPACE.
      QUOTED = ( LINE(IS:IS) .EQ. '''' )
C INC COLUMN NUMBER. IF THAT IS THE WANTED ONE, RETURN IS.
      ICOL = ICOL + 1
      IF( ICOL .EQ. IWCOL )RETURN
C SKIP TO THE ENDING QUOTE IF QUOTED.
      IF( QUOTED )THEN
         IS = NOCC(LINE,'''',IS+1,0)
         IF( IS .EQ. 0 )THEN
            WRITE(6,100)ICOL
  100       FORMAT(1X,'WARN: MISMATCHED QUOTE AT COL=',I3)
         ENDIF
      ENDIF
C FIND NEXT BLANK. OR SINGLE QUOTE. IF NONE, THERE IS NO NEXT COLUMN.
      IS = NBC(LINE,IS,0)
      IF( IS .EQ. 0 )RETURN
C LOOP TO FIND NEXT COLUMN START.
      GOTO 1
      END
C
      SUBROUTINE DECOMMA(LINE)
C----------------------------------------------------
C CONVERT COMMAS TO SPACES TO DEAL WITH CSV DATA.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*)LINE
C
      INTEGER I
C
      DO 1 I=1,LEN(LINE)
         IF( LINE(I:I) .EQ. ',' )LINE(I:I) = ' '
  1   CONTINUE
      RETURN
      END
C
      SUBROUTINE QUOTS2D( ARGSTR )
C----------------------------------------------------
C CONVERT SINGLE QUOTES TO DOUBLE QUOTES.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) ARGSTR
C
      INTEGER I
C
      DO 1 I=1,LEN(ARGSTR)
         IF(ARGSTR(I:I) .EQ. '''' )ARGSTR(I:I) = '"'
  1   CONTINUE
      RETURN
      END
C
      SUBROUTINE SQSTRIP( ARGSTR )
C----------------------------------------------------
C REMOVE ALL SINGLE QUOTES IN ARGSTR.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) ARGSTR
C
      CHARACTER*80 TARG
      INTEGER I, J
C
      J = 1
      DO 1 I=1,LEN(ARGSTR)
         IF( ARGSTR(I:I) .NE. '''' )THEN
            TARG(J:J) = ARGSTR(I:I)
            J = J + 1
         ENDIF
  1   CONTINUE
      DO 2 I=J,LEN(ARGSTR)
         TARG(I:I) = ' '
  2   CONTINUE
      ARGSTR = TARG
      RETURN
      END
C
      SUBROUTINE GOGRAF( IDEV, NDEV )
C----------------------------------------------------
C ENSURE DEVICE IDEV IS IN "GRAPHICS MODE" IF NEEDED.
C TEK4K DOES NEED THIS.
C THIS MAY NEED TO BE CALLED AFTER ANY NON-GRAPHICS
C TEXT HAS BEEN SENT TO THE DEVICE TO GET IT BACK IN TO
C GRAPHICS MODE.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO GOGRAF UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
      CALL TEKGRAF
      CALL TEKCLR
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE GFLUSH( IDEV, NDEV, LTEXT )
C----------------------------------------------------
C FLUSH THE OUTPUT, MAYBE GO TO TEXT MODE (IF MEANINGFUL).
C NOTE THAT THIS SENDS ANY QUEUED OUTPUT TO THE DEVICE,
C BUT IT DOES NOT NECESSARILY MAKE THE DEVICE DRAW.
C WITH INTERACTIVE DEVICES ON A TERMINAL LINE, THIS MUST
C BE CALLED BEFORE ANY NON GRAPHICS IS SENT TO THE TERMINAL
C TO PREVENT THAT TEXT BEING MIXED UP WITH PARTIAL GRAPHICS
C COMMANDS.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
      LOGICAL LTEXT
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO GFLUSH UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
      CALL A12FLS
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
      CALL A12FLS
      IF( LTEXT )THEN
         CALL TEKGRAF
         CALL TEKDRAW(3,747,0)
         CALL TEKTEXT
         CALL A12FLS
      ENDIF
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE MAKEVIS( IDEV, NDEV )
C-------------------------------------------
C MAKE THE DEVICE SHOW ALL GRAPHICS IT HAS RECEIVED NOW.
C GTERM NEEDS THIS.
C-------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO MAKEVIS UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
      CALL GTFLUSH
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
      CALL A12FLS
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE DEVFILL( IDEV, NDEV, RED, GRN, BLU )
C----------------------------------------------------
C MAKE THE DEVICE FILL THE DRAWING AREA WITH THE CURRENT COLOUR.
C ONLY GTERM CAN DO THIS AT THE MOMENT.
C----------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER IDEV, NDEV
      REAL RED, GRN, BLU
C
      IF( IDEV .LT. 1 .OR. IDEV .GT. NDEV )THEN
         WRITE(6,100)
 100     FORMAT(1X,'TRYING TO DEVFILL UNKNOWN DEVICE.')
         RETURN
      ENDIF
      GOTO(1001,1002,1003,1004,1005),IDEV
C---- GTERM
 1001 CONTINUE
      CALL GTCOL(RED,GRN,BLU)
      CALL GTFILL
      CALL GTFLUSH
      GOTO 1999
C---- TEK4K
 1002 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSCOL
 1003 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- EPSBIN
 1004 CONTINUE
C     DO NOTHING
      GOTO 1999
C---- SVG
 1005 CONTINUE
C     DO NOTHING
      GOTO 1999
 1999 CONTINUE
      RETURN
      END
C
      SUBROUTINE PARSUB(SUBSTR,ARGSTR,NCARG,IERR)
C----------------------------------------
C SUBSTITUTE FORMAL ARGUMENT VARIABLES IN ARGSTR WITH ACTUAL ARGS
C IN SUBSTR. IF ARGSTR CONTAINS $N THEN THAT IS SUBSTITUTED WITH
C THE NTH SPACE SEPARATED ITEM IN SUBSTR.
C ACTUAL ARGS IN SUBSTR MAY BE ENCLOSED IN SINGLE QUOTES TO ALLOW
C THEM TO CONTAIN SPACES.
C THE RESULT IS TRUNCATED AT THE SIZE OF ARGSTR REGARDLESS.
C IERR IS RETURNED WITH 0 IF THERE ARE NO ERRORS. IT IS AN ERROR
C TO NOT SUPPLY ENOUGH ARGUMENTS SO THAT SOME $N SUBSTITUTION FAILS.
C----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) SUBSTR, ARGSTR
      INTEGER NCARG, IERR
C
      INTEGER LARGSTR, LSUBSTR
      CHARACTER*80 SBUF
      CHARACTER*9 ARGDIG
      CHARACTER*1 TRMCHR
      LOGICAL ADDCHR
      INTEGER I, J, K, IS, IARG, IERESL
      INTEGER LNBC
C
      IERR = 0
      SBUF = ' '
      ARGDIG = '123456789'
      LARGSTR = LEN(ARGSTR)
      LSUBSTR = LEN(SUBSTR)
      J = 1
      I = 1
C---- PROCESS ALL CHARACTERS IN ARGSTR.
C---- THIS USES AN "OPEN CODED" DO-LOOP ON I AS I MAY NEED TO
C---- BE CONDITIONALLY INCREMENTED. I IS THE INDEX IN ARGSTR.
 1    CONTINUE
      IF( I .GT. NCARG )GOTO 2
C---- LOOK FOR $ AS A PARAMETER INDICATOR.
         IF( ARGSTR(I:I) .EQ. '$' )THEN
            IF( I .LT. NCARG )THEN
C---- IF NEXT CHAR IS DIGIT, DECODE AS A PARAMETER NUMBER.
               IARG = INDEX(ARGDIG,ARGSTR(I+1:I+1))
               IF( IARG .GT. 0 )THEN
C---- SKIP THE DIGIT SO WE DO NOT COPY IT.
                  I = I + 1
C---- FIND WHERE THE IARG'TH WORD STARTS IN SUBSTR
                  IS = 1
                  CALL GETSCOL(SUBSTR,IARG,IS)
C---- IF THERE WAS SUCH A WORD, SUBSTITUTE IT IN PLACE OF $N
                  IF( IS .GT. 0 )THEN
C---- IF THE WORD STARTS WITH ' IT SHOULD END WITH ' NOT SPACE.
C---- RETAIN THE ' AT THIS POINT, HOWEVER.
                     IF( SUBSTR(IS:IS) .EQ. '''' )THEN
                        TRMCHR = ''''
                        IF( ADDCHR(SUBSTR(IS:IS),SBUF,J,80) )GOTO 2
                        IS = IS + 1
                     ELSE
                        TRMCHR = ' '
                     ENDIF
C---- COPY THE WORD TO THE END OF SBUF. K IS THE SUBSTR INPUT
C---- POSITION (INDEX), J IS THE SBUF OUTPUT POSITION.
                     DO 3 K=IS,LSUBSTR
                        IF( SUBSTR(K:K) .EQ. TRMCHR )THEN
                           IF( TRMCHR .EQ. ' ' )GOTO 4
                           IF(ADDCHR(SUBSTR(K:K),SBUF,J,80))GOTO 2
                           GOTO 4
                        ENDIF
                        IF(ADDCHR(SUBSTR(K:K),SBUF,J,80))GOTO 2
  3                  CONTINUE
  4                  CONTINUE
C---- INSERT A SPACE AFTER THE SUBSTITUTION.
                     IF(ADDCHR(' ',SBUF,J,80))GOTO 2
                  ELSE
                     WRITE(6,100)IARG
 100  FORMAT(1X,'REQUIRED OBEY FILE ARGUMENT ',I2,' MISSING.')
                     IERR = 1
                     RETURN
                  ENDIF
               ELSE
C---- DOLLAR NOT FOLLOWED BY A DIGIT. INSERT DOLLAR.
                  IF(ADDCHR(ARGSTR(I:I),SBUF,J,80))GOTO 2
               ENDIF
            ELSE
C---- DOLLAR AT END OF STRING. INSERT DOLLAR.
               IF(ADDCHR(ARGSTR(I:I),SBUF,J,80))GOTO 2
            ENDIF
C---- IF CHAR IN ARGSTR IS NOT $, COPY IT TO THE RESULT.
         ELSE
            IF(ADDCHR(ARGSTR(I:I),SBUF,J,80))GOTO 2
         ENDIF
         I = I + 1
      GOTO 1
  2   CONTINUE
C---- COPY THE FINAL SUBSTITUTED RESULT BACK TO ARGSTR, TRUNCATING.
      DO 9 I=1,LARGSTR
         ARGSTR(I:I) = SBUF(I:I)
  9   CONTINUE
      RETURN
      END
C
      SUBROUTINE ADDSTR( RESULT, PART, LPRESPC, LENCQT )
C-------------------------------------------------------
C ADD STRING PART TO THE END OF RESULT.
C IF LPRESPC, INSERT A SPACE BEFORE THE NEW COMPONENT.
C IF LENCQT, ENCLOSE THE NEW COMPONENT IN DOUBLE QUOTES.
C-------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) RESULT, PART
      LOGICAL LPRESPC, LENCQT
C
      LOGICAL ADDCHR
      INTEGER LNBC
      INTEGER ILRESL, IERESL, IEPART, IR, I
C
      ILRESL = LEN(RESULT)
      IERESL = LNBC(RESULT,1,1)
      IEPART = LNBC(PART,1,0)
      IF( IEPART .EQ. 0 )RETURN
      IR = IERESL + 1
      IF( LPRESPC )THEN
         IF( ADDCHR( ' ', RESULT, IR, ILRESL ) )RETURN
      ENDIF
      IF( LENCQT )THEN
         IF( ADDCHR( '"', RESULT, IR, ILRESL ) )RETURN
      ENDIF
      DO 1 I=1,IEPART
         IF( ADDCHR( PART(I:I), RESULT, IR, ILRESL ) )RETURN
  1   CONTINUE
      IF( LENCQT )THEN
         IF( ADDCHR( '"', RESULT, IR, ILRESL ) )RETURN
      ENDIF
      RETURN
      END
C
      LOGICAL FUNCTION ADDCHR( INCHAR, OUTSTR, IOUT, OUTL )
C----------------------------------------------------------
C ADD CHARACTER INCHAR TO OUTSTR AT POSITION IOUT. BUMP IOUT.
C RETURN TRUE IF OUTSTR, LENGTH OUTL, IS ALREADY FULL.
C----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*1 INCHAR
      CHARACTER*(*) OUTSTR
      INTEGER IOUT, OUTL
C
      ADDCHR = .FALSE.
      IF( IOUT .GT. OUTL )THEN
         ADDCHR = .TRUE.
      ELSE
         OUTSTR(IOUT:IOUT) = INCHAR
         IOUT = IOUT + 1
      ENDIF
      RETURN
      END
C
      LOGICAL FUNCTION GETYN( STRING )
C----------------------------------------------------------
C RETURN .TRUE. IF STRING CONTAINS Y OR YES ELSE .FALSE.
C----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) STRING
C
      INTEGER ICMD
      INTEGER LOOKUP
      CHARACTER*3 OPTS(4)
C
      OPTS(1) = 'YES'
      OPTS(2) = 'NO'
      OPTS(3) = 'ON'
      OPTS(4) = 'OFF'
      ICMD = LOOKUP(OPTS,4,STRING,.FALSE.,.TRUE.)
      GETYN = .FALSE.
      IF( ICMD .EQ. 0 )THEN
         WRITE(6,100)
 100     FORMAT(1X,'EXPECTED YES, NO, Y, N, ON, OFF' )
      ELSE
         IF( ICMD .EQ. 1 .OR. ICMD .EQ. 3 )GETYN = .TRUE.
      ENDIF
      RETURN
      END
C
      SUBROUTINE REPACK(X,Y,YE,XE,NDATA)
C-----------------------------------------------------------
C REARRANGES DATA SO THAT IT CAN BE ACCESSED AS A 2D ARRAY
C BY GRAPHE AND PTPLTE FOR ERROR BARS. THIS IS NECESSARILY
C QUITE HACKISH. THE "A" AND "B" ARRAYS ARE ALLOCATED SO
C THEY IMMEDIATELY FOLLOW THE X AND Y ARRAYS SO THIS SHOULD
C WORK.
C-----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL X(1), Y(1), YE(1), XE(1)
      INTEGER NDATA
C
      INTEGER I
C
C MOVE XE SO IT ABUTTS THE END OF NDATA USED X DATA POINTS.
C LIKEWISE FOR YE AND Y.
C
      DO 1 I=1,NDATA
         X(I+NDATA) = XE(I)
         Y(I+NDATA) = YE(I)
 1    CONTINUE
      RETURN
      END
C
      SUBROUTINE AREPACK(X,Y,YED,YEU,NDATA)
C---------------------------------------------------------
C REARRANGE DATA FOR ASYMMETRIC Y ERROR BARS. IN THIS CASE,
C THE ORDER NEEDS TO CHANGE SO THAT:
C X -> X, Y -> "A", YED -> Y, YEU -> "B".
C YED IS THE "DOWN" PART OF THE ERROR BAR AND YEU THE "UP".
C----------------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL X(1), Y(1), YED(1), YEU(1)
      INTEGER NDATA
C
      INTEGER I
      REAL RTEMP
C
C FIRST, SWAP THE CONTENTS OF THE Y AND YED ("A") ARRAYS.
C YED = DA(IAOFF) WILL THEN CONTAIN Y AND Y = DA(IYOFF) YED.
C
      DO 1 I=1,NDATA
         RTEMP = Y(I)
         Y(I) = YED(I)
         YED(I) = RTEMP
  1   CONTINUE
C
C NOW, SQUISH THE ERROR BAR ARRAYS TOGETHER.
C
      DO 2 I=1,NDATA
         YED(I+NDATA) = Y(I)
         YED(I+2*NDATA) = YEU(I)
  2   CONTINUE
      RETURN
      END
C
      SUBROUTINE SHOW2D(X,Y,N,MX,MY)
C--------------------------------------------
C TEST REPACK HAS THE DESIRED EFFECT.
C--------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N, MX, MY
      REAL X(N,MX), Y(N,MY)
C
      INTEGER I, J
C
      DO 1 J=1,MX
         DO 2 I=1,N
            WRITE(6,*)'X(',I,',',J,')=',X(I,J)
  2      CONTINUE
  1   CONTINUE
      DO 3 J=1,MY
         DO 4 I=1,N
            WRITE(6,*)'Y(',I,',',J,')=',Y(I,J)
  4      CONTINUE
  3   CONTINUE
      RETURN
      END
C
      SUBROUTINE SHOW1D(X,Y,N)
C--------------------------------------------
C DUMP X,Y DATA TO BE PLOTTED.
C--------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL X(N), Y(N)
C
      INTEGER I
      DO 1 I=1,N
         WRITE(6,*)'X(',I,')=',X(I),' Y(',I,')=',Y(I)
 1    CONTINUE
      RETURN
      END
C
      SUBROUTINE LINSPC(X,N,START,STOP)
C--------------------------------------------
C INSERT N EVENLY SPACED VALUES COVERING START TO STOP INCLUSIVE.
C--------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL X(N), START, STOP
C
      INTEGER I
      REAL STEP
C
      STEP = (STOP - START) / (N - 1)
      DO 1 I=1,N
         X(I) = START + (I-1) * STEP
 1    CONTINUE
      RETURN
      END
C
      SUBROUTINE LOGSPC(X,N,START,STOP,BASE)
C---------------------------------------------
C RETURN N NUMBERS SPACED EVENLY ON A LOG SCALE.
C---------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL X(N), START, STOP, BASE
C
      INTEGER I
C
      CALL LINSPC(X,N,START,STOP)
      DO 1 I=1,N
         X(I) = BASE ** X(I)
 1    CONTINUE
      RETURN
      END
C
      LOGICAL FUNCTION VALDFMT(FMTSTR)
C---------------------------------------------
C SIMPLE CHECKS THAT A FORMAT STRING MIGHT BE VALID.
C---------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) FMTSTR
C
      INTEGER L
C
      L = LEN(FMTSTR)
      VALDFMT = .TRUE.
      IF( FMTSTR(1:1) .NE. '(' )VALDFMT = .FALSE.
      IF( FMTSTR(L:L) .NE. ')' )VALDFMT = .FALSE.
      RETURN
      END
C
      INTEGER FUNCTION EVAL(STACK,NELEM,NPOINTS,NWORDS,NSTACK,COPS,
     +                      HAVDEV,IDEV,NDEVS,ITER,MEMS,GCHANGE,
     +                      RBASE,RSTART,RSTOP,STRINGS,STRILEN,TXTCON,
     +                      ZEROVAL,BB,DOBB)
C---------------------------------------------
C ULTRA SIMPLE RPN FUNCTION EVALUATOR THAT OPERATES ON VECTORS.
C COPS IS A STRING CONTAINING OPERANDS AND OPERATORS SEPARATED BY COMMAS
C STACK IS THE ALLOCATED POINTS ARRAY, TOTAL SIZE NWORDS=NSTACK*NPOINTS
C  USED AS: ISTACK = 0 [1 .. NELEM .. NPOINTS] <- X RANGE VALUES.
C           ISTACK = 1 [NPOINTS+1 .. NPOINTS+1+NELEM .. 2*NPOINTS] <- Y
C           ISTACK = 2 [2*NPOINTS+1 .. 2*NPOINTS+1+NELEM .. 3*NPOINTS]
C           ISTACK = 3 [3*NPOINTS+1 .. 3*NPOINTS+1+NELEM .. 4*NPOINTS]
C           ...
C           ISTACK = NSTACK-1
C  NELEM IS THE NUMBER OF ACTIVE ELEMENTS = NUMBER OF X RANGE VALUES.
C  ISTACK = 0 IS NEVER MODIFIED, EXCEPT BY SETX AND XLIN,XLOG.
C  RETURN 0 IF EVALUATION WORKED, ELSE AN ERROR CODE.
C---------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NELEM, NPOINTS, NWORDS, IDEV, NDEVS, NSTACK, ITER
      REAL STACK(NWORDS), MEMS(9), RBASE, RSTART, RSTOP, ZEROVAL, BB(4)
      CHARACTER*(*) COPS
      CHARACTER*80 STRINGS(9)
      INTEGER STRILEN(9)
      LOGICAL HAVDEV, GCHANGE, TXTCON, DOBB
C
      INTEGER LCOPS, IBEG, IEND, ILEN, ISTKTOP, ISTKPOP, I, J, IOP
      INTEGER NOPS, JUNK, IERR, NS1, ISTKPTR, ISTACK, ISTKPO2, ISTKPO3
      INTEGER ISTKNEW, IREG, NEWELEM, IARG, IOEN, IOST, IMPOS, NFMT
      INTEGER ISTKPO4
      REAL ARG, DOMLIM, CEILING, V, FLOOR
      PARAMETER( NOPS=80 )
      CHARACTER*4 OPNAMES(NOPS)
      INTEGER MINSTK(NOPS), OPLEN(NOPS)
      CHARACTER*20 COP
      CHARACTER*80 EMSG, MARKER
      CHARACTER*5 VFMT
      LOGICAL RFROMC, CLOSED, VALDFMT, TRPDIV0
      INTEGER LNBC
      REAL X, Y, XO, YO, ROP, STRING, ZEROTST
      SAVE
      DATA X/0.0/, Y/0.0/
      DATA OPNAMES/    '+',    '-',    '*',    '/',    'P',
     +                'R/',   'R-',  'SIN',  'COS',  'TAN',
     +              'ASIN', 'ACOS', 'ATAN',  'CHS', 'SQRT',
     +                '**',  'RCP',  'INT', 'FRAC',  'FLR',
     +              'CEIL', 'SWAP', 'RAND', 'SETX',  'LOG',
     +              'LG10', 'LOG2',  'EXP', 'SINH', 'COSH',
     +              'TANH',  'MIN',  'MAX',  'DUP', 'DUMP',
     +               'STO',  'RCL',  'ABS', 'SIGN',    'M',
     +                 'D', 'HDSH', 'VDSH', 'XLIN', 'PTHO',
     +              'PTHC',  'ODD', 'ELEM',  'POP', 'XLOG',
     +              'SEED',  'MOD', 'I1IJ', 'I0IJ',    'T',
     +               'TVF',  'TVI',   'TS',   'TM',   'TC',
     +                'TH',   'TA',  'TSC',  'TEC', 'TLEN',
     +                'PE',   'GT',   'LT',   'LE',   'GE',
     +                'EQ',   'NE',  'NOT',  'SEL',  'IDX',
     +              'SETY',    'C',    'A',  'BOX',   'PC'/
      DATA MINSTK/2, 2, 2, 2, 1,
     +            2, 2, 1, 1, 1,
     +            1, 1, 1, 1, 1,
     +            2, 1, 1, 1, 1,
     +            1, 2, 1, 1, 1,
     +            1, 1, 1, 1, 1,
     +            1, 2, 2, 1, 1,
     +            2, 1, 1, 1, 2,
     +            2, 1, 1, 3, 2,
     +            2, 1, 2, 1, 4,
     +            1, 2, 2, 2, 1,
     +            2, 2, 1, 1, 1,
     +            1, 1, 0, 0, 1,
     +            3, 2, 2, 2, 2,
     +            2, 2, 1, 3, 0,
     +            1, 3, 5, 4, 1/
      DATA OPLEN/1, 1, 1, 1, 1,
     +           2, 2, 3, 3, 3,
     +           4, 4, 4, 3, 4,
     +           2, 3, 3, 4, 3,
     +           4, 4, 4, 4, 3,
     +           4, 4, 3, 4, 4,
     +           4, 3, 3, 3, 4,
     +           3, 3, 3, 4, 1,
     +           1, 4, 4, 4, 4,
     +           4, 3, 4, 3, 4,
     +           4, 3, 4, 4, 1,
     +           3, 3, 2, 2, 2,
     +           2, 2, 3, 3, 4,
     +           2, 2, 2, 2, 2,
     +           2, 2, 3, 3, 3,
     +           4, 1, 1, 3, 2/
C
C---- THE DOMAIN OF SEVERAL MATHEMATICAL FUNCTIONS IS LIMITED TO THIS:
C---- ALSO, IF TRPDIV0, TRAP DIVIDE BY < ABS(1E-9) ELSE USE 1E-9.
      DOMLIM = (2.0**47)-1.0
      TRPDIV0 = (ZEROVAL .EQ. 0.0)
      IF( ZEROVAL .EQ. 0.0)THEN
         ZEROTST = 1.0E-9
      ELSE
         ZEROTST = ABS(ZEROVAL)
      ENDIF
C
C---- THE STACK INDEX GIVES THE TOP OCCUPIED ITEM. INITIALLY RANGE IN O.
C---- PUSH: INCREMENT ISTACK, CHECK <= NS1, PUT THINGS IN STACK[ISTACK].
C---- POP: CHECK > 0, GET THINGS FROM STACK[ISTACK], DECREMENT ISTACK.
      ISTACK = 0
      NS1 = NSTACK - 1
      IERR = 0
C
C---- SPLIT THE RPN STRING INTO TOKENS ON COMMAS.
      LCOPS = LNBC(COPS,1,1)
      IBEG = 1
 1    CONTINUE
         IF( IBEG .GT. LCOPS )GOTO 2
         IEND = INDEX(COPS(IBEG:),',')
         IF( IEND .EQ. 0 )THEN
            IEND = LCOPS + 1
         ELSE
            IEND = IEND + IBEG - 1
         ENDIF
         IF( IEND .GT. IBEG )THEN
            ILEN = IEND - IBEG
            IF( ILEN .GT. 20 )GOTO 9003
            COP(1:ILEN) = COPS(IBEG:IEND)
C
C---- DEAL WITH THIS TOKEN. CHECK FOR OPERANDS FIRST.
C--- ANYTHING THAT CAN BE INTERPRETED AS A REAL NUMBER IS AN OPERAND.
C--- NUMBER : (    -- A1 ) : SET ARRAY TO A LITERAL CONSTANT.
            IF( RFROMC(COP(1:ILEN),ROP,1,JUNK) )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 10 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = ROP
 10            CONTINUE
C
C--- X MEANS PUT RANGE VALUES ON THE STACK.
C--- X : (   -- A1 ) : GET X RANGE ARRAY
            ELSE IF( (ILEN .EQ. 1) .AND. (COP(1:ILEN) .EQ. 'X') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               J = 1
               DO 11 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = STACK(J)
                  J = J + 1
 11            CONTINUE
C
C--- PI MEANS PUT 3.14159... ON THE STACK.
C--- PI : (    -- A1 ) : SET ARRAY TO PI.
            ELSE IF( (ILEN .EQ. 2) .AND. (COP(1:ILEN) .EQ. 'PI') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 12 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = 3.14159265358
 12            CONTINUE
C
C--- E MEANS PUT 2.71828 ... ON THE STACK.
C--- E : (   -- A1 ) : SET ARRAY TO E.
            ELSE IF( (ILEN .EQ. 1) .AND. (COP(1:ILEN) .EQ. 'E') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 13 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = 2.718281828459
 13            CONTINUE
C
C--- I MEANS PUT ITERATION NUMBER ON THE STACK.
C--- I : (  -- A1 ) : SET ARRAY TO CURRENT ITERATION NUMBER.
            ELSE IF( (ILEN .EQ. 1) .AND. (COP(1:ILEN) .EQ. 'I') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 14 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = ITER
 14            CONTINUE
C
C--- TWPI MEANS PUT 2*3.14159... ON THE STACK.
C--- TWPI : (  -- A1 ) : SET ARRAY TO 2 * PI.
            ELSE IF( (ILEN .EQ. 4) .AND. (COP(1:ILEN) .EQ. 'TWPI') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 15 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = 2.0*3.14159265358
 15            CONTINUE
C
C--- PI/2 MEANS PUT 0.5*3.14159... ON THE STACK.
C--- PI/2 : (  -- A1 ) : SET ARRAY TO PI / 2.
            ELSE IF( (ILEN .EQ. 4) .AND. (COP(1:ILEN) .EQ. 'PI/2') )THEN
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKTOP = ISTACK * NPOINTS + 1
               DO 16 I=ISTKTOP,ISTKTOP+NELEM
                  STACK(I) = 0.5*3.14159265358
 16            CONTINUE
C
C--- NOT AN OPERAND. IS IT AN OPERATOR?
            ELSE
               IOP = 0
               IF( ILEN .GT. 4 )GOTO 302
               DO 301 I=1,NOPS
                  IF( ILEN .EQ. OPLEN(I) )THEN
                     IF( COP(1:ILEN) .EQ. OPNAMES(I)(1:ILEN) )THEN
                        IOP = I
                        GOTO 302
                     ENDIF
                  ENDIF
 301           CONTINUE
 302           CONTINUE
               IF( IOP .EQ. 0 )GOTO 9004
C
C--- IT IS A KNOWN OPERATOR. TRY TO APPLY IT.
               IF( ISTACK .LT. MINSTK(IOP) )GOTO 9001
               ISTKTOP = ISTACK * NPOINTS + 1
               ISTKPOP = ISTKTOP - NPOINTS
               ISTKPO2 = ISTKPOP - NPOINTS
               ISTKPO3 = ISTKPO2 - NPOINTS
               ISTKPO4 = ISTKPO3 - NPOINTS
               GOTO(201,202,203,204,205,
     +              206,207,208,209,210,
     +              211,212,213,214,215,
     +              216,217,218,219,220,
     +              221,222,223,224,225,
     +              226,227,228,229,230,
     +              231,232,233,234,235,
     +              236,237,238,239,240,
     +              241,242,243,244,245,
     +              246,247,248,249,250,
     +              251,252,253,254,255,
     +              256,257,258,259,260,
     +              261,262,263,264,265,
     +              266,267,268,269,270,
     +              271,272,273,274,275,
     +              276,277,278,279,280),IOP
C
C--- + : ADD ( A1 A2 -- A1 ) : A1 = A1 + A2
 201           CONTINUE
               DO 2101 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) + STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2101          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- - : SUBTRACT ( A1 A2 -- A1 ) : A1 = A1 - A2
 202           CONTINUE
               DO 2102 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) - STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2102          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- * : MULTIPLY ( A1 A2 -- A1 ) : A1 = A1 * A2
 203           CONTINUE
               DO 2103 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) * STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2103          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- / : DIVIDE ( A1 A2 -- A1 ) : A1 = A1 / A2
 204           CONTINUE
               DO 2104 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .LT. ZEROTST )THEN
                     IF( TRPDIV0 )THEN
                        GOTO 9002
                     ELSE
                        IF( ABS(STACK(ISTKPOP)) .LT. ZEROTST )THEN
                           STACK(ISTKPOP) = 1.0
                        ELSE
                           ARG = SIGN(ZEROTST,ARG)
                           STACK(ISTKPOP) = STACK(ISTKPOP) / ARG
                        ENDIF
                     ENDIF
                  ELSE
                     STACK(ISTKPOP) = STACK(ISTKPOP) / ARG
                  ENDIF
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2104          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- P  : PRINT ( -- ) : PRINT TOP OF STACK INFORMATION.
 205           CONTINUE
               IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
               WRITE(6,2105)ISTACK, STACK(ISTKTOP), NELEM,
     +                      STACK(ISTKTOP+NELEM-1)
 2105          FORMAT(1X,'TOP:',I1,' [1]:',G12.4,' ... [',I4,']:',G12.4)
               GOTO 299
C
C--- R/ : REVERSE DIVIDE ( A1 A2 -- A1 ) : A1 = A2 / A1
 206           CONTINUE
               DO 2106 I=1,NELEM
                  ARG = STACK(ISTKPOP)
                  IF( ABS(ARG) .LT. ZEROTST )THEN
                     IF( TRPDIV0 )THEN
                        GOTO 9002
                     ELSE
                        IF( ABS(STACK(ISTKTOP)) .LT. ZEROTST )THEN
                           STACK(ISTKPOP) = 1.0
                        ELSE
                           ARG = SIGN(ZEROTST,ARG)
                           STACK(ISTKPOP) = STACK(ISTKTOP) / ARG
                        ENDIF
                     ENDIF
                  ELSE
                     STACK(ISTKPOP) = STACK(ISTKTOP) / ARG
                  ENDIF
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2106          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- R- : REVERSE SUBTRACT ( A1 A2 -- A1 ) : A1 = A2 - A1
 207           CONTINUE
               DO 2107 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKTOP) - STACK(ISTKPOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2107          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- SIN : ( A1 -- A1 ) : A1 = SIN(A1)
 208           CONTINUE
               DO 2108 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = SIN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2108          CONTINUE
               GOTO 299
C
C--- COS : ( A1 -- A1 ) : A1 = COS(A1)
 209           CONTINUE
               DO 2109 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = COS(ARG)
                  ISTKTOP = ISTKTOP + 1
 2109          CONTINUE
               GOTO 299
C
C--- TAN : ( A1 -- A1 ) : A1 = TAN(A1)
 210           CONTINUE
               DO 2110 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = TAN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2110          CONTINUE
               GOTO 299
C
C--- ASIN : ( A1 -- A1 ) : A1 = ARCSIN(A1)
 211           CONTINUE
               DO 2111 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 1.0 )GOTO 9005
                  STACK(ISTKTOP) = ASIN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2111          CONTINUE
               GOTO 299
C
C--- ACOS : ( A1 -- A1 ) : A1 = ARCCOS(A1)
 212           CONTINUE
               DO 2112 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 1.0 )GOTO 9005
                  STACK(ISTKTOP) = ACOS(ARG)
                  ISTKTOP = ISTKTOP + 1
 2112          CONTINUE
               GOTO 299
C
C--- ATAN : ( A1 -- A1 ) : A1 = ARCTAN(A1)
 213           CONTINUE
               DO 2113 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = ATAN(ARG)
                  ISTKTOP = ISTKTOP + 1
 2113          CONTINUE
               GOTO 299
C
C--- CHS : ( A1 -- A1 ) : A1 = -A1
 214           CONTINUE
               DO 2114 I=1,NELEM
                  STACK(ISTKTOP) = -STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
 2114          CONTINUE
               GOTO 299
C
C--- SQRT : ( A1 -- A1 ) : A1 = SQRT(A1)
 215           CONTINUE
               DO 2115 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 0.0 )GOTO 9005
                  STACK(ISTKTOP) = SQRT(ARG)
                  ISTKTOP = ISTKTOP + 1
 2115          CONTINUE
               GOTO 299
C
C--- ** : ( A1 A2 -- A1 ) : A1 = A1 ** A2
 216           CONTINUE
               DO 2116 I=1,NELEM
                  STACK(ISTKPOP) = STACK(ISTKPOP) ** STACK(ISTKTOP)
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2116          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- RCP : ( A1 -- A1 ) : RECIPROCAL A1 = 1.0 / A1
 217           CONTINUE
               DO 2117 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .LT. 1.0E-9 )GOTO 9005
                  STACK(ISTKTOP) = 1.0 / ARG
                  ISTKTOP = ISTKTOP + 1
 2117          CONTINUE
               GOTO 299
C
C--- INT : ( A1 -- A1 ) : TRUNCATION A1 = INT(A1)
 218           CONTINUE
               DO 2118 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  STACK(ISTKTOP) = INT(ARG)
                  ISTKTOP = ISTKTOP + 1
 2118          CONTINUE
               GOTO 299
C
C--- FRAC : ( A1 -- A1 ) : FRACTIONAL PART A1 = FRAC(A1)
 219           CONTINUE
               DO 2119 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  FLOOR = INT(ARG)
                  IF( ARG .LT. 0.0 )FLOOR = FLOOR - 1.0
                  STACK(ISTKTOP) = ARG - FLOOR
                  ISTKTOP = ISTKTOP + 1
 2119          CONTINUE
               GOTO 299
C
C--- FLR : ( A1 -- A1 ) : A1 = FLOOR(A1)
 220           CONTINUE
               DO 2120 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  FLOOR = INT(ARG)
                  IF( ARG .LT. 0.0 )FLOOR = FLOOR - 1.0
                  STACK(ISTKTOP) = FLOOR
                  ISTKTOP = ISTKTOP + 1
 2120          CONTINUE
               GOTO 299
C
C--- CEIL : ( A1 -- A1 ) : A1 = CEILING(A1)
 221           CONTINUE
               DO 2121 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. DOMLIM )GOTO 9005
                  CEILING = INT(ARG)
                  IF( ARG .GT. 0.0 )CEILING = CEILING + 1.0
                  STACK(ISTKTOP) = CEILING
                  ISTKTOP = ISTKTOP + 1
 2121          CONTINUE
               GOTO 299
C
C--- SWAP : ( A1 A2 -- A2 A1 )
 222           CONTINUE
               DO 2122 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  STACK(ISTKTOP) = STACK(ISTKPOP)
                  STACK(ISTKPOP) = ARG
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2122          CONTINUE
               GOTO 299
C
C--- RAND : ( A1 -- A1 ) : UNI DIST RANDOMS 0 TO A1 A1 = A1 * RANDOM
 223           CONTINUE
               DO 2123 I=1,NELEM
                  STACK(ISTKTOP) = RANF() * STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
 2123          CONTINUE
               GOTO 299
C
C--- SETX : ( A1 -- A1 ) : OVERWRITE RANGE VALUES WITH STACK TOP VALUES.
 224           CONTINUE
               J = 1
               DO 2124 I=1,NELEM
                  STACK(J) = STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
                  J = J + 1
 2124          CONTINUE
               GOTO 299
C
C--- LOG : ( A1 -- A1 ) : BASE E LOGARITHM A1 = LN(A1)
 225           CONTINUE
               DO 2125 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 1.0E-29 )GOTO 9005
                  STACK(ISTKTOP) = LOG(ARG)
                  ISTKTOP = ISTKTOP + 1
 2125          CONTINUE
               GOTO 299
C
C--- LG10 : ( A1 -- A1 ) : BASE 10 LOGARITHM A1 = LOG10(A1)
 226           CONTINUE
               DO 2126 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 1.0E-29 )GOTO 9005
                  STACK(ISTKTOP) = LOG10(ARG)
                  ISTKTOP = ISTKTOP + 1
 2126          CONTINUE
               GOTO 299
C
C--- LOG2 : ( A1 -- A1 ) : BASE 2 LOGARITHM A1 = LOG2(A1)
 227           CONTINUE
               DO 2127 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ARG .LT. 1.0E-29 )GOTO 9005
                  STACK(ISTKTOP) = 1.44269504088 * LOG(ARG)
                  ISTKTOP = ISTKTOP + 1
 2127          CONTINUE
               GOTO 299
C
C--- EXP : ( A1 -- A1 ) : A1 =  E ** A1  DOMAIN: -675.81 TO 741.66
 228           CONTINUE
               DO 2128 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 675.0 )GOTO 9005
                  STACK(ISTKTOP) = EXP(ARG)
                  ISTKTOP = ISTKTOP + 1
 2128          CONTINUE
               GOTO 299
C
C--- SINH : ( A1 -- A1 ) : A1 = SINH(A1) DOMAIN \X\ < 742.36
 229           CONTINUE
               DO 2129 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 742.0 )GOTO 9005
                  STACK(ISTKTOP) = SINH(ARG)
                  ISTKTOP = ISTKTOP + 1
 2129          CONTINUE
               GOTO 299
C
C--- COSH : ( A1 -- A1 ) : A1 = COSH(A1) DOMAIN \X\ < 742.36
 230           CONTINUE
               DO 2130 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 742.0 )GOTO 9005
                  STACK(ISTKTOP) = COSH(ARG)
                  ISTKTOP = ISTKTOP + 1
 2130          CONTINUE
               GOTO 299
C
C--- TANH : ( A1 -- A1 ) : A1 = TANH(A1) DOMAIN \X\ < 742.36
 231           CONTINUE
               DO 2131 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  IF( ABS(ARG) .GT. 742.0 )GOTO 9005
                  STACK(ISTKTOP) = TANH(ARG)
                  ISTKTOP = ISTKTOP + 1
 2131          CONTINUE
               GOTO 299
C
C--- MIN : ( A1 A2 -- A1 ) : A1 = MIN(A1,A2)
 232           CONTINUE
               DO 2132 I=1,NELEM
                  STACK(ISTKTOP) = MIN(STACK(ISTKPOP),STACK(ISTKTOP))
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2132          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- MAX : ( A1 A2 -- A1 ) : A1 = MAX(A1,A2)
 233           CONTINUE
               DO 2133 I=1,NELEM
                  STACK(ISTKTOP) = MAX(STACK(ISTKPOP),STACK(ISTKTOP))
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2133          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- DUP : ( A1 -- A1 A1 ) : DUPLICATE TOP OF STACK
 234           CONTINUE
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKNEW = ISTACK * NPOINTS + 1
               DO 2134 I=1,NELEM
                  STACK(ISTKNEW) = STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
                  ISTKNEW = ISTKNEW + 1
 2134          CONTINUE
               GOTO 299
C
C--- DUMP : ( -- ) : PRINT ALL STACK LEVELS.
 235           CONTINUE
               IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
               WRITE(6,2435)NELEM, NPOINTS, NWORDS, NSTACK
 2435          FORMAT(1X,'NELEM:',I5,' NPOINTS:',I5,' NWORDS:',I5,
     +                ' NSTACK:',I5)
               WRITE(6,2335)ISTACK
 2335          FORMAT(1X,'ISTACK = ',I2,' LVL 0 = X')
               DO 2235 I=0,ISTACK
                  ISTKPTR = I * NPOINTS + 1
                  WRITE(6,2135)I, STACK(ISTKPTR), NELEM,
     +                         STACK(ISTKPTR+NELEM-1)
 2235          CONTINUE
 2135          FORMAT(1X,'LVL:',I1,' [1]:',G12.4,' ... [',I4,']:',G12.4)
               GOTO 299
C
C--- STO : ( A1 C2 -- A1 ) : STORE A1[1] IN REGISTER C2
 236           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               MEMS(IREG) = STACK(ISTKPOP)
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- RCL : ( A1 -- C1 ) : RECALL CONST VALUE A1 FROM REGISTER INT(A1)
 237           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               DO 2137 I=1,NELEM
                  STACK(ISTKTOP) = MEMS(IREG)
                  ISTKTOP = ISTKTOP + 1
 2137          CONTINUE
               GOTO 299
C
C--- ABS : ( A1 -- A1 ) : A1 = ABS(A1)
 238           CONTINUE
               DO 2138 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  STACK(ISTKTOP) = ABS(ARG)
                  ISTKTOP = ISTKTOP + 1
 2138          CONTINUE
               GOTO 299
C
C--- SIGN : ( A1 -- A1 ) : A1 = (A1 < 0) ? -1 : 1
 239           CONTINUE
               DO 2139 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  STACK(ISTKTOP) = SIGN(1.0,ARG)
                  ISTKTOP = ISTKTOP + 1
 2139           CONTINUE
               GOTO 299
C
C--- M : ( C1 C2 -- ) : MOVE TO (A1[1],A2[1])
 240           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               Y = STACK(ISTKTOP)
               X = STACK(ISTKPOP)
               IF( DOBB )THEN
                 BB(1) = MIN(BB(1),X)
                 BB(2) = MAX(BB(2),X)
                 BB(3) = MIN(BB(3),Y)
                 BB(4) = MAX(BB(4),Y)
               ELSE
                 CALL OFF2(X,Y)
               ENDIF
               ISTACK = ISTACK - 2
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               GOTO 299
C
C--- D : ( C1 C2 -- ) : DRAW TO (A1[1],A2[1])
 241           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               Y = STACK(ISTKTOP)
               X = STACK(ISTKPOP)
               IF( DOBB )THEN
                 BB(1) = MIN(BB(1),X)
                 BB(2) = MAX(BB(2),X)
                 BB(3) = MIN(BB(3),Y)
                 BB(4) = MAX(BB(4),Y)
               ELSE
                  CALL ON2(X,Y)
               ENDIF
               ISTACK = ISTACK - 2
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               GOTO 299
C
C--- HDSH : ( A1 -- A1 ) : DRAW RELATIVE (1,0) IF A1[I] > 0 ELSE MOVE
 242           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               DO 2142 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  X = X + 1.0
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     IF( ARG .GT. 0 )THEN
                        CALL ON2(X,Y)
                     ELSE
                        CALL OFF2(X,Y)
                     ENDIF
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2142          CONTINUE
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               GOTO 299
C
C--- VDSH : ( A1 -- A1 ) : DRAW RELATIVE (0,1) IF A1[I] > 0 ELSE MOVE
 243           CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               DO 2143 I=1,NELEM
                  ARG = STACK(ISTKTOP)
                  Y = Y + 1.0
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     IF( ARG .GT. 0 )THEN
                        CALL ON2(X,Y)
                     ELSE
                        CALL OFF2(X,Y)
                     ENDIF
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2143          CONTINUE
               IF( .NOT. DOBB)GCHANGE = .TRUE.
               GOTO 299
C
C--- XLIN : ( C1 C2 C3 -- ) : X = A1[1] TO A2[1] IN A3[1] LINEAR STEPS
 244           CONTINUE
               NEWELEM = INT(STACK(ISTKTOP))
               IF( NEWELEM .LT. 2 )GOTO 9007
               IF( NEWELEM .GT. NPOINTS )GOTO 9009
               RBASE = 1
               RSTART = STACK(ISTKPO2)
               RSTOP = STACK(ISTKPOP)
               CALL LINSPC(STACK,NEWELEM,RSTART,RSTOP)
               NELEM = NEWELEM
               ISTACK = ISTACK - 3
               GOTO 299
C
C--- PTHO, PTHC : ( A1 A2 -- ) : DRAW POLYLINE X=A1,Y=A2, OPEN/CLOSED
 245           CONTINUE
               CLOSED = .FALSE.
               GOTO 2145
 246           CONTINUE
               CLOSED = .TRUE.
 2145          CONTINUE
               IF( .NOT. HAVDEV )GOTO 9008
               X = XO = STACK(ISTKPOP)
               Y = YO = STACK(ISTKTOP)
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),X)
                  BB(2) = MAX(BB(2),X)
                  BB(3) = MIN(BB(3),Y)
                  BB(4) = MAX(BB(4),Y)
               ELSE
                  CALL OFF2(X,Y)
               ENDIF
               ISTKTOP = ISTKTOP + 1
               ISTKPOP = ISTKPOP + 1
               DO 2245 I=2,NELEM
                  X = STACK(ISTKPOP)
                  Y = STACK(ISTKTOP)
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     CALL ON2(X,Y)
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
                  ISTKPOP = ISTKPOP + 1
 2245          CONTINUE
               IF( CLOSED )THEN
                  IF( DOBB )THEN
                     BB(1) = MIN(BB(1),X)
                     BB(2) = MAX(BB(2),X)
                     BB(3) = MIN(BB(3),Y)
                     BB(4) = MAX(BB(4),Y)
                  ELSE
                     CALL ON2(XO,YO)
                  ENDIF
                  X = XO
                  Y = YO
               ENDIF
               IF( .NOT. DOBB )GCHANGE = .TRUE.
               ISTACK = ISTACK - 2
               GOTO 299
C
C--- ODD : ( A1 -- A1 ) : A1 = 1 WHERE A1 IS ODD ELSE 0
 247           CONTINUE
               DO 2147 I=1,NELEM
                  IARG = INT(STACK(ISTKTOP))
                  IF( 2*(IARG/2) .EQ. IARG )THEN
                     STACK(ISTKTOP) = 0
                  ELSE
                     STACK(ISTKTOP) = 1
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2147           CONTINUE
                GOTO 299
C
C--- ELEM : ( A1 C2 : A1 C2 ) : C2 = A1[C2]
 248            CONTINUE
                I = MAX(1,MIN(NELEM,INT(STACK(ISTKTOP))))
                V = STACK(ISTKPOP+I-1)
                DO 2148 I=1,NELEM
                   STACK(ISTKTOP) = V
                   ISTKTOP = ISTKTOP + 1
 2148           CONTINUE
                GOTO 299
C
C--- POP : ( A1 -- ) : POP THE STACK
 249            CONTINUE
                ISTACK = ISTACK - 1
                GOTO 299
C
C--- XLOG : ( C1 C2 C3 C4 -- ) : X = C1**C2 TO C1**C3 IN C4 STEPS
 250           CONTINUE
               NEWELEM = INT(STACK(ISTKTOP))
               IF( NEWELEM .LT. 2 )GOTO 9007
               IF( NEWELEM .GT. NPOINTS )GOTO 9009
               RBASE = STACK(ISTKPO3)
               RSTART = STACK(ISTKPO2)
               RSTOP = STACK(ISTKPOP)
               CALL LOGSPC(STACK,NEWELEM,RSTART,RSTOP,RBASE)
               NELEM = NEWELEM
               ISTACK = ISTACK - 4
               GOTO 299
C
C--- SEED : ( C1 -- ) : SET RANDOM NUMBER SEED TO A1[1]
 251           CONTINUE
               CALL RANSET(STACK(ISTKTOP))
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- MOD : ( A1 A2 -- A1 ) : A1 = MOD(A1,A2) OR A1 = A1 % A2
 252           CONTINUE
               DO 2152 I=1,NELEM
                  STACK(ISTKTOP) = MOD(STACK(ISTKTOP),STACK(ISTKPOP))
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2152          CONTINUE
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- I0IJ : ( C1 C2 -- C1 C2 ) : C1'=MOD(C1,C2), C2'=(C1/C2)
C--- I1IJ : ( C1 C2 -- C1 C2 ) : C1'=MOD(C1,C2)+1, C2'=(C1/C2)+1
 253           CONTINUE
               I = INT(STACK(ISTKTOP))
               IF( I .LE. 0 )GOTO 9005
               J = INT(STACK(ISTKPOP))
               IF( J .LE. 0 )GOTO 9005
               ARG = MOD(J-1,I) + 1
               V = (J-1) / I + 1
               GOTO 2253
 254           CONTINUE
               I = INT(STACK(ISTKTOP))
               IF( I .LE. 0 )GOTO 9005
               J = INT(STACK(ISTKPOP))
               IF( J .LE. 0 )GOTO 9005
               ARG = MOD(J-1,I)
               V = (J-1) / I
 2253          CONTINUE
               DO 2153 I=1,NELEM
                  STACK(ISTKPOP) = ARG
                  STACK(ISTKTOP) = V
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
 2153          CONTINUE
               GOTO 299
C
C--- T : ( C1 -- ) : DRAW CONTENTS OF STRING REGISTER C1 AS TEXT.
 255           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               IF( STRILEN(IREG) .EQ. 0 )GOTO 9010
               IF( .NOT. DOBB )THEN
                  CALL SYMTXT(STRINGS(IREG)(1:STRILEN(IREG)))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TVF : ( C1 C2 -- C1 ) : DRAW C1 AS TEXT USING FORMAT STRING IN C2.
C--- TVI : ( C1 C2 -- C1 ) : DRAW INT(C1) AS TEXT, AS PER TVF.
 256           CONTINUE
 257           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               IF( STRILEN(IREG) .EQ. 0 )GOTO 9010
               IF( .NOT. VALDFMT(STRINGS(IREG)(1:STRILEN(IREG))) )
     +            GOTO 9011
               IF( .NOT. DOBB )THEN
                  IF( IOP .EQ. 56 )THEN
                     CALL RNUM(STACK(ISTKPOP),
     +                         STRINGS(IREG)(1:STRILEN(IREG)))
                  ELSE
                     CALL INUM(INT(STACK(ISTKPOP)),
     +                         STRINGS(IREG)(1:STRILEN(IREG)))
                  ENDIF
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TS : ( C1 -- ) : DRAW SYMBOL WITH CODE NUMBER C1
C--- TM : ( C1 -- ) : DRAW MARKER WITH CODE NUMBER C1
C--- TC : ( C1 -- ) : DRAW CHARACTER FROM CUR ALPHABET WITH CODE C1
 258           CONTINUE
               VFMT = ' '
               WRITE(VFMT,2158)INT(STACK(ISTKTOP))
 2158          FORMAT('*:',I2.2)
               NFMT = 4
               GOTO 2260
 259           CONTINUE
               VFMT = ' '
               WRITE(VFMT,2159)INT(STACK(ISTKTOP))
 2159          FORMAT('*::',I2.2)
               NFMT = 5
               GOTO 2260
 260           CONTINUE
               VFMT = ' '
               WRITE(VFMT,2160)INT(STACK(ISTKTOP))
 2160          FORMAT('*V',I2.2)
               NFMT = 4
 2260          CONTINUE
               IF( .NOT. DOBB )THEN
                  CALL SYMTXT(VFMT(1:NFMT))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TH : ( C1 -- ) : SET TEXT/MARKER/SYMBOL HEIGHT
 261           CONTINUE
               CALL SYMHT(STACK(ISTKTOP))
               CALL MARKHT(STACK(ISTKTOP))
               ISTACK = ISTACK - 1
               GOTO 299
C
C--- TA : ( C1 -- ) : SET TEXT DRAWING ANGLE IN DEGREES CCW
 262           CONTINUE
               CALL SYMANG(STACK(ISTKTOP))
               GOTO 299
C
C--- TSC : ( -- ) : SET TEXT START CONTINUATION
 263           CONTINUE
               CALL SYMCON
               TXTCON = .TRUE.
               GOTO 299
C
C--- TEC : ( -- ) : SET TEXT END CONTINUATION
 264           CONTINUE
               CALL ENSYMC
               TXTCON = .FALSE.
               GOTO 299
C
C--- TLEN : ( C1 -- C1 ) : GET THE LENGTH IN BOUNDS UNITS OF A STRING
 265           CONTINUE
               IREG = INT(STACK(ISTKTOP))
               IF( IREG .LT. 1 .OR. IREG .GT. 9 )GOTO 9006
               IF( STRILEN(IREG) .EQ. 0 )GOTO 9010
               V = STRING(STRINGS(IREG)(1:STRILEN(IREG)))
               DO 2165 I=1,NELEM
                  STACK(ISTKTOP) = V
                  ISTKTOP = ISTKTOP + 1
 2165          CONTINUE
               GOTO 299
C
C--- PE : ( A1 C2 C3 -- A1 ): PRINT RANGE OF TOS ELEMENTS FREE FORMAT
 266           CONTINUE
               IOST = MAX(1,MIN(NELEM,INT(STACK(ISTKPOP))))
               IOEN = MAX(IOST,MIN(NELEM,INT(STACK(ISTKTOP))))
               DO 2166 I=IOST,IOEN
                  ARG = STACK(ISTKPO2+I-1)
                  WRITE(6,*)'TOS[',I,'] (OF ',NELEM,') = ',ARG
 2166          CONTINUE
               GOTO 299
C
C--- GT : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 > A2) ? 1 : 0 ;
C--- LT : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 < A2) ? 1 : 0 ;
C--- LE : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 <= A2) ? 1 : 0 ;
C--- GE : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 >= A2) ? 1 : 0 ;
C--- EQ : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 == A2) ? 1 : 0 ;
C--- NE : ( A1 A2 -- A1 A2 A3 ) : A3 = (A1 != A2) ? 1 : 0 ;
 267           CONTINUE
               IARG = 1
               GOTO 2367
 268           CONTINUE
               IARG = 2
               GOTO 2367
 269           CONTINUE
               IARG = 3
               GOTO 2367
 270           CONTINUE
               IARG = 4
               GOTO 2367
 271           CONTINUE
               IARG = 5
               GOTO 2367
 272           CONTINUE
               IARG = 6
 2367          CONTINUE
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKNEW = ISTACK * NPOINTS + 1
               DO 2167 I=1,NELEM
                  STACK(ISTKNEW) = 0
                  ARG = STACK(ISTKPOP)
                  V = STACK(ISTKTOP)
                  GOTO(2267,2268,2269,2270,2271,2272),IARG
 2267             CONTINUE
                  IF(ARG .GT. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2268             CONTINUE
                  IF(ARG .LT. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2269             CONTINUE
                  IF(ARG .LE. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2270             CONTINUE
                  IF(ARG .GE. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2271             CONTINUE
                  IF(ARG .EQ. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2272             CONTINUE
                  IF(ARG .NE. V)STACK(ISTKNEW) = 1.0
                  GOTO 2467
 2467             CONTINUE
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
                  ISTKNEW = ISTKNEW + 1
 2167          CONTINUE
               GOTO 299
C
C--- NOT : ( A1 -- A1 ) : A1 = (A1 == 0) ? 1 : 0 ;
 273           CONTINUE
               DO 2173 I=1,NELEM
                  IF( STACK(ISTKTOP) .EQ. 0.0 )THEN
                     STACK(ISTKTOP) = 1.0
                  ELSE
                     STACK(ISTKTOP) = 0.0
                  ENDIF
                  ISTKTOP = ISTKTOP + 1
 2173          CONTINUE
               GOTO 299
C
C--- SEL : ( A1 A2 A3 -- A1 A2 A3 ) : A3 = (A3 == 0) ? A1 : A2 ;
 274           CONTINUE
               DO 2174 I=1,NELEM
                  IF( STACK(ISTKTOP) .EQ. 0.0 )THEN
                     STACK(ISTKTOP) = STACK(ISTKPO2)
                  ELSE
                     STACK(ISTKTOP) = STACK(ISTKPOP)
                  ENDIF
                  ISTKPOP = ISTKPOP + 1
                  ISTKTOP = ISTKTOP + 1
                  ISTKNEW = ISTKNEW + 1
 2174          CONTINUE
               GOTO 299
C
C--- IDX : ( -- A1 ) : SET A1 TO THE ARRAY INDEX.
 275           CONTINUE
               ISTACK = ISTACK + 1
               IF( ISTACK .GT. NS1 )GOTO 9000
               ISTKNEW = ISTACK * NPOINTS + 1
               DO 2175 I=1,NELEM
                  STACK(ISTKNEW) = I
                  ISTKNEW = ISTKNEW + 1
 2175          CONTINUE
               GOTO 299
C
C--- SETY : ( A1 -- A1 ) : OVERWRITE GRAPH Y VALUES WITH STACK TOP VALS.
 276           CONTINUE
               J = NPOINTS + 1
               DO 2176 I=1,NELEM
                  STACK(J) = STACK(ISTKTOP)
                  ISTKTOP = ISTKTOP + 1
                  J = J + 1
 2176          CONTINUE
               GOTO 299
C
C--- C : ( C1 C2 C3 -- ) : DRAW CIRCLE, CENTER C1,C2 RADIUS C3.
 277           CONTINUE
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),STACK(ISTKPO2)-STACK(ISTKTOP))
                  BB(2) = MAX(BB(2),STACK(ISTKPO2)+STACK(ISTKTOP))
                  BB(3) = MIN(BB(3),STACK(ISTKPOP)-STACK(ISTKTOP))
                  BB(4) = MAX(BB(4),STACK(ISTKPOP)+STACK(ISTKTOP))
               ELSE
                  CALL CIRCLE(STACK(ISTKPO2), STACK(ISTKPOP),
     +                        STACK(ISTKTOP))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 3
               GOTO 299
C
C--- A : ( C1 C2 C3 C4 C5 -- ) : DRAW ARC, CTR C1,C2 RADIUS C3, C4 TO C5
 278           CONTINUE
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),STACK(ISTKPO4)-STACK(ISTKPO2))
                  BB(2) = MAX(BB(2),STACK(ISTKPO4)+STACK(ISTKPO2))
                  BB(3) = MIN(BB(3),STACK(ISTKPO3)-STACK(ISTKPO2))
                  BB(4) = MAX(BB(4),STACK(ISTKPO3)+STACK(ISTKPO2))
               ELSE
                  CALL CIRARC(STACK(ISTKPO4), STACK(ISTKPO3),
     +                        STACK(ISTKPO2), STACK(ISTKPOP),
     +                        STACK(ISTKTOP))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 5
               GOTO 299
C
C--- BOX : ( C1 C2 C3 C4 -- ) : DRAW RECTANGLE, B,L C1,C2 W,H C3,C4
 279           CONTINUE
               IF( DOBB )THEN
                  BB(1) = MIN(BB(1),STACK(ISTKPO3))
                  BB(2) = MAX(BB(2),STACK(ISTKPO3)+STACK(ISTKPOP))
                  BB(3) = MIN(BB(3),STACK(ISTKPO2))
                  BB(4) = MAX(BB(4),STACK(ISTKPO2)+STACK(ISTKTOP))
               ELSE
                  CALL RECT(STACK(ISTKPO3),STACK(ISTKPO2),0.0,
     +                      STACK(ISTKPOP),STACK(ISTKTOP))
                  GCHANGE = .TRUE.
               ENDIF
               ISTACK = ISTACK - 4
               GOTO 299
C
C--- PC : ( C1 -- C1 ) : PRINT C1 (TOS A[1]), FREE FORMAT.
 280           CONTINUE
               WRITE(6,*)'C1 = ',STACK(ISTKTOP)
               GOTO 299
C
C--- END OF OPERATOR SWITCH.
 299           CONTINUE
C
C--- END OF OPERAND OR OPERATOR.
            ENDIF
C
C--- END OF NON-ZERO TOKEN LENGTH.
         ENDIF
C
C--- LOOK FOR THE NEXT TOKEN.
         IBEG = IEND + 1
         GOTO 1
C
C--- NO MORE TOKENS.
 2    CONTINUE
      EVAL = IERR
      RETURN
C
C--- ERROR MESSAGES.
 9000 CONTINUE
      EMSG = 'STACK OVERFLOW'
      IERR = 1
      GOTO 9990
 9001 CONTINUE
      EMSG = 'STACK UNDERFLOW'
      IERR = 2
      GOTO 9990
 9002 CONTINUE
      EMSG = 'DIVIDE BY ZERO'
      IERR = 3
      GOTO 9990
 9003 CONTINUE
      EMSG = 'TOKEN TOO LONG'
      IERR = 4
      GOTO 9990
 9004 CONTINUE
      EMSG = 'UNKNOWN OPERATOR'
      IERR = 5
      GOTO 9990
 9005 CONTINUE
      EMSG = 'DOMAIN ERROR'
      IERR = 6
      GOTO 9990
 9006 CONTINUE
      EMSG = 'INVALID REGISTER NUMBER'
      IERR = 7
      GOTO 9990
 9007 CONTINUE
      EMSG = 'EVALUATION RANGE MUST HAVE 2 OR MORE STEPS'
      IERR = 8
      GOTO 9990
 9008 CONTINUE
      EMSG = 'GRAPHICS DEVICE MUST BE OPEN FOR THIS'
      IERR = 9
      GOTO 9990
 9009 CONTINUE
      EMSG = 'NEVAL CANNOT EXCEED NPOINTS'
      IERR = 10
      GOTO 9990
 9010 CONTINUE
      EMSG = 'EMPTY STRING REGISTER'
      IERR = 11
      GOTO 9990
 9011 CONTINUE
      EMSG = 'INVALID FORMAT STRING'
      IERR = 12
      GOTO 9990
 9990 CONTINUE
      IF( HAVDEV )CALL GFLUSH(IDEV,NDEVS,.TRUE.)
      WRITE(6,9991)EMSG(1:LNBC(EMSG,1,1))
      MARKER = ' '
      IF( IBEG .LT. 72 )THEN
         WRITE(6,9991)COPS(1:LCOPS)
 9991    FORMAT(1X,A)
         MARKER(IBEG:IBEG) = '!'
         WRITE(6,9991)MARKER(1:IBEG)
      ELSE
         IOST = MAX(1,IBEG-36)
         IOEN = MIN(LCOPS,IBEG+36)
         IF( (IBEG-36) .LT. 0 )THEN
            IMPOS = 37 + (IBEG - 36)
         ELSE
            IMPOS = 37
         ENDIF
         WRITE(6,9993)COPS(IOST:IOEN)
         MARKER(IMPOS:IMPOS) = '!'
         WRITE(6,9993)MARKER(1:IMPOS+1)
 9993    FORMAT(1X,'...',A,'...')
      ENDIF
      IF( IERR .EQ. 6 )THEN
         WRITE(6,9992)ARG
 9992    FORMAT(1X,'ARGUMENT CAUSING DOMAIN ERROR: ',G13.6)
      ENDIF
      EVAL = IERR
      RETURN
      END
C
      SUBROUTINE PATH( XARR, YARR, N, CLOSED )
C-------------------------------------------------
C DRAW A PATH (STRAIGHT LINE SEGMENTS) IN BOUNDS COORDINATES
C USING THE CONTENTS OF THE POINTS ARRAYS (GENERATED BY EVAL()).
C--------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER N
      REAL XARR(N), YARR(N)
      LOGICAL CLOSED
C---
      INTEGER I
C
      CALL OFF2(XARR(1),YARR(1))
      DO 1 I=2,N
         CALL ON2(XARR(I),YARR(I))
 1    CONTINUE
      IF( CLOSED )CALL ON2(XARR(1),YARR(1))
      RETURN
      END
C
      INTEGER FUNCTION EXPROC( RPN, PROCEXP, PROC, PROCLEN, NREGS )
C--------------------------------------------------
C EXPAND AN RPN STRING BY REPLACING ALL ,@N, SEQUENCES
C WITH THE CONTENTS OF PROC REGISTER PROC(N).
C--------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NREGS, PROCLEN(NREGS)
      CHARACTER*(*) RPN, PROCEXP, PROC(NREGS)
C---
      INTEGER INPOS, OUTPOS, ATPOS, LRPN, LPROC, IREG
      INTEGER LNBC
      CHARACTER*80 MARKER
      CHARACTER*9 REGNAME
      SAVE
      DATA REGNAME/'123456789'/
C
      LRPN = LNBC(RPN,1,1)
      INPOS = 0
      OUTPOS = 0
C
C--- LOOK AT EACH CHARACTER OF RPN. COPY TO OUTPUT UNLESS @A
 1    CONTINUE
      INPOS = INPOS + 1
      IF( INPOS .GT. LRPN )GOTO 2
      IF( RPN(INPOS:INPOS) .NE. '@' )THEN
         OUTPOS = OUTPOS + 1
         PROCEXP(OUTPOS:OUTPOS) = RPN(INPOS:INPOS)
C
C--- IF @ DECODE NEXT INPUT CHARACTER AS A SINGLE DIGIT.
      ELSE
         INPOS = INPOS + 1
         IF( INPOS .GT. LRPN )THEN
            WRITE(6,100)
            GOTO 900
         ENDIF
         IREG = INDEX(REGNAME,RPN(INPOS:INPOS))
         IF( IREG .EQ .0 )THEN
            WRITE(6,100)
            GOTO 900
         ENDIF
C
C--- INSERT THE CONTENTS OF PROC REGISTER IREG.
C--- PROCEXP CANNOT OVERFLOW DUE TO THE SIZES OF IT AND PROC REGISTERS.
         LPROC = PROCLEN(IREG)
         IF( LPROC .EQ. 0 )THEN
            WRITE(6,101)IREG
            GOTO 900
         ENDIF
         OUTPOS = OUTPOS + 1
         PROCEXP(OUTPOS:OUTPOS+LPROC-1) = PROC(IREG)(1:LPROC)
         OUTPOS = OUTPOS + LPROC - 1
      ENDIF
C
C--- GET THE NEXT CHARACTER FROM RPN (IF ANY).
      GOTO 1
 2    CONTINUE
C
C--- RETURN THE LENGTH OF PROCEXP.
      EXPROC = OUTPOS
      RETURN
C
C--- DEAL WITH ERRORS.
 900  CONTINUE
      WRITE(6,102)RPN(1:LRPN)
      MARKER = ' '
      MARKER(INPOS:INPOS) = '!'
      WRITE(6,102)MARKER(1:INPOS)
      EXPROC = 0
      RETURN
C
 102  FORMAT(1X,A)
 101  FORMAT(1X,'RPN ERROR: NOT INSERTING ZERO LENGTH PROC: ',I1)
 100  FORMAT(1X,'RPN ERROR: @ MUST BE FOLLOWED BY A DIGIT.')
      END
C
      LOGICAL FUNCTION BBEMPTY( BB )
C----------------------------------------
C RETURN .TRUE. IF BB HAS THE EMPTY BOUNDING BOX PATTERN, ELSE .FALSE.
C----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      REAL BB(4)
C
      BBEMPTY = (BB(1) .GT. 1.0E299) .AND. (BB(4) .LT. -1.0E299)
      RETURN
      END
C
      INTEGER FUNCTION LSYSTEM( NRULES, NITER, ANGLE,
     +                          STRINGS, STRILEN, REGS )
C-----------------------------------------
C GENERATE AND DRAW AN L-SYSTEM.
C THE AXIOM IS IN STRING REGISTER 1.
C THE RULES ARE IN STRING REGISTERS 2 ... 9 WITH NRULES DEFINED.
C THE ANGLE FOR TURNS IS ANGLE.
C-----------------------------------------
      IMPLICIT LOGICAL (A-Z)
      INTEGER NRULES, NITER, STRILEN(9)
      REAL ANGLE, REGS(9)
      CHARACTER*80 STRINGS(9)
C
      INTEGER NSUBST, NVALID, NSTACK
      PARAMETER(NSUBST=9, NVALID=NSUBST+5, NSTACK=20)
      INTEGER I, J, K, INLUN, OUTLUN, TMPLUN, IPASS, ISTK
      REAL XSTK(NSTACK), YSTK(NSTACK), ASTK(NSTACK), CANGLE
      REAL XPOS, YPOS, XNEW, YNEW, XLO, XHI, YLO, YHI, DANGLE, DX, DY
      LOGICAL CCSUB
      CHARACTER*(NVALID) CVALID
      CHARACTER*(NSUBST) CSUBST
      CHARACTER*1 CC
C
C--- CHECK FORMAT OF THE AXIOM AND RULES
C
      LSYSTEM = 0
      CVALID = 'F:ABCDEMXY+-[]'
      CSUBST = 'ABCDEFMXY'
      IF( STRILEN(1) .EQ. 0 )THEN
         WRITE(6,*)'AXIOM (STRING REGISTER 1) IS EMPTY'
         LSYSTEM = 1
         RETURN
      ENDIF
      DO 3 K=1,STRILEN(1)
         IF( INDEX(CVALID, STRINGS(1)(K:K)) .EQ. 0 )THEN
            WRITE(6,*)'INVALID CHAR ',STRINGS(1)(K:K),' IN AXIOM'
            LSYSTEM = 5
            RETURN
         ENDIF
 3    CONTINUE
      DO 1 I=1,NRULES
         J = I + 1
         IF( STRILEN(J) .LT. 3 )THEN
            WRITE(6,*)'RULE ',I,' (STRING REG ',J,') IS EMPTY OR SHORT'
            LSYSTEM = 2
            RETURN
         ENDIF
         IF( STRINGS(J)(2:2) .NE. ':' )THEN
            WRITE(6,*)'VARIABLE AND SUBSTITUTION MUST HAVE COLON BTW'
            LSYSTEM = 3
            RETURN
         ENDIF
         DO 2 K=1,STRILEN(J)
            IF( INDEX(CVALID, STRINGS(J)(K:K)) .EQ. 0 )THEN
               WRITE(6,*)'INVALID CHAR ',STRINGS(J)(K:K),' IN RULE ',I
               LSYSTEM = 4
               RETURN
            ENDIF
 2       CONTINUE
 1    CONTINUE
C
C--- OPEN TWO SCRATCH FILES ON LUNS 20 AND 21
C
      OPEN(UNIT=20,STATUS='SCRATCH',ERR=5)
      REWIND(UNIT=20)
      GOTO 6
 5    CONTINUE
      WRITE(6,*)'FAILED TO OPEN SCRATCH FILE ON LUN 20'
      LSYSTEM = 6
      RETURN
 6    CONTINUE
      OPEN(UNIT=21,STATUS='SCRATCH',ERR=7)
      REWIND(UNIT=21)
      GOTO 8
 7    CONTINUE
      CLOSE(UNIT=20)
      WRITE(6,*)'FAILED TO OPEN SCRATCH FILE ON LUN 21'
      LSYSTEM = 7
      RETURN
 8    CONTINUE
      OUTLUN = 20
      INLUN = 21
C
C--- INSERT THE AXIOM INTO SCRATCH FILE 1
C
      DO 10 I=1,STRILEN(1)
         WRITE(OUTLUN,100)STRINGS(1)(I:I)
 100     FORMAT(A1)
 10   CONTINUE
      REWIND(UNIT=OUTLUN)
C
C--- APPLY PRODUCTION RULES NITER TIMES.
C
      DO 11 J=1,NITER
         TMPLUN = INLUN
         INLUN = OUTLUN
         OUTLUN = TMPLUN
         REWIND(UNIT=INLUN)
         REWIND(UNIT=OUTLUN)
C
C--- READ EACH CHAR OF INLUN, CHECK RULES FOR SUBSTITUTIONS. APPLY THEM.
C
 12      CONTINUE
         READ(INLUN,100,END=13)CC
         CCSUB = .FALSE.
         DO 14 I=2,NRULES+1
            IF( CC .EQ. STRINGS(I)(1:1) )THEN
               DO 15 K=3,STRILEN(I)
                  WRITE(OUTLUN,100)STRINGS(I)(K:K)
 15            CONTINUE
               CCSUB = .TRUE.
            ENDIF
 14      CONTINUE
         IF( .NOT. CCSUB )THEN
            WRITE(OUTLUN,100)CC
         ENDIF
         GOTO 12
 13      CONTINUE
 11   CONTINUE
C
C--- THE FINAL PRODUCTION IS IN OUTLUN. REWIND IT AND DRAW IT.
C
      DO 90 IPASS=1,2
         REWIND(UNIT=OUTLUN)
         XPOS = REGS(1)
         YPOS = REGS(2)
         CANGLE = 3.141592653 * REGS(3) / 180.0
         DANGLE = 3.141592653 * ANGLE / 180.0
         ISTK = 1
         IF( IPASS .EQ. 1 )THEN
            XLO = XHI = XPOS
            YLO = YHI = YPOS
         ELSE
            CALL OFF2(XPOS, YPOS)
         ENDIF
 20      CONTINUE
            READ(OUTLUN,100,END=21)CC
C           WRITE(6,*)CC
            IF( (CC .EQ. 'F') .OR. (CC .EQ. 'M') )THEN
               XNEW = XPOS + COS(CANGLE)
               YNEW = YPOS + SIN(CANGLE)
               IF( IPASS .EQ. 2 )THEN
                  IF( CC .EQ. 'F' )THEN
                     CALL ON2(XNEW, YNEW)
                  ELSE
                     CALL OFF2(XNEW, YNEW)
                  ENDIF
               ELSE
                  XLO = MIN(XLO, XNEW)
                  YLO = MIN(YLO, YNEW)
                  XHI = MAX(XHI, XNEW)
                  YHI = MAX(YHI, YNEW)
               ENDIF
               XPOS = XNEW
               YPOS = YNEW
            ELSE IF( CC .EQ. '+' )THEN
               CANGLE = CANGLE + DANGLE
            ELSE IF( CC .EQ. '-' )THEN
               CANGLE = CANGLE - DANGLE
            ELSE IF( CC .EQ. '[' )THEN
               IF( ISTK .EQ. NSTACK )THEN
                  WRITE(6,*)'LSYSTEM - STACK OVERFLOW'
                  LSYSTEM = 9
                  GOTO 99
               ELSE
                  XSTK(ISTK) = XPOS
                  YSTK(ISTK) = YPOS
                  ASTK(ISTK) = CANGLE
                  ISTK = ISTK + 1
               ENDIF
            ELSE IF( CC .EQ. ']' )THEN
               IF( ISTK .EQ. 1 )THEN
                  WRITE(6,*)'LSYSTEM - STACK UNDERFLOW'
                  LSYSTEM = 10
                  GOTO 99
               ELSE
                  ISTK = ISTK - 1
                  XPOS = XSTK(ISTK)
                  YPOS = YSTK(ISTK)
                  CANGLE = ASTK(ISTK)
                  IF( IPASS .EQ. 2 )THEN
                     CALL OFF2(XPOS, YPOS)
                  ENDIF
               ENDIF
            ENDIF
            GOTO 20
 21      CONTINUE
         IF( IPASS .EQ. 1 )THEN
            WRITE(6,*)'SETTING BOUNDS TO: ',XLO,XHI,YLO,YHI,' +5%'
            DX = 0.05 * (XHI - XLO)
            DY = 0.05 * (YHI - YLO)
            CALL BOUNDS(XLO-DX,XHI+DX,YLO-DY,YHI+DY)
         ENDIF
 90   CONTINUE
C
C--- CLEAN UP AND RETURN.
C
 99   CONTINUE
      CLOSE(UNIT=20,ERR=30)
 30   CONTINUE
      CLOSE(UNIT=21,ERR=31)
 31   CONTINUE
      RETURN
      END
C
      SUBROUTINE LDPROC(PRNAME, IPREG, PREGS, IDEV, NDEVS, HAVDEV)
C------------------------------------------------
C TRY TO FIND PRNAME IN GPLPROC. IF FOUND, TRY TO LOAD PROCEDURE INTO
C PROCEDURE REGISTER IPREG
C------------------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) PRNAME
      INTEGER IPREG, IDEV, NDEVS
      CHARACTER*80 PREGS(9)
      LOGICAL HAVDEV
C---
      INTEGER IPFERR, LNBC, LPRNAME, ILINE, LLINE
      CHARACTER*80 LINE
C
C--- GET THE PROCEDURES LIBRARY FILE AS LOCAL.
C
      CALL PF('GET','GPLPROC','GPLPROC','NA','IGNR','RC',IPFERR)
      IF( IPFERR .NE.0 )THEN
         IF(HAVDEV)CALL GFLUSH(IDEV,NDEVS,.TRUE.)
         WRITE(6,*)'CANNOT GET GPLPROC, ERROR = ',IPFERR
         RETURN
      ENDIF
C
C--- OPEN GPLPROC
C
      OPEN(UNIT=30,FILE='GPLPROC',STATUS='OLD',ERR=1)
      GOTO 2
 1    CONTINUE
      WRITE(6,*)'CANNOT OPEN GPLPROC'
      RETURN
 2    CONTINUE
      REWIND(UNIT=30)
C
C--- LOOK FOR THE PROCEDURE NAME
C
      ILINE = 1
      LPRNAME = LNBC(PRNAME,1,1)
 3    CONTINUE
      READ(30,100,END=4,ERR=5)LINE
 100  FORMAT(A)
      LLINE = LNBC(LINE,1,1)
      IF( LLINE .EQ. LPRNAME )THEN
         READ(30,100,END=6,ERR=5)LINE
         PREGS(IPREG) = LINE
         GOTO 99
      ENDIF
      ILINE = ILINE + 1
      GOTO 3
C
C--- DID NOT FIND PROCEDURE CALLED PRNAME
C
 4    CONTINUE
      WRITE(6,*)'PROCEDURE ',PRNAME(1:LPRNAME),' NOT FOUND'
      GOTO 99
C
C--- ERROR READING GPLPROC
C
 5    CONTINUE
      WRITE(6,*)'ERROR READING GPLPROC AT LINE ',ILINE
      GOTO 99
C
C--- PROCEDURE NAME NOT FOLLOWED BY PROCEDURE
C
 6    CONTINUE
      WRITE(6,*)'MISSING PROCEDURE BODY AT LINE ',ILINE
      GOTO 99
C
C--- CLOSE GPLPROC AND RETURN
C
 99   CONTINUE
      CLOSE(UNIT=30,ERR=98)
 98   CONTINUE
      RETURN
      END
C
      SUBROUTINE TXBOX( TEXT, DEBUG )
C------------------------------------
C EXPERIMENT WITH BOXED TEXT. THIS IS NOT SO SIMPLE.
C------------------------------------
      IMPLICIT LOGICAL (A-Z)
      CHARACTER*(*) TEXT
      LOGICAL DEBUG
C---
      REAL STRING
      REAL W, WMAX, H, X0, Y0, WO
      INTEGER I,MODE, O, L, NL, PS, S, NTRIES
      CHARACTER*1 CC
      INTEGER MAXTRY
      PARAMETER(MAXTRY=10)
C
C--- DRAW A BOUNDING RECTANGLE WITHIN WHICH THE TEXT MUST FIT.
      CALL BOUNDS(-1.0,5.0,-1.0,5.0)
      CALL RECT(0.0,0.0,0.0,4.0,3.0)
C
C--- TURN ON TEXT PROPERTY CONTINUATION SO MULTIPLE SYMTXT CALLS
C--- KEEP PREVIOUSLY SET PROPERTIES.
      CALL TXTCON
C
C--- SET THE INITIAL TEXT HEIGHT AND MAXIMUM WIDTH.
      WMAX = 3.6
      H = 0.5
C
C--- IF A LINE CANNOT BE BROKEN, RETURN HERE WITH MODIFIED H.
      NTRIES = 1
 7    CONTINUE
      IF( NTRIES .GT. MAXTRY )GOTO 8
      CALL SYMHT(H)
C
C--- SET NUMBER OF OUTPUT LINES, LINE COUNTING MODE, GET CHAR COUNT.
      NL = 0
      MODE = 0
      L = LEN(TEXT)
C
C--- LOOP OVER MODE: 0: COUNT LINES, 1: DRAW TEXT.
C--- O: COUNT OF LINES OUTPUT, PS: PREVIOUS SPACE INDEX, S: SPACE INDEX
C--- I: CHARACTER INDEX.
 3    CONTINUE
      IF( MODE .GT. 1 )GOTO 4
      O = 0
      PS = 0
      S = 0
      I = 1
C
C--- LOOP OVER CHARACTERS.
 1    CONTINUE
      IF( I .GT. (L+1) )GOTO 2
      IF( I .EQ. (L+1) )THEN
         CC = ' '
      ELSE
         CC = TEXT(I:I)
      ENDIF
C
C--- TAKE ACTION WHEN CHARACTER IS A SPACE.
      IF( CC .EQ. ' ' )THEN
         IF(DEBUG)WRITE(6,*)'SPACE AT ',I
         S = I
         W = H * STRING(TEXT(O+1:S-1))
         IF(DEBUG)WRITE(6,*)'O=',O,', S=',S,', W=',W
C
C--- KEEP ADVANCING UNTIL ACCUMULATED WIDTH SINCE LAST OUTPUT EXCEEDS
C--- WMAX. UNTIL THEN, JUST KEEP TRACK OF THE PREVIOUS SPACE INDEX.
         IF( W .LT. WMAX )THEN
            PS = S
            IF(DEBUG)WRITE(6,*)'UPDATED PS=',PS
C
C--- OUTPUT WIDTH EXCEEDED. IF NO PREVIOUS SPACE, NOWHERE TO BREAK THAT
C--- WILL KEEP OUTPUT SHORT ENOUGH. OTHERWISE, INCREMENT LINE COUNT OR
C--- OUTPUT A LINE FROM THE LAST SPACE TO THIS ONE.
         ELSE
            IF(DEBUG)WRITE(6,*)'W GE WMAX, OUTPUT'
            IF( PS .EQ. 0 )THEN
               IF( MODE .EQ. 0 )THEN
                  IF(DEBUG)WRITE(6,*)'TOO LONG WITHOUT SPACES, ADJ H'
                  H = 0.8 * H
                  NTRIES = NTRIES + 1
                  GOTO 7
               ENDIF
            ELSE
               IF( MODE .EQ. 0 )THEN
                  NL = NL + 1
                  IF(DEBUG)WRITE(6,*)'MODE 0, NL=',NL
               ELSE
                  WO = H * STRING(TEXT(O+1:PS-1))
                  X0 = 2.0 - 0.5 * WO
                  CALL OFF2(X0,Y0)
                  CALL SYMTXT(TEXT(O+1:PS-1))
                  IF(DEBUG)
     +            WRITE(6,*)'M1, OUT:',TEXT(O+1:PS-1),' AT ',X0,',',Y0
                  Y0 = Y0 - H
               ENDIF
            ENDIF
C
C--- OUTPUT HAS BEEN DONE TO PREVIOUS SPACE. UPDATE PREVIOUS SPACE.
            O = PS
            PS = S
         ENDIF
      ENDIF
C
C--- MOVE TO NEXT INPUT CHARACTER.
      I = I + 1
      GOTO 1
 2    CONTINUE
C
C--- END OF INPUT TEXT. IF SOME PART HAS NOT YET BEEN OUTPUT, OUTPUT IT.
      IF(DEBUG)WRITE(6,*)'END OF TEXT'
      IF( O .LT. L )THEN
         IF(DEBUG)WRITE(6,*)'SOME TEXT LEFT TO OUTPUT'
         WO = H * STRING(TEXT(O+1:L))
         IF( MODE .EQ. 0 )THEN
            IF( WO .GT. WMAX )THEN
               IF(DEBUG)WRITE(6,*)'TOO LONG WITHOUT SPACES, ADJ H'
               H = 0.8 * H
               NTRIES = NTRIES + 1
               GOTO 7
            ELSE
               NL = NL + 1
               IF(DEBUG)WRITE(6,*)'NL=',NL
            ENDIF
         ELSE
            X0 = 2.0 - 0.5 * WO
            CALL OFF2(X0,Y0)
            CALL SYMTXT(TEXT(O+1:L))
            IF(DEBUG)WRITE(6,*)'OUT:',TEXT(O+1:L),' AT ',X0,',',Y0
         ENDIF
      ENDIF
C
C--- IN MODE 0 AT END OF TEXT, CALCULATE Y START POSITION FOR DRAWING.
      IF( MODE .EQ. 0 )THEN
         Y0 = 1.5 + ( (NL - 1) * 0.5 * H )
         IF(DEBUG)WRITE(6,*)'MODE 0, SETTING Y0=',Y0
         IF( Y0 .GT. (3.0 - H) )THEN
            IF(DEBUG)WRITE(6,*)'TEXT OUTSIDE BOX TOP. ADJ H'
            H = 0.8 * H
            NTRIES = NTRIES + 1
            GOTO 7
         ENDIF
      ENDIF
C
C--- MOVE FROM LINE COUNTING MODE TO DRAWING MODE.
      MODE = MODE + 1
      IF(DEBUG)WRITE(6,*)'GOING TO MODE ',MODE
      GOTO 3
C
C--- FINISHED PROCESSING IN DRAWING MODE. TURN OFF TEXT PROPERTY
C--- CONTINUATION AND RETURN.
 4    CONTINUE
      CALL ENTXTC
C
      RETURN
C
C--- COULD NOT GET THE TEXT TO FIT NO MATTER WHAT!
 8    CONTINUE
      CALL ENTXTC
      IF(DEBUG)WRITE(6,*)'FAILED TO FIT TEXT'
      RETURN
      END
