      SUBROUTINE DFXM11( NBET, NFONT, IERR, INO )
C --- -----------------------------------------------------------------
C
C --- THIS ROUTINE LOADS FONT NUMBER NFONT INTO ALPHABET NBET,
C --- RETURNING THE ERROR STATUS IN IERR AND THE NUMBER OF BYTES READ
C --- IN IN INO.
C
C                IERR NON-FATAL CODES
C
C         1   FONT NOT FOUND
C         2   FONT TRUNCATED (I.E. COORDINATES EXCEED MAX ALLOWED)
C         3   FONT HAS TOO MANY ENTRIES
C         4   FONT HAS TOO FEW ENTRIES
C         5   ERROR IN FONT LOAD. UNEXPECTED END OF FILE WHILE
C             READING IN FONT
C
C                IERR FATAL CODES
C
C        -1   SYSTEM ERROR - NO DATA TRANSFERRED
C        -2   SYSTEM ERROR - PARTIAL TRANSFER OF DATA
C
C
C --- NBET IS 1, 2, 3, 4 OR 5.
C --- 1 TO 3 ARE ALPHABETIC FONTS WITH 96 CHARACTERS DEFINED.
C --- 4 IS A SYMBOL FONT.
C --- 5 IS THE MARKER FONT.
C
C --- ENTRY POINTS IN THIS ROUTINE PERFORM OTHER FONT-RELATED TASKS.
C
C *********************************
C * ORIGINAL DESCRIPTION OF FONT  *
C * FILE CONTENTS AND FORMAT FROM *
C * UNMODIFIED DIMFILM SOURCE     *
C *********************************
C
C------------------------------------------------------
C
C      FONT FILE STRUCTURE
C
C      FILE HEADER:                                                     GENM1133
C           WORD 1:   FONT NUMBER (+VE VALUE, -VE END OF DATA FILE)     GENM1134
C                       (THE FOLLOWING TWO POINTERS ARE IMPLEMENTATION
C                        DEPENDENT IN THEIR INTERPRETATION:
C                        THEY MAY BE ABSOLUTE OR RELATIVE, AND IF
C                        RELATIVE MAY RELATE ONLY TO INDEX+DATA
C                        RECORDS OR INCLUDE ALLOWANCE FOR ANY
C                        OPTIONAL INTER-FONT FLAG RECORD.
C                        THAT IS THE POINTER MAY BE THE RECORD
C                        NUMBER OF THE PRECEDING/CURRENT FONT OR BE
C                        THE NUMBER OF INDEX+DATA RECORDS IN THE
C                        PRECEDING/CURRENT FONT.  THEY MAY BE USED FOR
C                        BACKWARD/FORWARD SKIPPING.  AN OPTIONAL
C                        INTER-FONT FLAG RECORD MAY ALSO BE USED FOR
C                        THIS PURPOSE.  THIS STRUCTURE IS CREATED BY
C                        THE FONT GENERATION PROGRAM: SEE FNTSRC
C                        TEMPLATE PROGRAM.)
C                2:   BACKWARD POINTER  (RECORD NUMBER OF HEADER FOR    GENM1135
C                                        PRECEDING FONT, OR NUMBER OF   GENM1136
C                                        INDEX+DATA RECORDS IN
C                                        PRECEDING FONT, -1 IF NONE)    GENM1136
C                3:   FORWARD POINTER    (RECORD NUMBER FOR HEADER OF   GENM1137
C                                         NEXT FONT, OR NUMBER OF       GENM1138
C                                         INDEX+DATA RECORDS IN THIS    GENM1138
C                                         FONT.   REDUNDANT FOR         GENM1138
C                                         FONT=-1)                      GENM1139
C                4:   NUMBER OF CHARACTERS IN FONT (INCLUDING ACCENTS)  GENM1140
C                                                   = <NUM>
C                5:   MONO HALF-WIDTH LEFT
C                6:   MONO HALF-WIDTH RIGHT
C                7:   BASE LINE OFFSET
C                8:   HEIGHT
C                9:   LINE SPACING
C                               (NOTE: 5-9 IN CHARACTRER RASTER UNITS)
C      INDEX:
C            <NUM> 5 WORD ENTRIES, BEING FOR EACH CHARACTER:
C           WORD 1:   LAST BYTE POINTER (I.E. FIRST BYTE-1 OF NEXT
C                                        CHARACTER)
C                2:   LEFT EXTENT (PROPORTIONAL)
C                3:   RIGHT EXTENT (PROPORTIONAL)
C                4:   LOWEST EXTENT (HEIGHT MIN)
C                5:   HIGHEST EXTENT (HEIGHT MAX)
C                     (FOR ACCENTS 4/5 ARE MIN/MAX HEIGHTS:
C                      WHEN ABSOLUTE VALUE LESS THAN 100 ARE
C                      ABSOLUTE MIN/MAX,
C                      WHEN ABSOLUTE VALUE IS 100 OR GREATER ARE
C                      MIN/MAX HEIGHTS RELATIVE TO PRECEDING
C                      CHARACTER,
C                      BOTH ZERO IF ACCENT DOES NOT AFFECT HEIGHT
C                      OF PRECEDING CHARACTER)
C
C      DATA:
C            CHARACTER DATA - DESCRIBED IN DFX202
C
C------------------------------------------------------                 COSM1128
C
CDC      IMPLICIT NONE
C
C --- ARGUMENTS.
C
      INTEGER NBET, NFONT, IERR, INO
      INTEGER IE
      INTEGER NB, NBYTE1, NBYTE2
C
C    MAXBET IS NUMBER OF SIMULTANEOUSLY IN-CORE ALPHABETS
C    DIMFILM CURRENTLY SUPPORTS MAXBET UP TO A MAXIMUM OF 3
C    *PLUS* A SYMBOL FONT AND A MARKER FONT.
      INTEGER MAXBET
      PARAMETER (MAXBET=3)
C
C --- LOCAL STORAGE.
C
      CHARACTER*16 HEX
      CHARACTER*72 LINE
      INTEGER HEADER(9), MAXCH, NREC, NCHAR, NCH, FLEN
      INTEGER IOS, I, J, K, L, M, P, W, NBYTES, CBYTES
      INTEGER SW, EW, CW, SB, PCW, ISKIP
      INTEGER GETBYT
      INTEGER PBASE(MAXBET+2)
      LOGICAL FSTLN
C
      INTEGER FLUN
      PARAMETER( FLUN=16 )
C
C --- NBPW - BYTES PACKED PER WORD.
C --- NBA, NBS, NBM - NO OF BYTES IN ALPHABET, SYMBOL, MARKER FONTS.
C --- NWA, NWS, NWM - NO OF WORDS IN ALPHABET, SYMBOL, MARKER FONTS.
C --- PBET1, PBET2, PBET3 - INDEX OF START OF ALPHABET FONTS IN WORDS.
C --- PBET4, PBET5 - INDEX OF START OF SYMBOL AND MARKER FONTS.
C --- NWDATA - TOTAL NUMBER OF WORDS OF PACKED FONT DATA.
      INTEGER NBPW
C --- 32 BIT INTEGER MACHINES:      PARAMETER(NBPW=4)
C --- 60 BIT INTEGER MACHINES:      PARAMETER(NBPW=6)
#ifdef PORTF77
      PARAMETER(NBPW=4)
#else      
      PARAMETER(NBPW=6)
#endif      
      INTEGER NBA, NBS, NBM
      PARAMETER(NBA=12000,NBS=10000,NBM=2000)
      INTEGER NWA, NWS, NWM
      PARAMETER(NWA=NBA/NBPW,NWS=NBS/NBPW,NWM=NBM/NBPW)
      INTEGER PBET1,PBET2,PBET3
      PARAMETER(PBET1=1,PBET2=PBET1+NWA,PBET3=PBET2+NWA)
      INTEGER PBET4,PBET5
      PARAMETER(PBET4=PBET3+NWA,PBET5=PBET4+NWS)
      INTEGER NWDATA
      PARAMETER(NWDATA=PBET5+NWM)
C
C --- COMMONS, TAKEN FROM JOHN GILBERTS DFXM11 SOURCE.
C
C      INTEGER MHWLRU,MHWRRU,BLORU,HRU,LSRU,LBYTEA,LBYTES,LBYTEM
C      INTEGER IXTENT,CFONT
C      INTEGER LXTEQV,RXTEQV,LYTEQV,UYTEQV
C      INTEGER LXTEQ1,RXTEQ1,LYTEQ1,UYTEQ1
C      INTEGER LXTENT(1:120,MAXBET+1),RXTENT(1:120,MAXBET+1)
C      INTEGER LYTENT(1:120,MAXBET+1),UYTENT(1:120,MAXBET+1)
C      INTEGER LBYTEQ(0:120,MAXBET+1),BETCHS
C --- FONT PARAMETERS FOR EACH CHARACTER
C      COMMON /DFXC20/ MHWLRU(MAXBET+2),MHWRRU(MAXBET+2),
C     1                BLORU(MAXBET+2),HRU(MAXBET+2),LSRU(MAXBET+2),
C     2                LXTEQV(1:120,MAXBET),LXTEQ1(1:96),
C     3                RXTEQV(1:120,MAXBET),RXTEQ1(1:96),
C     4                LYTEQV(1:120,MAXBET),LYTEQ1(1:96),
C     5                UYTEQV(1:120,MAXBET),UYTEQ1(1:96),
C     6                LBYTEA(0:120,MAXBET),LBYTES(0:96),LBYTEM(0:48),
C     7                IXTENT,CFONT(MAXBET+2),BETCHS(MAXBET+2)
C    EQUIVALENCE REQUIRED TO AVOID WASTED SPACE AND ENABLE SINGLE
C    ARRAY REFERENCE FOR ALPHABETS AND SYMBOLS (THE LATTER NOT
C    POSSESSING THE APPENDED 24 ACCENT SET)
C      EQUIVALENCE (LXTENT,LXTEQV),(RXTENT,RXTEQV),(LYTENT,LYTEQV)
C      EQUIVALENCE (UYTENT,UYTEQV),(LBYTEA,LBYTEQ)
      INCLUDE 'dfxc20s.cmn'
      INCLUDE 'dfxc21.cmn'
      INCLUDE 'dfxc22b.cmn'
      INCLUDE 'dfxc20.cmn'
C
C --- WE EXPECT THIS ROUTINE TO WORK WITHOUT ANY ERRORS.
C
      IERR = 0
      INO = 0
      ISKIP = 0
C
C --- SET UP THE BASE OF EACH ALPHABET IN WORD STORAGE ARRAY
C
      PBASE(1) = PBET1
      PBASE(2) = PBET2
      PBASE(3) = PBET3
      PBASE(4) = PBET4
      PBASE(5) = PBET5
C
C --- GET THE MAXIMUM CHARACTERS DEFINED IN A FONT AND THE MAXIMUM
C --- ALLOWED BYTES
C
      IF (NBET.EQ.4) THEN
        MAXCH=96
        FLEN=NBS
      ELSE IF (NBET.EQ.5) THEN
        MAXCH=48
        FLEN=NBM
      ELSE
        MAXCH=120
        FLEN=NBA
      ENDIF
C
C --- INITIALIZE INDEX BYTE POINTERS FOR ALL CHARACTERS TO ZERO.
C
      IF (NBET.EQ.5) THEN
         DO 503 I=0,MAXCH
  503       LBYTEM(I)=0
      ELSE
         DO 500 I=0,MAXCH
  500       LBYTEQ(I,NBET)=0
      ENDIF
C
C --- REWIND THE FONT FILE.
C     AT PRESENT, REWIND DOES NOT SEEM TO WORK ON COS, THOUGH, SO
C     ALWAYS OPEN THE FONT FILE HERE. 
C
C      REWIND( UNIT=FLUN, IOSTAT=IOS )
C      IF( IOS .NE. 0 )THEN
C         IERR = -1
C         RETURN
C     ENDIF
      IE = 0
      OPEN( UNIT=FLUN, FILE='DADIMFO',
     1      STATUS='OLD', FORM='FORMATTED',
     1     ACCESS='SEQUENTIAL', IOSTAT=IE )
      IF( IE .NE. 0 ) CALL DFXMSA( IE )
      FSTLN = .TRUE.
C
C     HOWEVER, FILES ARE NOT REWOUND ON OPEN IN NOS, SO
C     REWIND EXPLICITLY AFTER OPENING.
C
      REWIND( UNIT=FLUN, IOSTAT=IOS )
C
C --- READ LINES UNTIL WE FIND A Z IN COLUMN 1.
C
 1    CONTINUE
      READ(FLUN,100,END=2)LINE
 100  FORMAT(A72)
      IF( LINE(1:1) .EQ. 'Z' )GOTO 3
      GOTO 1
 2    IERR = 1
      PRINT 101,NFONT
 101  FORMAT( ' DFXM11 FONT ',I3,' NOT FOUND IN FONT FILE.' )
      IE = 0
      CLOSE( UNIT=FLUN, IOSTAT=IE )
      IF( IE .NE. 0 ) CALL DFXMSA( IE )
      RETURN
 3    CONTINUE
C
C --- READ IN THE HEADER RECORD.
C
      READ(FLUN,*) (HEADER(I),I=1,9)
      IF( FSTLN )THEN
         FSTLN = .FALSE.
      ENDIF
C
C --- SEE IF THIS IS THE FONT WE WANT.
C
      IF( HEADER(1) .NE. NFONT )GOTO 1
C
C --- COPY THE DATA FROM THE HEADER.
C
      MHWLRU(NBET) = HEADER(5)
      MHWRRU(NBET) = HEADER(6)
      BLORU (NBET) = HEADER(7)
      HRU   (NBET) = HEADER(8)
      LSRU  (NBET) = HEADER(9)
C
C --- NG- OCT 2008: DEBUG.
C
C     PRINT 1999,HEADER(1),HEADER(2),HEADER(3),HEADER(4)
C1999 FORMAT(1X,'HEADER1-4 ',I6,I6,I6,I6)
C     PRINT 1998,HEADER(5),HEADER(6),HEADER(7),HEADER(8),HEADER(9)
C1998 FORMAT(1X,'HEADER5-9 ',I6,I6,I6,I6,I6)
C
C --- SET NUMBER OF CHARACTERS ACTUALLY DEFINED IN THIS FONT.
C --- SINCE OUR RECONSTRUCTED FONTS DO NOT CORRECTLY MATCH WHAT
C --- DIMFILM EXPECTS, SUPPRESS ERROR MESSAGES AND CODES FOR CERTAIN
C --- MISMATCHES.
C
      NCH = HEADER(4)
      IF( NCH .GT. MAXCH )THEN
C         PRINT 111,NCH,MAXCH
C 111     FORMAT(' DFXM11 FONT HAS ',I4,' CHARS. MAX ',I3 )
C         IERR = 3
         ISKIP = NCH - MAXCH
C        PRINT 1111,ISKIP
C1111    FORMAT(' SKIPPING ',I4,' EXCESS INDEX RECORDS.')
         NCH = MAXCH
      ENDIF
      IF( NBET .LT. 4 )THEN
         IF( NCH .LT. 96 )THEN
            PRINT 112,NCH
 112        FORMAT(' DFXM11 EXPECTED 96 CHAR. GOT ',I3 )
C            IERR = 4
         ENDIF
      ENDIF
C
C --- LOAD THE INDEX.
C
      IF( NBET .EQ. 5 ) THEN
         DO 2101 I=1,NCH
            READ(FLUN, *, IOSTAT=IOS) LBYTEM(I), J1, J2, J3, J4
            IF( IOS .NE. 0 )GOTO 2102
 2101    CONTINUE
C         PRINT 888,NCH
C 888     FORMAT(1X,'MARKER: ',I6,' NCH' )
C         READ(FLUN, *, IOSTAT=IOS) (LBYTEM(I), J,J,J,J, I = 1, NCH)
      ELSE
         DO 2100 I=1,NCH
            READ(FLUN, 2121, IOSTAT=IOS) IR1, IR2, IR3, IR4, IR5
 2121       FORMAT(I8,I6,I6,I6,I6)
            IF( IOS .NE. 0 )GOTO 2102
            LBYTEQ(I,NBET) = IR1
            LXTENT(I,NBET) = IR2
            RXTENT(I,NBET) = IR3
            LYTENT(I,NBET) = IR4
            UYTENT(I,NBET) = IR5
 2100    CONTINUE
C         READ(FLUN, *, IOSTAT=IOS) (LBYTEQ(I,NBET), LXTENT(I,NBET),
C     &    RXTENT(I,NBET), LYTENT(I,NBET), UYTENT(I,NBET), I = 1, NCH)
      ENDIF
C
 2102 CONTINUE
      IF( IOS .NE. 0 ) THEN
         PRINT 103, NFONT
  103    FORMAT(' DFXM11 CANNOT READ INDEX FOR FONT ', I4)
         CALL DFXMSA( IOS )
         IERR = -2

         IE = 0
         CLOSE( UNIT=FLUN, IOSTAT=IE )
         IF( IE .NE. 0 ) CALL DFXMSA( IE )

         RETURN
      ENDIF
C
C --- PATCH UP THE INDEX ENTRIES ... SIGH ...
C
      IF( NBET .EQ. 5 )THEN
         DO 666 I=1,NCH
            LBYTEM(I) = LBYTEM(I) + 1
 666     CONTINUE
      ELSE
         DO 667 I=1,NCH
            LBYTEQ(I,NBET) = LBYTEQ(I,NBET) + 1
CX            PRINT 1997,I,LBYTEQ(I,NBET)
CX 1997       FORMAT(1X,'IDX ',I6,' = ',I9)
 667     CONTINUE
      ENDIF
C
C --- LOAD THE NUMBER OF FONT VECTORS.
C
      READ( FLUN, *, IOSTAT=IOS ) NBYTES
      IF( IOS .NE. 0 ) THEN
         PRINT 104, NFONT
  104    FORMAT(' DFXM11 CANNOT READ VECTOR BYTE COUNT FOR FONT ', I3 )
         NBYTES = 0
         CALL DFXMSA( IOS )
         IERR = -2
         IE = 0
         CLOSE( UNIT=FLUN, IOSTAT=IE )
         IF( IE .NE. 0 ) CALL DFXMSA( IE )         
         RETURN
      ENDIF
C
C --- LIMIT NYBTES TO THE MAXIMUM ALLOWED BYTE COUNT
C
      IF( NBYTES .GT. FLEN )THEN
         PRINT 113,NBYTES,FLEN
 113     FORMAT(' DFXM11 GOT ',I6,' FONT BYTES. MAX. ', I5 )
         IERR = 2
         NBYTES = FLEN
      ENDIF
C
C --- READ IN THE FONT VECTOR DATA. PACK IT INTO INTEGERS, NBPW BYTES
C --- PER INTEGER. THIS IS MEANT TO BE PORTABLE RATHER THAN EFFICIENT.
C
      P = PBASE(NBET)
      CBYTES = NBYTES
      HEX = '0123456789ABCDEF'
      NREC = ( NBYTES - 1 ) / 36 + 1
      DO 10 I=1,NREC
         READ(FLUN,100,IOSTAT=IOS)LINE
         IF( IOS .NE. 0 )THEN
            PRINT 116,NFONT
 116        FORMAT(' UNEXPECTED EOF READING FONT ',I3,' VECTORS.')
            GOTO 23
         ENDIF
         NCHAR = 2 * CBYTES
         IF( NCHAR .GT. 72 )NCHAR = 72
         DO 11 J=1,NCHAR,2*NBPW
            W = 0
            DO 12 L = 0,2*NBPW-1
               M = J + L
               K = INDEX(HEX,LINE(M:M)) - 1
               IF( K .GE. 16 )K = 0
               IF( K .LT. 0 )K = 0
               W = 16 * W + K
  12        CONTINUE
            WDATA(P) = W
C
C --- NG- OCT 2008: DEBUG FONTS
C
C           PRINT 1777,P,W
C1777       FORMAT(1X,'P=',I6,' W(P)=',Z12)
C
            P = P + 1
  11     CONTINUE
         CBYTES = CBYTES - 36
  10  CONTINUE
  23  CONTINUE
C
C --- RETURN THE NUMBER OF BYTES READ.
C
      IF( CBYTES .LT. 0 )CBYTES = 0
      INO = NBYTES - CBYTES
      IE = 0
      CLOSE( UNIT=FLUN, IOSTAT=IE )
      IF( IE .NE. 0 ) CALL DFXMSA( IE )      
      RETURN
C
C --- -----------------------------------------------------------------
      ENTRY DFXM10( IEA )
C --- -----------------------------------------------------------------
C
C --- OPEN "THE" FONT FILE - IF THERE IS A SINGLE FONT FILE.
C     DO NOT DO ANYTHING HERE AS OF 2025 FOR COS COMPATIBILITY.
C     WE OPEN AND CLOSE THE FONT FILE FOR EVERY FONT REQUEST.
C
      IEA = 0
C      OPEN( UNIT=FLUN, FILE='DADIMFO',
C     1      STATUS='OLD', FORM='FORMATTED',
C     1      ACCESS='SEQUENTIAL', IOSTAT=IEA )
      IF( IEA .NE. 0 ) CALL DFXMSA( IEA )
      RETURN
C
C --- -----------------------------------------------------------------
      ENTRY DFXM12( IEB )
C --- -----------------------------------------------------------------
C
C --- CLOSE "THE" FONT FILE - IF THERE IS A SINGLE FONT FILE.
C     DO NOT DO ANYTHING HERE.
C
      IEB = 0
C      CLOSE( UNIT=FLUN, IOSTAT=IEB )
C      IF( IEB .NE. 0 ) CALL DFXMSA( IEB )
      RETURN
C
C --- -----------------------------------------------------------------
      ENTRY DFXM20( NB, NBYTE1, NBYTE2 )
C --- -----------------------------------------------------------------
C
C    ROUTINE UNPACKS DATA FROM COMMON BLOCK DFXC21 AND PUTS
C    IT IN ARRAY ICDATA IN DFXC22.
C    UNPACKS NBYTE1 TO NBYTE2 INCLUSIVE OF ALPHABET NB
C    INTO ICDATA.
C
C    IT IS IMPLEMENTATION DEPENDENT AS TO HOW THE FONT DATA IS
C    STORED IN /DFXC21/ - IT IS SUGGESTED DATA BE PACKED AS
C    BYTES WHICH ARE UNPACKED INTO SIGNED INTEGER VALUES
C    IN RANGE -127,+127
C
C
C --- SET UP THE BASE OF EACH ALPHABET IN WORD STORAGE ARRAY
C
      PBASE(1) = PBET1
      PBASE(2) = PBET2
      PBASE(3) = PBET3
      PBASE(4) = PBET4
      PBASE(5) = PBET5
C
C --- FIND THE FIRST AND LAST WORDS FOR THIS BYTE RANGE
C
CX      PRINT 179,NB,NBYTE1,NBYTE2,PBASE(NB)
CX 179  FORMAT(1X,'NB=',I6,' NBYTE1=',I6,' NBYTE2=',I6,' PBASE(NB)=',I6)
      SW = ( NBYTE1 - 1 ) / NBPW
      EW = ( NBYTE2 - 1 ) / NBPW
      SB = NBPW * SW + 1
CX      PRINT 180,SW,EW,SB
CX 180  FORMAT(1X,'SW=',I6,' EW=',I6,' SB=',I6)
C
C --- STEP OVER THE WORDS. OFFSET THE WORD BY THE ALPHABET START.
C
      J = 0
      DO 2000 CW=SW,EW
         PCW = CW  + PBASE(NB)
         DO 2001 I=1,NBPW
            IF( SB .GE. NBYTE1 .AND. SB .LE. NBYTE2 )THEN
               J = J + 1
               ICDATA(J) = GETBYT( WDATA(PCW), NBPW-I )
CX               PRINT 181,J,ICDATA(J)
CX 181           FORMAT(1X,I4,I6)
            ENDIF
            SB = SB + 1
 2001    CONTINUE
 2000 CONTINUE
C
C --- INVERT Y ... QUE, MANUEL?
C
      DO 2002 K=2,J,2
         ICDATA(K) = -ICDATA(K)
 2002 CONTINUE
C
      RETURN
C
      END
