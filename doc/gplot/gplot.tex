%% Based on a TeXnicCenter-Template by Tino Weinkauf.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% HEADER
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,twoside,11pt]{article}
% Alternative Options:
%	Paper Size: a4paper / a5paper / b5paper / letterpaper / legalpaper / executivepaper
% Duplex: oneside / twoside
% Base Font Size: 10pt / 11pt / 12pt


%% Language %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[USenglish]{babel} %francais, polish, spanish, ...
\usepackage[T1]{fontenc}
%%\usepackage[ansinew]{inputenc}

\usepackage{lmodern} %Type1-font for non-english texts and characters

%% NG: Try the following for sans serif.
%% Well - take your pick. helvet leaves math in serif. But is otherwise rather nice?
\usepackage[scaled]{helvet}
%%\usepackage[math]{kurier}  %% Not nice.
%%\usepackage[math]{iwona}   %% Not nice.
%%\usepackage{cmbright}      %% Still will not work after installing hfbright.
\renewcommand*\familydefault{\sfdefault}

\usepackage{eulervm}
\usepackage{url}

%% NG: Try this for colour.
\usepackage{color}

\usepackage{float}

%% NG: Try this for HTML output
%% Also choose LaTeX => HTML of course ...
%%\usepackage[html]{tex4ht}

%% Packages for Graphics & Figures %%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx} %%For loading graphic files
%\usepackage{subfig} %%Subfigures inside a figure
%\usepackage{tikz} %%Generate vector graphics from within LaTeX

%% Please note:
%% Images can be included using \includegraphics{filename}
%% resp. using the dialog in the Insert menu.
%% 
%% The mode "LaTeX => PDF" allows the following formats:
%%   .jpg  .png  .pdf  .mps
%% 
%% The modes "LaTeX => DVI", "LaTeX => PS" und "LaTeX => PS => PDF"
%% allow the following formats:
%%   .eps  .ps  .bmp  .pict  .pntg

%% NG: Try this to scale graphics to be at most the line length wide.
%% \includegraphics[width=\maxwidth]{figure}
\makeatletter
\def\maxwidth{%
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

%% NG: Try fancy chapter headings.
%% This is Ulf Lindgren's FncyChap package. But set to Sans.
%\usepackage[Lenny]{fncychap}
%\ChTitleVar{\Huge\bfseries\sf}
%\usepackage[Glenn]{fncychap}
%\ChTitleVar{\Large\bfseries\sf}

%% NG: And we might want text in a box.
\usepackage{boxedminipage}

%% Math Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{mathrsfs}


%% Line Spacing %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{setspace}
%\singlespacing        %% 1-spacing (default)
%\onehalfspacing       %% 1,5-spacing
%\doublespacing        %% 2-spacing


%% Other Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{a4wide} %%Smaller margins = more text per page.
\usepackage{fancyhdr} %%Fancy headings
%\usepackage{longtable} %%For tables, that exceed one page

%% NG: Fancy verbatim text
\usepackage{relsize,fancyvrb}

%% NG: Font for Creative Commons license thing
\usepackage{cclicenses}

%% NG: Try barcodes (crumbs!)
%\usepackage{pst-barcode,pstricks-add}

%% NG: Node diagrams
\usepackage{pstricks,pst-node}

%% NG: Landscape?
\usepackage{lscape}

%% NG: Source code listings
\usepackage{listings,color}
\lstloadlanguages{Python,bash}
\lstdefinestyle{cp}{
  language=Python,
  frame=single,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily
}
\lstdefinestyle{sh}{
  language=bash,
  frame=single,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily
}
\lstdefinestyle{cpt}{
  language=Python,
  frame=single,
  showstringspaces=false,
  basicstyle=\tiny\ttfamily
}
\lstset{style=sh}

%% Index
%\usepackage{makeidx}
%\makeindex

%% NG: Adjust contents layout.
\usepackage{tocloft}
\setlength{\cftsecnumwidth}{3em}
\setlength{\cftsubsecnumwidth}{4em}
\setlength{\cftsubsubsecnumwidth}{5em}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Remarks
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% TODO:
% 1. Edit the used packages and their options (see above).
% 2. If you want, add a BibTeX-File to the project
%    (e.g., 'literature.bib').
% 3. Happy TeXing!
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Options / Modifications
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\input{options} %You need a file 'options.tex' for this
%% ==> TeXnicCenter supplies some possible option files
%% ==> with its templates (File | New from Template...).
\newcommand{\newpara}{\par\vspace{4mm}\noindent}
\newcommand{\myldots}{\ldots\ }

\addto\captionsUSenglish{\renewcommand*\abstractname{Summary}}

% Let us try bold text in red ...
\definecolor{OurRed}{rgb}{0.9,0.1,0.1}
\newcommand{\textbfc}[1]{\textbf{\textcolor{OurRed}{#1}}}
\newcommand{\textttc}[1]{\texttt{\textcolor{OurRed}{#1}}}
\newcommand{\textc}[1]{\textcolor{OurRed}{#1}}

% And in green ...
\definecolor{OurGreen}{rgb}{0.1,0.5,0.1}
\newcommand{\textbfg}[1]{\textbf{\textcolor{OurGreen}{#1}}}

% Title page background colour.
\definecolor{titlepagecolor}{cmyk}{1,.60,0,.40}

% Alter some LaTeX defaults for better treatment of figures:
    % See p.105 of "TeX Unbound" for suggested values.
    % See pp. 199-200 of Lamport's "LaTeX" book for details.
    %   General parameters, for ALL pages:
    \renewcommand{\topfraction}{0.9}	% max fraction of floats at top
    \renewcommand{\bottomfraction}{0.8}	% max fraction of floats at bottom
    %   Parameters for TEXT pages (not float pages):
    \setcounter{topnumber}{2}
    \setcounter{bottomnumber}{2}
    \setcounter{totalnumber}{4}     % 2 may work better
    \setcounter{dbltopnumber}{2}    % for 2-column pages
    \renewcommand{\dbltopfraction}{0.9}	% fit big float above 2-col. text
    \renewcommand{\textfraction}{0.07}	% allow minimal text w. figs
    %   Parameters for FLOAT pages (not text pages):
    \renewcommand{\floatpagefraction}{0.7}	% require fuller float pages
	% N.B.: floatpagefraction MUST be less than topfraction !!
    \renewcommand{\dblfloatpagefraction}{0.7}	% require fuller float pages

%% argmin math operator    
\DeclareMathOperator*{\argmin}{\arg\!\min}

%% Choose to include the giant COMP figures or NOT.
\newif\ifinclcomp
\inclcompfalse
%%\inclcomptrue

    
\usepackage[xetex,unicode,
pdftitle={GPLOT: A DIMFILM Based Graph Plotting and Drawing Program for CDC NOS 2.8
  and other Operating Systems},
pdfauthor={Nick Glazzard},
colorlinks,linkcolor=blue,citecolor=blue,urlcolor=blue
]{hyperref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

%%\title{\textbf{GPLOT}: A \textbf{DIMFILM} Based Graph Plotting \\ and Drawing Program for CDC NOS 2.8}
%%\author{Nick Glazzard}
%%\maketitle

\begin{titlepage}
\pagecolor{titlepagecolor}

\vspace*{25mm}
{\color{white} \noindent \rule{\textwidth}{3mm}}
\begin{center}
\Huge
\textcolor{white}{\textbf{GPLOT}: A \textbf{DIMFILM} Based Graph Plotting \\ and Drawing Program for CDC NOS 2.8 \\ and other Operating Systems}
\end{center}
\vspace*{2mm}
{\color{white} \noindent \rule{\textwidth}{3mm}}

\vspace*{6cm}

\begin{center}
\Large 
\textcolor{white}{
  Nick Glazzard
}
\end{center}

\vspace*{2cm}

\begin{center}
\Large 
\textcolor{white}{
Version 0.90\\
\today
}
\end{center}

\end{titlepage}

\pagecolor{white}


%%\begin{abstract}
%%Stuff
%%\end{abstract}

\clearpage

\tableofcontents

\clearpage

\section{Introduction}
\newpara
\textbf{GPLOT} is an interactive graphics program based on U.L.C.C. \textbf{DIMFILM}, a substantial graphics
library written and maintained
by Dr. John Gilbert between 1972 and approximately 1995. The version of \textbf{DIMFILM} used is
from somewhere around 1984 and is the second major version, which moved away from CDC Fortran
to portable, standard Fortran-77 (necessitated by U.L.C.C.'s move to Amdahl IBM compatible machines). 
\newpara
\textbf{GPLOT}, in contrast, was deliberately written for the CDC \texttt{FTN5} compiler under NOS 2.8 and
was not intended to be portable. It uses seven letter identifiers, dynamic memory allocation (via
the Common Memory Manager), and makes some use of NOS system calls.
\newpara
That said, it can be built and used on ``Unix-like'' systems (Debian Linux and macOS have been tested)
where it behaves almost identically to the NOS version. As of V0.89, it can also be built on VAX/VMS and
(experimentally) NOS/VE.
\newpara
Originally, \textbf{GPLOT} was focussed on plotting graphs from tabulated data and could perhaps be thought of
as a stripped down \textbf{Gnuplot}, though with far fewer capabilities.
Recent versions have extended its capabilities in new directions so that it can be used for drawing block diagrams,
tables and other technical drawings.
\newpara
The primary `interactive' output device for \textbf{GPLOT} is \textbf{GTerm} -- a simple terminal emulator with colour graphics
capabilities written in Python (see the \textbf{GTerm} project repository for more information). \textbf{GPLOT} also 
supports Tektronix 401x terminals (which \texttt{xterm} emulates, although Ren\'{e} Richarz's
excellent 4014 emulator is preferred: \url{https://github.com/rricharz/Tek4010}).
\newpara
Output in the form of graphics files which  can be included in other documents is available in two formats:
Encapsulated PostScript files and SVG files. The latter is 
used by the \textbf{PMDHTML} Markdown to HTML program and the \textbf{PLNOTES} short document maintenance scheme for NOS
(which is not described further here) as well as for HTML documents in general. The former is useful for \LaTeX and other
``print'' style document systems.
\newpara
A major goal for \textbf{GPLOT} is that it should be \textit{very easy to use} --- as easy as other graph plotting
programs on modern operating systems (such an \textbf{Gnuplot}, matplotlib, etc.) --- although \textbf{GPLOT} is not
directly comparable to those programs. In some aspects, it does much less than they do, but it also does
things they do not do.
\newpara
To build and install \textbf{GPLOT} on an emulated CYBER mainframe (with DtCyber), or on a ``Unix-like'' system or
other supported system,
please refer to the main \textbf{GPLOT} Github project \texttt{README.md}. This describes the build procedures in
a step-by-step fashion and also explains how a single source code base can be used fairly easily on both NOS and
``Unix-like'' and other systems.
\newpara
\textbf{GPLOT} (with \textbf{DIMFILM}) is almost entirely self-contained -- it has no dependencies beyond the operating
system and language runtime libraries. By modern standards, it is very light weight -- the entire source of
GPLOT, DIMFILM, output device code and utility functions is less than 40,000 lines, including comments. It should be possible to
port it to other systems with working Fortran-77 compilers and runtimes, provided they do not insist on six character
variable and function names (although it would not be very hard to work around that with a simple Python program
to transform the source code). Many historic systems, as well as almost all modern systems, should be able to
build and run it. That said, it will almost certainly not run on systems as small as PDP-11s.

\subsection{About this document}
This description of GPLOT is in three parts.

\begin{itemize}
\item \textbf{Part I} is a ``traditional manual'' for \textbf{GPLOT} that describes each of its commands in detail, but doesn't help
  you decide which of them to use for a specific task.
\item \textbf{Part II} is a tutorial (of sorts) that goes through various tasks that \textbf{GPLOT} can help with from plotting
  simple graphs to creating quite complicated diagrams.
\item \textbf{Part III} is a collection of information of various kinds on various topics that fill in details (e.g.
  complete font tables) or describes tools that can be used with \textbf{GPLOT}.
\end{itemize}

\clearpage
\part{\textbf{GPLOT} Manual}
\clearpage

\section{Running \textbf{GPLOT}}
\textbf{GPLOT} needs two files: \texttt{GPLOT} (the pre-loaded binary executable) 
and \texttt{DADIMFO} (which contains
the font data for \textbf{DIMFILM}). To run \textbf{GPLOT} on NOS, use:
\begin{verbatim}
/ATTACH,GPLOT.
/GPLOT.
\end{verbatim}
\texttt{GPLOT} will \texttt{ATTACH} the font file (\texttt{DADIMFO}) itself.
On NOS, options supplied on the ``command line'' should be comma separated, following
the usual rules for CCL (Cyber Control Language). Note that arguments containing spaces
need to be ``quoted'' by enclosing them in dollar signs (as per normal CCL practice).

\newpara
To run \textbf{GPLOT} on a ``Unix-like'' (or VAX/VMS) system, use:
\begin{verbatim}
$ gplot
\end{verbatim}
On these systems, options should be space separated and arguments containing spaces
should be enclosed in double quotation marks -- the usual rules for the shell being
used should be followed. Note, though, that the \texttt{keyword=value} format is used, as
it is on NOS.

\newpara
Running \textbf{GPLOT} on a VAX/VMS system requires that a logical name be defined (to find
the font definition file) and \textbf{GPLOT} should be defined as a ``foreign command'' so that
parsing command line arguments works as intended. To do that, the following should be added
to a login command procedure:
\begin{verbatim}
define DIMFONTS_LOGICAL DISK$USER:[<user>.GPLOT.GPLOT-SOURCE]DADIMFO.DAT
gplot :== "run DISK$USER:[<user>.GPLOT.GPLOT-SOURCE]gplot.exe"
\end{verbatim}

\newpara
Running \textbf{GPLOT} on NOS/VE (which should be considered ``experimental'' and subject
to change) can be done using
\begin{verbatim}
gplot.gplot
\end{verbatim}
or by adding GPLOT (which is a library as well as an ``executable'' -- which is really a ``program description''
entry in the GPLOT library) to the command list using:
\begin{verbatim}
create_command_list_entry gplot
\end{verbatim}
after which
\begin{verbatim}
/ gplot
\end{verbatim}
will work.

\newpara
The following options are recognized.
\begin{itemize}
\item \textttc{OBEY=FILE}\\
   \textbf{GPLOT} will read commands from the specified \texttt{LOCAL} file with name \texttt{FILE}. 
   The program exits when the file has been read.
\item \textttc{PARM=STRING}\\
   Used with \texttt{OBEY=FILE}. \texttt{STRING} is passed as one or more parameters to the \texttt{OBEY} file.
    See \ref{obfile} for more details.
   Under NOS, if \texttt{STRING} needs to contain spaces (i.e. there is more than one parameter), it should be enclosed in
   \$ (or \texttt{``}) signs. If any single parameter in \texttt{STRING} itself needs to contain spaces,
   that parameter should be enclosed in
   single quotes.
\item \textttc{GET=YN}\\
   Turn on automatic \texttt{GET}s of indirect \texttt{PERMANENT} files before \texttt{READ} and \texttt{OBEY} 
   try to access the files they need. \texttt{YN} is
   \texttt{YES} or \texttt{NO} (or an abbreviation down to \texttt{Y} or \texttt{N}). 
   This saves having to issue \texttt{GET} in \textbf{GPLOT} (or NOS before \textbf{GPLOT} is
   run) in order to make the files to be used \texttt{LOCAL}. On the other hand, if changes have been made to a \texttt{LOCAL} version
   of a \texttt{PERMANENT} file, these will be lost when \textbf{GPLOT} \texttt{READs} or \texttt{OBEYs} 
   that file with `auto \texttt{GET}' in effect. So be 
   careful! This option is only relevant on NOS systems.
 \item \textttc{SAVE=YN}\\
   Turn on automatic \texttt{SAVE} or \texttt{REPLACE} of graphics output files as indirect \texttt{PERMANENT} files.
   This option is only relevant on NOS systems.
\item \textttc{DEBUG=YN}\\
   Outputs debugging information (mostly to do with \texttt{OBEY} file arguments and parameter substitutions currently).
\item \textttc{QUIET=YN}\\
   Displays the unabbreviated command and \texttt{OBEY} nesting level for every command executed. Note that this may
   upset some output devices (especially the Tektronix 401x).
\item \textttc{SLIDE=YN}\\
	Tell \textbf{DIMFILM} to use a graph plotting layout suitable for slides. This is the default, as it seems better suited to most
	output devices. The alternative tends to have text and other features that look too small on the page or display. Some
	people might like that, though. 
\end{itemize}
An example of a \textbf{GPLOT} control statement is:
\begin{verbatim}
GPLOT,OBEY=DOPLOT,PARM=$X Y 'A TITLE'$.
\end{verbatim}

\newpara
On a ``Unix-like'' system (and VMS and NOS/VE), this would be:
\begin{verbatim}
gplot obey=doplot parm="x y 'a title'"
\end{verbatim}

\section{Commands}
All commands can be abbreviated so long as they uniquely identify a command.
(If the abbreviation is ambiguous, you will get a warning message and no command will
be executed). 
\newpara
All commands are shown in \texttt{UPPER CASE}, as that is the primary (\texttt{NORMAL}) character mode
for NOS. In \texttt{NORMAL} mode, lower case is equivalent to upper case, so lower case can be used
if desired. 

\begin{quote}
\begin{center}
\textbf{Warning}\\
\end{center}
\textbf{GPLOT} should
\textit{not} be used in \texttt{ASCII} mode on NOS (in which lower case characters are \textit{really} lower case),
otherwise command names will not be recognised, amongst other problems.
This does not mean that lower case text cannot be plotted, though -- it can.

\newpara
On ``Unix-like'' systems, lower case input can be used freely. Command names are converted to upper case internally.
Strings preserve the case as entered. Also, EPS and SVG output files are given their usual extensions
(extensions are alien to NOS and COS).

\newpara
In order to simplify usage on ``Unix-like'' systems, \textbf{GPLOT} converts all file names to lower case on those
systems. This may (rarely) be undesirable, but is thought to be helpful in general.
\end{quote}

\newpara
If a line starts with a hash character (\texttt{\#}) or the two characters ``\texttt{C }'' (upper case C only), the entire line
will be treated as a comment. Anything after a semi-colon (\texttt{;}) is treated as an inline comment, unless the semi-colon is in
a double quoted string.

\newpara
Commands are divided in to related groups below, but that is only for 
convenience in describing them.

\subsection{Basic Graphics Commands}
These are the lowest level facilities on which graph plotting is built.
\begin{itemize}
\item \textttc{DEVICE NAME [OUTPUT-FILE [SIZES]]} --- Select the output device.\\
   The EPS and SVG devices need an output file name to write to. Note that this
   will be created as a \texttt{LOCAL} file and will need to be made permanent with
   \texttt{SAVE} or \texttt{REPLACE} on NOS unless the \texttt{SAVE=YES} option has been used.
   For the EPS and SVG devices, an additional SIZES specification may be
   given. See Section \ref{devinfolabel} for the available devices and their
   characteristics.
\item \textttc{CLEAR [NAME]} --- Clear the drawing area.\\
  The device display will be set to its default background colour (white, except on
  the Tektronix 401x, which is black).
   Any previously drawn material will be erased. If
   \texttt{EPSCOL} or \texttt{SVG} devices are being used, the \texttt{NAME}
   argument can be used to set the name to be used by the \emph{next} output file(s).
   Note that the name given must be 4 or fewer characters on NOS, or 72 characters
   on ``Unix-like'' systems. See \ref{devinfolabel} for more information. Using
   \texttt{CLEAR} with a file name before outputting anything is a good way to create a
   specifically named output file. The file named in the \texttt{DEVICE} command will
   simply be deleted if it is found to be empty when the \texttt{CLEAR} command is encountered.
\item \textttc{BOUNDS XL XH YL YH} --- Set the plotting bounds.\\
   This establishes a user coordinate system with $x_l,y_l$ at the bottom left
   and $x_h,y_h$ at the top right. The \texttt{MOVE}, \texttt{DRAW}, 
   \texttt{PANE} and \texttt{BLANK} commands use this
   coordinate system.
\item \textttc{PANE XL XH YL YH} --- Set the \texttt{PANE} (clipping area).\\
   All drawing with \texttt{MOVE}, \texttt{DRAW} and \texttt{TEXT} will be clipped to the area specified
   here. In contrast, all graph plotting commands will apply inside this area,
   so that graphs will be scaled to fit this region. This is a way to plot
   multiple graphs side by side.
\item \textttc{UNPANE} --- Stop using any pane.\\ 
  The full drawing area will be used after this.
\item \textttc{CANVAS XL XH YL YH} --- A convenience function that sets \texttt{BOUNDS}
  and \texttt{PANE} (to the same extents) in one command.
 \item \textttc{OUTLINE object} --- Outline an area.\\
   The area is determined by \texttt{object}, which may be: \texttt{PANE}, \texttt{BLANK},
   \texttt{BOUNDS} or \texttt{DEVICE}.
\item \textttc{BLANK XL XH YL YH} --- Set the blank area.\\
   No drawing with either the basic graphics or graph plotting routines will
   make a mark inside the specified area. This can be useful for reserving a
   space for a graph key, for example.
\item \textttc{UNBLANK} --- Stop using any blank area.\\
   The previous blank area is no longer protected after this.
\item \textttc{COLOUR R G B} --- Set the RGB colour to use for drawing.\\
   \textbf{DIMFILM} maintains a separate drawing colour and line width for three
   different classes of graphical objects: lines, including those on graph plots;
   text (character strings); and graph plot annotations. This \texttt{COLOUR}
   command will be applied to the colour/style group last selected with
   a \texttt{CSGROUP} command (all 3 groups being the default if \texttt{CSGROUP} hasn't
   been used).
\item \textttc{WIDTH WIDTH} --- Set the line width.\\
   The width is a multiple of a device dependent "base width" and not all devices
   can draw wide lines (currently, only the Tektronix device cannot). This \texttt{WIDTH} will
   apply to the currently selected colour/style group as explained for \texttt{COLOUR}.
\item \textttc{CSGROUP GROUPNAME} --- Set the current colour/style group.\\
	This chooses which class of graphical objects any subsequent \texttt{COLOUR} and \texttt{WIDTH}
	commands apply to. The \texttt{GROUPNAME} values are: 
	\begin{itemize}
	\item \textttc{ALL} -- Apply COLOUR and WIDTH to all three colour/style groups.
	\item \textttc{GENERAL} -- Apply them to line drawing operations.
	\item \textttc{TEXT} -- Apply them to text drawing operations.
	\item \textttc{ANNOT} -- Apply them to graph plot annotation operations.
	\end{itemize}
	As usual, these group names can be abbreviated, providing the abbreviation
	remains unique.
\item \textttc{STYLE STYLENAME} --- Set the line style.\\
   The following styles are defined: \texttt{SOLID}, \texttt{DASH},
   \texttt{DOT}, \texttt{DASHDOT}. These are
   probably self explanatory! Note that this is not constrained to the current
   colour/style group.
\item \textttc{MOVE X Y} --- Move to position.\\
   The virtual pen is moved to $(x,y)$ in \texttt{BOUNDS} coordinates.
\item \textttc{DRAW X Y} --- Draw to position.\\
   The virtual pen is lowered and moved to $(x,y)$ in \texttt{BOUNDS} coordinates.
\item \textttc{TEXT "TEXT"} --- Draw text.\\
   The string \texttt{TEXT} is drawn at the current pen position. The string may be enclosed
   in double quotation marks to allow spaces in the string. The text will be drawn
   with the current font, which defaults to \texttt{SANS.SIMPLEX}. The string may contain many special
   formatting sequences. The most frequently useful are \texttt{*L} to switch to lower case
   and \texttt{*U} to switch back to upper. The full set of format controls are described in
   the \textbf{DIMFILM} manual, and a summary of most of them is given in Table~\ref{tab:textformats}.
   On systems other than NOS, lower case letters will be preserved.
\item \textttc{FILL} --- Fill the drawing area with the current colour.\\
   This erases all drawn graphics, of course. It differs from
   \texttt{CLEAR} in that \texttt{CLEAR} always fills with a fixed
   device dependent colour and empties any buffered graphics commands
   in the device (if any). \texttt{FILL} is only useful after a \texttt{CLEAR} and
   only on \textbf{GTerm}.
\end{itemize}

\begin{table}
\begin{footnotesize}
\centering
\begin{tabular}{|| l | l ||}
\hline
Sequence & Purpose \\
\hline
\texttt{*U} & Start upper case. This is the default state and \texttt{\$U} is not useful.\\
\texttt{*L  \ldots \$L} & Start and end lower case.\\
\texttt{*B} & Backspace over last character.\\
\texttt{*1} or \texttt{*2} or \texttt{*3} & Select a font set.\\
\texttt{*+  \ldots \$+ } & Start and end super-script. Maximum of 2 levels.\\
\texttt{*- \ldots \$-} & Start and end sub-script. Maximum of 2 levels.\\
\texttt{*= \ldots \$=} & Start and end underlining.\\
\texttt{*N} & Reset sub- or super- script level to zero.\\
\texttt{*O }\ldots \$O & Make sub- or super- scripts fully below or above previous character (for summations).\\
\texttt{*,} numerator \texttt{\$,} denominator \texttt{\$.} & Construct a fraction.\\
\texttt{*:nn} & Output current symbol font character with code number \texttt{nn} (00 to 96).\\
\texttt{*::nn} & Output current marker font character with code number \texttt{nn} (00 to 96).\\
\texttt{*Vnn }& Output current font set alphabetic character with code number \texttt{nn} (00 to 96).\\
\hline
\end{tabular}
\caption{Special text formatting character sequences}
\label{tab:textformats}
\end{footnotesize}
\end{table}

\subsection{Further Drawing Commands}
These add a small number of primitive shapes as well as more control over how text is drawn.
There is also a command that draws an arbitrary polyline.

\begin{itemize}
\item \textttc{CIRCLE X Y R} -- Draw a circle.\\
  Centre at $(x,y)$ with radius $r$.
\item \textttc{ARC X Y R A1 A2} -- Draw an arc of a circle.\\
  Centre at $(x,y)$ and with radius $r$, starting at angle
  $a_1$ and ending at angle $a_2$. The angles are measured in degrees counter-clockwise from the positive X axis.
\item \textttc{RECT X Y W H} -- Draw a rectangle.\\
  With bottom left at $(x,y)$, width $w$, height $h$.
\item \textttc{CRECT X Y W H} -- Draw a rectangle.\\
  Centred on  $(x,y)$, width $w$, height $h$.
\item \textttc{FONT FONTNAME} -- Set the current font.\\
  The \texttt{FONTNAME} must be one of the alphabetic fonts listed by \texttt{LISTFONT}.
\item \textttc{SYMHT H} -- Set the height characters, symbols and markers.\\
  The height is given in user bounds units.
\item \textttc{SYMANG A} -- Set the angle at which text is drawn.\\
  The angle is in degrees measured counter-clockwise from the positive X axis.
\item \textttc{CTEXT W "TEXT"} -- Draw text centred at the current position.\\
  The text is scaled so its width is $w$ in user bounds units. If $w$ is 0, the text isn't scaled.
  Instead, it is drawn at the size set with \texttt{SYMHT}.
\item \textttc{MARKER NUMBER YES} -- Draw marker \texttt{NUMBER} at the current position.
\item \textttc{PATH TYPE} --- Use the contents of the \texttt{X,Y} arrays (e.g. as set by \texttt{READ} or the
  evaluator (see below) as the vertices of a polyline. If \texttt{TYPE} is \texttt{C} (closed), join the
  last coordinate pair to the first. If \texttt{TYPE} is \texttt{O} (open) do not do that.
\item \textttc{CURVE TYPE} --- Use the contents of the \texttt{X,Y} arrays (e.g. as set by \texttt{READ} or the
  evaluator (see below) as points through which a smooth curve must pass. If \texttt{TYPE} is \texttt{C} (closed), join the
  last coordinate pair to the first. If \texttt{TYPE} is \texttt{O} (open) do not do that. The curve is calculated
  so that its first and second derivatives are continuous.
\item \textttc{BEZIER TYPE} --- Use the contents of the \texttt{X,Y} arrays (e.g. as set by \texttt{READ} or the
  evaluator (see below) as the vertices of a cubic B\'{e}zier control polygon.
  If \texttt{TYPE} is \texttt{C} (closed), join the last coordinate pair to the first. If \texttt{TYPE} is
  \texttt{O} (open) do not do that. Note that there are rules about the number of points that must be
  supplied for the control polygon to be valid. Specifically, for an open curve, the number of
  control points, $N$, must conform to $((N-1) \mod 3) = 0$, and for a closed curve: $(N \mod 3) = 0$.
\end{itemize}

\subsection{Graph Axis Commands}
Before plotting a graph, \textbf{GPLOT} needs to know the range and type of the axes on which
to plot the graph. The default settings of \texttt{XYAUTO}, \texttt{XLINEAR} 
and \texttt{YLINEAR} mean that \textit{none}
of the commands below \textit{need} to be used before plotting, but you may want to use them. 
\begin{itemize}
\item \textttc{XYAUTO} --- Find both axis ranges automatically.\\
   \textbf{DIMFILM} will examine the range of the data in use when an \texttt{XYPOINT}, 
   \texttt{XYLINE} or \texttt{XYHISTOGRAM}
   command occurs and will set the axis ranges to match. Linear axes will be used.
\item \textttc{XYSAME} --- Keep the previous axis ranges.\\
   If a graph was plotted with \texttt{XYAUTO} on, and other graphs need to be plotted on the same
   axes, use \texttt{XYSAME} after the first graph has been drawn. 
\item \textttc{XRANGE XLO YHI} --- Set the X axis range.\\
   The X axis will run from \texttt{XLO} to \texttt{XHI}.
\item \textttc{YRANGE YLO YHI} --- Set the Y axis range.\\
   The Y axis will run from \texttt{YLO} to \texttt{YHI}.
\item \textttc{XLINEAR} --- Use a linear X axis.\\
   This is the default.
\item \textttc{YLINEAR} --- Use a linear Y axis.\\
   This is the default.
\item \textttc{XLOG} --- Use a logarithmic X axis.
\item \textttc{YLOG} --- Use a logarithmic Y axis.
\item \textttc{INTVALUES Which} --- Try to use integer values for an axis/axes.\\
  \texttt{Which} may be: \texttt{NONE}, \texttt{X}, \texttt{Y}, or \texttt{BOTH}.
  It is not always possible to do this, because of the range of the axis values. If
  it is not possible, floating point values will be used with no error message given.
\end{itemize}

\subsection{Graph Plotting Commands}
These are the commands that get the data to be graphed and actually draw graphs. Before data
can be plotted, it must be \texttt{READ}, so the graph drawing commands 
(\texttt{XYPOINT}, \texttt{XYLINE} and \texttt{XYHISTOGRAM})
will not work until a \texttt{READ} has got some data. The graphs that can be drawn depend on what
data is \texttt{READ} --- this can be two real numbers per point (for $(x,y)$), three -- which adds 
information for a symmetric Y error bar, or four -- which adds data needed for asymmetric Y
error bars, or symmetric Y and X error bars. The graph drawing commands will always use all
the data available, so if \texttt{READ} has got data for $(x,y)$ and a symmetric Y error bar, for example,
that is what \texttt{XYPOINT} and \texttt{XYLINE} will draw. To stop drawing unwanted items, simply re-read the
data omitting the undesired items.
\begin{itemize}
\item \textttc{MAXPOINTS NUMBER} -- Set maximum number of data points.\\ 
   Memory for data to be plotted is allocated dynamically (this could be
   done in most major Fortran implementations, even though it is completely non-standard
   in Fortran-77 and earlier --- there is much, possibly deliberate, ignorance on the part
   of academics of what could actually be done in this language). Four real numbers are allocated
   for each point --- two for an $(x,y)$ coordinate and two for error bar data. On starting,
   \textbf{GPLOT} allocates space for 1000 points. This can be changed at any time (although any data
   \texttt{READ} will be thrown away if it is changed, of course). The number of data points is limited
   by the amount of central memory on the machine, and how much of that you are allowed to use by
   your account settings. Under emulation, there is no reason not to use the maximum
   available --- 262,144 words of which 131,072 can be used by any one job (minus a bit, of
   course!). \textbf{GPLOT} is, unfortunately, not small ... and will grow as more facilities are
   added. At present, the maximum number of points allowed is set to 10000 and this is close to the
   maximum possible. The limit of addressable central memory is the main limitation on what
   can actually be done under NOS. Although extended memory and `out-of-core' solutions (where
   most of the data resides on disk) may be possible in some cases, that isn't always so (e.g.
   \textbf{DIMFILM} needs the data it plots to be in central memory), and these methods always come
   with a significant performance and complexity cost.
   \begin{quote}
     \begin{center}
       \textbf{Note}\\
       On ``Unix-like'' systems, this command has no effect. The default value is always used
       regardless of what may be specified here.
     \end{center}
   \end{quote}
\item \textttc{READ NAME XCOL YCOL [YECOL [XECOL]]} --- Read a data file using the specified `columns'.\\
   The file \texttt{NAME} (which must be a \texttt{LOCAL} file -- possibly obtained inside \textbf{GPLOT} using
   the \texttt{GET} command) should contain numbers (in the standard character code), with at least one per line,
   separated by spaces or commas. There may be any number of spaces preceding or separating each number
   (subject to line length limitations -- the limit is 80). Blank lines are skipped and ignored.
   Lines with the character \texttt{`C'} in column 1 are ignored (allowing comments). 
   The \texttt{numbers} may be integers
   or any real number format (exponential or not), optionally preceded by a \texttt{+} or \texttt{-} sign. 
   \texttt{READ} will
   try to interpret anything that \textit{could} be a number \textit{as} a number. It will stop reading a data item
   when a non-numeric character is found --- but this is not treated as an error.\\
   Each space (or single
   comma) separated number on a line is termed a `column', and these are numbered starting at 1. So column
   2 is the second number on each line. Column numbers must be specified for \texttt{XCOL} and \texttt{YCOL} data to
   obtain at least an $(x,y)$ coordinate for each point. As a special case, \texttt{XCOL} may be 0, in which case,
   the X coordinate is set to the point number (starting at 1). This allows a data file with a single
   data item per line to be processed.\\
   If a column number is supplied for \texttt{YECOL},
   then that column's values will be used for symmetric Y error bars. If a column number is also specified
   for \texttt{XECOL}, then that data will be used as either a symmetric X error bar or as the upper part of an asymmetric
   Y error bar, depending on the setting made with the \texttt{ASYMYERRORBARS} command. The default is to interpret 
   \texttt{YECOL} and \texttt{XECOL} as the lower and upper extents of asymmetric Y error bars, as this may be more frequently
   useful, There is currently no way to draw asymmetric X error bars.\\
   If \texttt{NAME} is \texttt{HERE} (i.e. the string \texttt{HERE}), 
   then no data file is opened. Instead, \texttt{READ} tries to read data from
   the command input stream itself (\texttt{INPUT} or an \texttt{OBEY} file -- see below). 
   \texttt{READ} will stop reading data items
   when it finds a line that contains the string \texttt{EOF} as its only item. This facility is mostly to allow
   other programs to write a self contained \texttt{OBEY} file that executes a complete plotting task then exits \textbf{GPLOT}.
   A major anticipated application of this is plotting data from APL.
\item \textttc{MARKER NUMBER} --- Set the marker number to be used for points.\\
   This is a character number in \texttt{Font 9001}. Characters are associated
   with numbers 2 to 25, but with 5 and 11 omitted. Numbers 2, 3, 4, 8, 9, 19 and 20 are perhaps the most useful.
   Something may need to be done to improve this font or at least supply descriptive names for the markers!
\item \textttc{XYPOINT} --- Draw an XY graph with points.\\
   The points will be drawn with the last marker set with a \texttt{MARKER}
   command, or 3 (the default) if no \texttt{MARKER} command is used. 
   Depending on the data items \texttt{READ} and the \texttt{ASYMYERRORBARS}
   setting, symmetric Y, asymmetric Y or symmetric Y and X error bars will also be drawn.
\item \textttc{XYLINE} --- Draw an XY graph with lines.\\
   By default, data points will be joined with straight lines (linear
   interpolation -- of a kind) and in \texttt{SOLID} line style. The line style can be changed with the \texttt{STYLE} command.
   Cubic or quintic interpolation can be used between the data points to get smooth curves instead of straight lines.
   At least 3 points are required for cubic and 5 for quintic interpolation. If there are insufficient points, linear
   interpolation is used as a fall-back. The interpolation is as supplied by \textbf{DIMFILM} --- as always, whether it is appropriate
   depends on the data and its desired interpretation. I'm not certain exactly how \textbf{DIMFILM} comes up with the interpolation,
   although it is visually fine.
\item \textttc{XYHISTOGRAM} --- Draw an XY histogram.\\
   Bars (of a type determined by \texttt{HISTSTYLE} --- default: \texttt{ABUT}) 
   are drawn centered on the X coordinate and extending vertically
   from the $X=0$ axis to the Y coordinate. Error bar data (if any) is ignored.
\item \textttc{HISTSTYLE STYLENAME [WIDTH]} --- Sets the histogram bar style.\\
   \texttt{STYLENAME} is one of the following:
   \begin{itemize}
   \item \textttc{ABUT} --- Open rectangular bars are drawn, centred on an X coordinate, and with a width determined by the X location
   of the preceding point (apart from the first point, which uses the location of the second point), so that the bars touch one
   another along the X direction.
   \item \textttc{ABUT+SHADE} --- as \texttt{ABUT}, but the bars are filled with `shading' ---
   lines at 45 degrees spaced 0.02 of the X \texttt{BOUNDS} range
   apart.
   \item \textttc{LINES} --- Zero width lines are used for the bars.
   \item \textttc{WIDE} --- Bars of the specified \texttt{WIDTH} (in X axis units) are drawn without shading.
   \item \textttc{WIDE+SHADE} --- As \texttt{WIDE}, but with shading.
   \end{itemize}
\item \textttc{INTERPOLATE STYLE [N]} --- Set the interpolation mode for \texttt{XYLINE}.\\
   \texttt{STYLE} may be: \texttt{LINEAR}, \texttt{CUBIC} or \texttt{QUINTIC} --- which are hopefully self explanatory!
   As explained in \texttt{XYLINE}, either straight lines or smooth curves can join the points. 
   If \texttt{CUBIC} or \texttt{QUINTIC} is used, the
   number of intermediate (linear) segments drawn for the curve between each point is controlled by \texttt{N} (default: 10).
\item \textttc{ASYMYERRORS MODE} --- Use asymmetric Y error bars if \texttt{MODE} is \texttt{ON}.\\
   If \texttt{OFF}, symmetric Y and X error bars are drawn. Error bars will only be drawn if error bar
   data has been \texttt{READ}, and both \texttt{YECOL} and \texttt{XECOL} must have been 
   specified to get asymmetric Y error bars or
   symmetric Y and X error bars.
 \item \textttc{USEKEY} --- Prepare to create a key for a graph.\\
   A separate panel will be created to the right of the graph plotting area containing a key or legend
   to identify lines or sets of points on a graph.
 \item \textttc{ADDKEY} --- Add a key entry for the data plotted by the previous \texttt{XYLINE} or \texttt{XYPOINT} command.
 \item \textttc{KEYS} --- Create the accumulated key and draw it.
 \item \textttc{GRAPHMODE STATE} --- Automatically set bounds so that graphs occupy as much area on a device as possible.\\
   \texttt{STATE} must be either \texttt{ON} or \texttt{OFF}. The bounds default to 0 to 1 on both axes. All graph plotting takes place within the
   current pane, which is identical to the bounds unless specifically set. However, the bounds area will be centered in the
   output device drawable area in order to keep a unit step on both axes the same (so circles are circles and not ellipses
   when drawn). To fully use the device drawable area, the bounds must have the same aspect ratio as the device.
   GRAPHMODE ON arranges for this to happen internally.
 \item \textttc{SUBFIGGRID NX NY IX IY [SHRINK]} --- Set up to draw a graph as part of a rectangular array of sub-figures.\\
   This allows a pane to be automatically set up so that the next graph is plotted as one of an array
   of \texttt{NX} by \texttt{NY} graphs at
   the \texttt{IX,IY} coordinate of that grid. As always in \textbf{GPLOT},
   grid coordinates start at 1 and range up to \texttt{NX} or \texttt{NY} inclusive.
   The optional \texttt{SHRINK} argument is a floating
   point number less than 1 which shrinks the pane about its center to control the separation of the graphs.
 \item \textttc{GRMOVE X Y} --- Move the ``pen'' to graph coordinates $(x,y)$, setting the ``current position''.
 \item \textttc{GRDRAW X Y} --- Draw from the current position to $(x,y)$, adjusting the ``current position''.
\end{itemize}


\subsection{Graph Annotation Commands}
Graphs almost always need some annotation. Minimal annotation is: ticks on the axes, numeric values
against those ticks, and a framing rectangle drawn around the graph plotting area. These are always
drawn after each graph drawing command (\texttt{XYPOINT}, \texttt{XYLINE}, \texttt{XYHISTOGRAM}) 
unless \texttt{ANNOTATE OFF} is used.
\texttt{TITLE}, \texttt{XLABEL}, \texttt{YLABEL} and \texttt{GRID} annotation elements are only 
drawn if these are explicitly specified.
\begin{itemize}
\item \textttc{ANNOTATE ON} or \texttt{OFF} --- Turn annotation on or off.\\
   Typically, annotation is wanted whenever a single graph is drawn. However, after drawing one curve
   (etc.) with annotation, it might be desirable to turn off annotation when drawing the other curves
   on the same axes. It is certainly more efficient to do so, and some devices with some line width settings
   may show visible changes when items are drawn over existing identical elements (for whatever reason).
\item \textttc{TITLE "TEXT"} --- Set the title.\\
   This is drawn at the top of the graph, centred on the width of the graph drawing area.
   \texttt{TEXT} may be enclosed in double quotes to allow spaces and format commands 
   (such as \texttt{*L} and \texttt{*U}) are
   understood.
\item \textttc{XLABEL "TEXT"} --- Set the X axis label.\\
   This is plotted below the X axis (at the bottom of the graph drawing area.
\item \textttc{YLABEL "TEXT"} --- Set the Y axis label.\\
   This is plotted (vertically) to the left of the Y axis.
\item \textttc{GRID Style} --- Draw a grid with lines at the major axis ticks for one or both axes.\\
   Style may be: \texttt{NONE}, \texttt{X}, \texttt{Y}, or \texttt{BOTH}, which are hopefully self explanatory.
   Note that the grid will only be drawn if \textttc{ANNOTATE ON} is in effect (it will not be  drawn if
   \textttc{RIGHTANNOT ON} is in effect).
\item \textttc{GSTYLE Mode} --- Choose the overall graph drawing style.  \\
	Mode may be:
	\texttt{BOXED}, \texttt{AXES} or \texttt{OPEN}. The default is \texttt{BOXED}, with axis annotations along the
	edges of a boxed region. The \texttt{OPEN} option disposes of the right and top edges.
	\texttt{AXES} draws only axis lines that pass through a point which can be specified but defaults to $(0,0)$. This
	gives a dramatically different appearance. Note that the point the axes pass through must be in the range of
	graph values to be drawn, otherwise one or both of the axes will be omitted..
\item \textttc{AXCUT X Y} --- Set the coordinates through which axis lines will pass. \\
	If using \texttt{GSTYLE AXES} this must
	be used to position the axes in the coordinate ranges being used, otherwise no annotation will appear.
\item \textttc{RIGHTANNOT ON} or \texttt{OFF} --- Selects annotation of the right hand edge for \texttt{GSTYLE BOXED}. \\
	This will
	only be drawn if \texttt{ANNOTATE OFF} has been previously used to stop left edge annotation. Using this with changes to 
	\texttt{YRANGE} allows data with different Y value ranges to be drawn on the same plot.
\item \textttc{ RYLABEL "TEXT"} --- Sets the right hand edge label.\\
	This is useful if \texttt{RIGHTANNOT ON} is used.
\end{itemize}

\newpara      
See also \texttt{GLABEL} in Section~\ref{labels-sect}.

\subsection{\textbf{GPLOT} System Commands}
These commands don't draw anything, but they show the state of \textbf{GPLOT}, interact usefully with NOS, and allow
something like plotting macros (with parameters) to be used.
\begin{itemize}
\item \textttc{OBEY NAME [PARAMETERS]} --- Start reading commands from file \texttt{NAME}.\label{obfile}\\
   The file may contain any \textbf{GPLOT} command (one per line), including \texttt{OBEY}. \texttt{OBEY} files may be
   nested up to 5 deep (this could be increased, but 5 seems likely to be enough). If \texttt{PARAMETERS}
   is specified, it should be a single string without spaces or a string enclosed in double quotation
   marks. Each space separated word in the \texttt{PARAMETERS} string defines a single parameter, which are
   given numbers based on position starting at 1 on the left. Up to 9 parameters can usefully be set up
   in the \texttt{PARAMETERS} string. When reading commands from an \texttt{OBEY} file, \textbf{GPLOT} will apply a simple
   parameter substitution process: each space separated word of the form: \texttt{\$N}, where \texttt{N} 
   is \texttt{1} to \texttt{9}, will
   be replaced by the \texttt{N}th word of the \texttt{PARAMETER} string. It is possible to pass parameters containing spaces
   by enclosing them in single quotes in the \texttt{PARAMETER} string. For example:
   \begin{verbatim}
   OBEY FRED "FIRST 'SECONDA SECONDB'"
   \end{verbatim}
   defines two actual parameters that will be substituted for the formal parameters \texttt{\$1} and \texttt{\$2} wherever
   these occur as space separated words in the file \texttt{FRED}. \texttt{\$2} will, in fact, be substituted as:
   \begin{verbatim}
   "SECONDA SECONDB"
   \end{verbatim}
   in order to preserve the embedded space(s). This is useful for passing \texttt{TITLE} strings to \texttt{OBEY} files,
   for example.
 \item \textttc{HELP [TOPIC]} --- Output help information, including the supported output devices.\\
   \texttt{HELP} alone outputs a list of \textbf{GPLOT} commands, alphabetically sorted. If \texttt{TOPIC} is the name
   of a command, detailed information on that command is displayed. \texttt{HELP HELP} briefly described the \texttt{HELP} command
   itself. If \texttt{TOPIC} is \texttt{DEVICES}, information on the available output devices is displayed.
\item \textttc{STATUS} --- Displays various \textbf{GPLOT} state information.\\
   This includes the number of points available, whether anything has been read, the \texttt{BOUNDS}, whether
   any \texttt{PANE} or \texttt{BLANK} is in effect, etc.
\item \textttc{LOGFILE NAME} --- Opens a command log file called \texttt{NAME}.\\
   This is a \texttt{LOCAL} file on NOS to which any interactive input from you, the user, is written. Commands executed
   from any \texttt{OBEY} files are not logged. This lets you log a session and repeat it (perhaps after editing)
   by executing the log file as an \texttt{OBEY} file. You will need to \texttt{SAVE} or \texttt{REPLACE} the file to make it
   \texttt{PERMANENT} if you want to keep it between jobs. When \texttt{LOGFILE} is executed, any previously open log file
   is closed and a new one is opened. If the new one has a different name from the old, the old one will
   not be destroyed.
\item \textttc{MEMTEST} --- Test dynamic memory is working.\\
   Which it will be! More usefully, it also generates test data in the form of a sine wave, which can then
   be plotted to evaluate how well an output device is working, or to get familiar with \textbf{GPLOT}.
\item \textttc{GET NAME} --- Get an indirect access \texttt{PERMANENT} file.\\
   This is useful to avoid having to exit \textbf{GPLOT} to make some data file \texttt{LOCAL} so it can be \texttt{READ}.
   There is no command as yet to \texttt{ATTACH} a direct access \texttt{PERMANENT} file, although it would be easy
   to add one.
\item \textttc{LISTFONT} --- Lists the available fonts.\\
	The names of all available fonts are shown, along with the type of font: \texttt{ALPHABETIC}, \texttt{SYMBOL} or 
	\texttt{MARKER}.
\item \textttc{VERSION [N]} --- Print (if \texttt{N} is omitted) the current version of \textbf{GPLOT}.
        If \texttt{N} is supplied, it should be the
        number of the string register (1 to 9) in to which to put version information.
\item \textttc{WAIT} --- Wait for input from the user if the device is interactive (\textbf{GTerm} or Tektronix 401x).
  The user should respond with \texttt{Y (enter)} or just \texttt{(enter)} to continue.
  If \texttt{N (enter)} is used, the request
  for a response will be repeated. If \texttt{Q (enter)} is used, \textbf{GPLOT} will perform
  an \texttt{EXIT} command and terminate. Note that the response is case sensitive and upper case must be used here.
\item \textttc{RESET} --- Reset most of \textbf{GPLOT} state to the default values. This does not include any data that has been
  \texttt{READ} or the selected device.
\item \textttc{PREFIX PATH} --- Set a prefix string to be pre-pended to all input file names.\\
  This is ignored on NOS. On ``Unix-like'' systems, it allows a directory to be set in which to look for all
  input files. The format of this string is not examined by \textbf{GPLOT}, but currently a \texttt{/} character is added to the end
  of it. This behaviour may change in future versions, as this may be inappropriate on other operating systems to which
  \textbf{GPLOT} may be ported.
\item \textttc{EXIT} --- Exit \textbf{GPLOT}.\\
   This closes any log file, flushes graphics commands to the output device, and shuts down \textbf{DIMFILM}. 
   Then it exits \textbf{GPLOT} --- surprise!
\end{itemize}

\section{Defining and Using Functions}
The ability to define and use functions is based on an \textbf{RPN evaluator} for simplicity, where operands are held on a \textbf{stack}.
However, in this case, the values on the
stack are arrays, each containing up to \texttt{MAXPOINTS} elements. These stack entries may also be used to hold scalar values
as needed by the RPN operators. The scalar values are held in the first element of the arrays. 

\subsection{Overview, storage and RPN evaluator commands}
There are a number of \textbf{commands} associated with the RPN evaluator and these are like other \textbf{GPLOT} commands.
The RPN evaluator itself deals with \textbf{operators} which act on \textbf{operands} with an entire thing to be evaluated defined
as an \textbf{RPN-string} consisting of comma separated operands and operator names. The operand and operator name strings are
the two types of \textbf{tokens} understood by the RPN evaluator. 
\newpara
The size of the stack can be set with the command:
\begin{itemize}
\item \textttc{NSTACK n}
\end{itemize}
where \texttt{n} is an integer greater than or equal to 4. The default is 8. The number of words used by the stack is 
\texttt{NSTACK * MAXPOINTS}
and this must be compatible with the maximum field length. The first four stack entries are also used to store X and Y points 
and X and Y error bars for graph plotting, so \texttt{NSTACK} must be at least 4.
\newpara
The stack entries are numbered 0, 1 \ldots \texttt{NSTACK-1}. Stack entry 0 is special:
\begin{itemize}
\item It can only be written to by the \textttc{ERANGE} command or the \textttc{XLIN}, \textttc{XLOG} and \textttc{SETX} 
RPN operators.
\item Writing to it with the \textttc{ERANGE} command, or the \textttc{XLIN} or \textttc{XLOG} operators,
  sets the evaluation range and the number of active elements in
the stack arrays -- i.e. the array length, \texttt{NELEM} for evaluation purposes\footnote{Also referred to as
\texttt{NEVAL} internal to \texttt{GPLOT}.}.
\item Its contents can be accessed by the \textttc{X} RPN operator.
\end{itemize}
It is usual for the contents of stack level 0 to define the values for which the function will be evaluated, which is why its contents
are accessed with the operator named \textttc{X}. Since the effective array length must be known for the vast majority of operators to
work, either the \textttc{ERANGE} command \emph{must be used before} any RPN is evaluated or the \textttc{XLIN} or \textttc{XLOG} 
operators must be used before any other RPN operators. The contents of stack level 0 will be called the \textbf{X range array.}
\newpara
Stack level 1 is also special in that it contains the Y values corresponding to the X values in the X range array when plotting graphs.
This may be referred to as the \textbf{Y value array}. There is an RPN operator which explicitly sets this by copying the contents of
the top-of-stack (TOS) array into it.
\newpara
Three other groups of storage are also defined for use with function definition and evaluation:
\begin{itemize}
\item \textbf{Scalar Registers}: There are 9 registers (named 1 to 9) that can be used with \texttt{STO} and \texttt{RCL} commands and RPN
	operators to save scalar variables.
\item \textbf{String Registers}: There are 9 registers (named 1 to 9) to hold strings of up to 80 characters. These can be set with the
	\texttt{STRING} command and accessed by RPN operators.
\item \textbf{Procedure Registers}: These 9 registers (named 1 to 9) are used to hold RPN procedures as strings that can be `called`. The
	contents can be set with the command \texttt{PROC} to a literal string, or loaded from a procedure library file using the
	\texttt{LOADPROC} command (see below).
\end{itemize}
\newpara
A procedure is defined in the form of an \textbf{RPN-string} as a series of comma separated tokens:
\begin{verbatim}
TOKEN,TOKEN,...,TOKEN
\end{verbatim}
A \texttt{TOKEN} is a numeric constant operand or an RPN operator. Unlike commands, RPN operator names cannot be abbreviated. 
\newpara
There are two commands which can cause an \texttt{RPN-string} to be evaluated. The main one is:
\begin{itemize}
\item \textttc{EVAL RPN-string [``arguments'']}
\end{itemize}
The \texttt{RPN-string} for \texttt{EVAL} can `call` procedures stored in Procedure Registers (as \texttt{RPN-string}s) using the token
\texttt{@n} where \texttt{n} is the Procedure Register number (1 to 9). The `calling` of procedures in Procedure Registers is
actually done by string substitution. There is no true call-return mechanism. If a stored procedure contains \texttt{@n}, it
will also be substituted. The substitution continues until no \texttt{@n} sequences are found in the expanded procedure
string.
\newpara
There is an optional second argument to \texttt{EVAL} which can be used to pass parameters to a procedure, in a sense. If present,
it should be a comma separated list of up to 9 numeric values (or \texttt{\$n} for parameter substitution in scripts). These
values are placed into successive Scalar Registers starting with register 1. Using these registers, along with String Registers,
is how parameters can be given to RPN procedures. Inside those, the parameter values are accessed with the \texttt{RCL} operator.
\newpara
A very useful variant on EVAL is:
\begin{itemize}
\item \textttc{ITEVAL start end step RPN-string [``arguments'']}
\end{itemize}
which will evaluate the RPN-string \texttt{max( int( (end - start + step) / step ), 0 ) } times, as per a Fortran DO-loop. The value of
the loop counter can be accessed using the token \texttt{I} in the \texttt{RPN-string}.
The \texttt{I} token has the value 1 if used in an
\texttt{RPN-string} evaluated via \texttt{EVAL}.
\newpara
Both \texttt{EVAL} and \texttt{ITEVAL} will preserve stack level 0 (or X). In some cases, it is also necessary to preserve
stack level 1 (or Y) when $(x,y)$ data points (e.g. from \texttt{READ}) are to be processed with the evaluator.
The \textttc{2DEVAL} command does this, and is otherwise equivalent to \texttt{EVAL}. Although Y is preserved on entry to
the evaluator, stack level 1 is not otherwise protected in the way stack level 0 is. The \textttc{2DITEVAL}
command is a ``Y preserving'' version of \texttt{ITEVAL} too.
\newpara
There are RPN operators which directly produce graphical output. It is sometimes useful to know the bounds of that output before
actually drawing anything, and three commands are provided to do that: \texttt{BBSTART}, \texttt{BBEND} and \texttt{BBSET}. See
the next Section for details.

\subsubsection{Evaluator Related Command Descriptions}
A full list of the commands provided for the RPN evaluator follows.
\begin{itemize}
\item \textttc{ERANGE BASE START STOP NELEM} --- Set the contents of stack level 0 (or X) to a set of equally spaced values.\\
  This also sets the effective array length to \texttt{NELEM}.
  \texttt{BASE} is 1 for linearly spaced values or the base of the logarithm for logarithmically spaced values.
  \texttt{START} is the starting value for the range.
  For logarithmic ranges, the \texttt{BASE} is raised to \texttt{START} for the starting value.
  \texttt{STOP} is the ending value for he range (the range is inclusive).
  For logarithmic ranges, the \texttt{BASE} is raised to \texttt{END} for the ending value.
  \texttt{NELEM} is the number of steps to make between START and STOP.\\
  For example: \texttt{ERANGE 2 1 8 8} results in \texttt{2, 4, 8, 16, 32, 64, 128 and 256} appearing in X.
\item \textttc{EVAL RPN-string [``arguments'']} --- See above.
\item \textttc{ITEVAL start end step RPN-string [``arguments'']} --- See above.
\item \textttc{2DEVAL RPN-string [``arguments'']} --- See above.
\item \textttc{2DITEVAL start end step RPN-string [``arguments'']} --- See above.  
\item \textttc{PROC N RPN} --- Put an RPN string into Procedure Register N (1 to 9).
\item \textttc{LOADPROC N NAME} --- Copy a named procedure from the \texttt{GPLPROC} procedure library file to Procedure Register \texttt{N}.
  For more information on this, see Section~\ref{gplproc-sect}.
\item \textttc{STRING N TEXT} --- Set the contents of String Register \texttt{N} to \texttt{TEXT}.
  The only way to pass strings to the RPN evaluator is through String Registers.
\item \textttc{STO N X} --- Put \texttt{X} into Scalar Register \texttt{N}. The only way to pass numeric parameters to the RPN evaluator is through
  Scalar Registers. The optional ``arguments'' string to EVAL and ITEVAL is a conveneient way of setting a group of these
  registers to pass parameters to a procedure.
\item \textttc{RCL N} --- Display the contents of Scalar Register \texttt{N}.
\item \textttc{ZEROVAL V} --- Set the value of divide-by-zero avoidance and some other tolerance tests. The default is $10^{-9}$.
\item \textttc{BBSTART} prevents RPN operators that would normally draw things from doing so, but instead has them accumulate bounding
	box information.
\item \textttc{BBEND} restores normal operation of the graphics drawing RPN operators.
\item \textttc{BBSET} sets the bounds to the accumulated bounding box and is equivalent to issuing a \texttt{BOUNDS} command with the
	appropriate arguments.
\end{itemize}

\subsection{How the RPN evaluator works}
The RPN evaluator's basic operation given an \texttt{RPN-string} is as follows:
\begin{enumerate}
\item Split \texttt{RPN-string} into tokens using commas as token separators.
\item Loop over the tokens.
\item For each token, first check if it could be an operand:
  \begin{enumerate}
  \item If it can be interpreted as a decimal number (integer, or real using floating point or scientific notation), treat it as an
  	operand and push a constant array with every element set to this value on the stack 
  	(if there is room -- if the stack would overflow abandon evaluation with an error message).
  \item If the token is \texttt{X}, push the X range array on to the stack.
  \item If the token is \texttt{PI}, push a constant array with every element set to $\pi$ on to the stack.
  \item If the token is \texttt{TWPI}, push a constant array with every element set to $2 \pi$ on to the stack.
  \item If the token is \texttt{PI/2}, push a constant array with every element set to $\frac{\pi}{2}$ on to the stack.
  \item If the token is \texttt{E}, push a constant array with every element set to $e$ on to the stack.
  \item If the token is \texttt{I}, push a constant array with every element set to the iteration number on to the stack if
  	the evaluation is being done from \texttt{ITEVAL} or 1 otherwise.
  \end{enumerate}
\item If it is not an operand, see if it is a known operator. If not, that is an error and evaluation is abandoned.
\item Given that the token is a known operator, the number of operands it needs is known. If there are insufficient
	operands on the stack, abandon evaluation with stack underflow.
\item Try to execute the operator. It is applied to all elements of its operand arrays to produce one or more
	results, which are usually also naturally arrays, but if the result is naturally scalar, all elements of the output array
	are set to that value. The operands are popped off the stack and the results are pushed on to it.
\item In the rare case that an operator has more results than operands, a check is made for stack overflow. If that
	would happen, evaluation is abandoned.
\item Some operators can also fail with some operands which are not within the domain of the operator or would result
	in divide by zero. If these conditions occur, evaluation is abandoned with a domain error or divide by zero error.
	The tolerance for possible divide by zero conditions can be set with the \textttc{ZEROVAL} command before evaluation.
\item Some operators cause graphics output as a `side effect` \ldots albeit a rather critical one!
\end{enumerate}

\newpara
The RPN evaluator, while useful, has a number of fundamental limitations.
\begin{itemize}
\item There are no jumps, conditional branches or looping constructs. This makes it less powerful than the RPN in
  programmable calculators. (There is conditional value selection operating on array elements, but that is a different
  thing.) The only form of looping available is through \texttt{ITEVAL}, which is useful, but limited.
\item The command line (and all other input lines in \textbf{GPLOT}) is limited to 80 characters. Any lines longer
  than this are truncated at 80 characters. This means the length of an RPN string must be significantly less than this.
  For many problems, the limited size of procedures this implies makes it impossible to use the RPN evaluator to solve them.
  Using procedures stored in the GPLPROC procedure library is a useful way of working around this, as explained below. Using this,
  the maximum size of a procedure is 696 characters, which is not huge, but enough for many tasks.
\end{itemize}

\subsection{Operands and Operators}
In the following descriptions of the available operators, the symbol \texttt{A} is an array of \texttt{NELEM} values 
existing as a operand on the stack. The symbol \texttt{C} is a scalar value (a simple constant) existing as an operand
on the stack and actually stored in the first element of the \texttt{NELEM} length array used for all operands. The convention used for describing Forth operators is used:\\
\texttt{( O1 O2 \ldots -- R1 R2 \ldots )} \\
where \texttt{O1} (etc.) are the operands that must be on the stack before the operator is used (and it consumes them),
and \texttt{R1} (etc.) are the values left on the stack by the operator. The \texttt{--} signifies the action of the operator.
\texttt{TOS} is short for Top Of Stack.

\subsubsection{Constants}
Most of these tokens set the top-of-stack (TOS) to an arbitrary value or to one of several standard constants, all of which need no further
description. There are two operators in this group and these are:
\begin{itemize}
\item \texttt{I} : This is the iteration number if the \texttt{RPN-string} is being evaluated from \texttt{ITEVAL} or the constant 1 otherwise.
\item \texttt{IDX} : This fills the TOS array with the index of its array elements -- \texttt{1 \ldots MAXSTACK} -- so that \texttt{A[I]=I}. 
\end{itemize}
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
<DIGITS> & (    -- C1 )  & SET TOS ARRAY TO A LITERAL CONSTANT.\\
X & (    -- A1 )  & SET TOS TO X RANGE ARRAY.\\
PI  & (    -- C1 ) & SET TOS TO PI.\\
E & (    -- C1 ) &  SET TOS TO E.\\
TWPI & (    -- C1 ) & SET TOS TO 2 PI.\\
PI/2 & (    -- C1 ) & SET TOS TO PI / 2.\\
\hline
I & (    -- C1 ) & SET TOS TO ITERATION NUMBER FROM ITEVAL. 1 IF IN EVAL.\\
\hline
IDX & (    -- A1 ) & SET TOS TO THE ARRAY ELEMENT INDEX. \\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Stack Manipulation}
These operators provide the essential stack operations needed by all RPN evaluators. They also provide:
\begin{itemize}
\item \texttt{SETX} and \texttt{SETY} : Easy ways of setting the stack levels used as X (also evaluation range) and Y values 
	for graph plotting from the TOS values.
\item \texttt{XLIN} and \texttt{XLOG} : Sets the X (evaluation range) stack level to equally spaced values 
	in a linear or logarithmic space.
\item \texttt{I0IJ} and \texttt{I1IJ} : Convert a 1D, 1 based, array index to a pair of 2D array indices for a 2D array 
	with a given first dimension. The first of these generates 0 based 2D array indices and the second generates 1 based
	indices. In all cases, the specified first dimension of the 2D array must be $>0$!
\end{itemize}
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
SWAP or S & ( A1 A2 -- A2 A1 ) & SWAP OR EXCHANGE TOP 2 STACK ARRAYS.\\
DUP or \& & ( A1 -- A1 A1 ) & DUPLICATE TOP OF STACK (TOS)\\
POP & ( A1 -- ) & POP TOP OF STACK\\
G & (\ldots AN \ldots C1 -- AN ) & GET STACK LEVEL AT DEPTH C1 INTO TOS\\
CL & ( -- ) & CLEAR STACK\\
SETX & ( A1 -- A1 ) & OVERWRITE RANGE / GRAPH X VALUES WITH TOS: X = A1\\
SETY & ( A1 -- A1 ) & OVERWRITE GRAPH Y VALUES WITH STACK TOP VALUES: Y = A1\\
XLIN & ( C1 C2 C3 -- ) & X = C1 TO C2 IN C3 LINEAR STEPS\\
XLOG & ( C1 C2 C3 C4 -- ) & X = C1**C2 TO C1**C3 IN C4 STEPS\\
EL & ( A1 C2 -- A1 C2 ) & C2 = A1[C2]\\
I0IJ & ( C1 C2 -- C1' C2' ) & C1'=MOD(C1,C2), C2'=(C1/C2) : 1D TO 2D INDICES, 0 BASED.\\
I1IJ & ( C1 C2 -- C1' C2' ) & C1'=MOD(C1,C2)+1, C2'=(C1/C2)+1 : 1D TO 2D IDX, 1 BASED.\\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Basic Arithmetic}
These operators provide the arithmetic operations of a basic RPN calculator, but operating on arrays.
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
+ & ( A1 A2 -- A1 ) & ADD ARRAY ELEMENTS: A1 = A1 + A2\\
- & ( A1 A2 -- A1 ) & SUBTRACT ARRAY ELEMENTS: A1 = A1 - A2\\
R- & ( A1 A2 -- A1 ) & REVERSE SUBTRACT: A1 = A2 - A1\\
* & ( A1 A2 -- A1 ) & MULTIPLY ARRAY ELEMENTS: A1 = A1 * A2\\
** & ( A1 A2 -- A1 ) & EXPONENTIATION: A1 = A1 ** A2\\
/ & ( A1 A2 -- A1 ) & DIVIDE ARRAY ELEMENTS: A1 = A1 / A2\\
R/ & ( A1 A2 -- A1 ) & REVERSE DIVIDE: A1 = A2 / A1\\
RCP & ( A1 -- A1 ) & RECIPROCAL A1 = 1.0 / A1\\
CHS & ( A1 -- A1 ) & A1 = -A1\\
ABS & ( A1 -- A1 ) & A1 = ABS(A1)\\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Math Functions}
These operators provide all the standard functions that would be found on a scientific calculator, but operating on arrays.
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
SIN & ( A1 -- A1 ) & A1 = SIN(A1)\\
COS & ( A1 -- A1 ) & A1 = COS(A1)\\
TAN & ( A1 -- A1 ) & A1 = TAN(A1) \\
ASIN & ( A1 -- A1 ) & A1 = ARCSIN(A1)  \\
ACOS & ( A1 -- A1 ) & A1 = ARCCOS(A1)  \\
ATAN & ( A1 -- A1 ) & A1 = ARCTAN(A1)  \\
SINH & ( A1 -- A1 ) & A1 = SINH(A1), DOMAIN |X| < 742.36  \\
COSH & ( A1 -- A1 ) & A1 = COSH(A1), DOMAIN |X| < 742.36 \\
TANH & ( A1 -- A1 ) & A1 = TANH(A1), DOMAIN |X| < 742.36 \\
SQRT & ( A1 -- A1 ) & A1 = SQRT(A1) \\
LOG & ( A1 -- A1 ) & BASE E LOGARITHM: A1 = LN(A1) \\
LG10 & ( A1 -- A1 ) & BASE 10 LOGARITHM: A1 = LOG10(A1) \\
LOG2 & ( A1 -- A1 ) & BASE 2 LOGARITHM: A1 = LOG2(A1) \\
EXP & ( A1 -- A1 ) & A1 =  E ** A1  DOMAIN: -675.81 TO 741.66 \\
RAND & ( A1 -- A1 ) & UNIFORMLY DISTRIBUTED RANDOMS [0:A1): A1 = A1 * RANDOM \\
SEED & ( C1 -- ) & SET RANDOM NUMBER SEED TO A1[1] \\
GCD & ( C1 C2 -- C1 ) & FIND GREATEST COMMON DIVISOR OF C1, C2\\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Number Range Related Functions}

\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
MIN & ( A1 A2 -- A1 ) & A1 = MIN(A1,A2) \\
MAX & ( A1 A2 -- A1 ) & A1 = MAX(A1,A2) \\
MOD & ( A1 A2 -- A1 ) & A1 = MOD(A1,A2) OR A1 = A1 \% A2 \\
SIGN & ( A1 -- A1 ) & A1 = (A1 < 0) ? -1 : 1 \\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Conditionals}
There functions compare arrays of numbers and set a result array to 0 or 1 (false or true) depending on the
result of that comparison. There is also a \texttt{SEL} operator which uses the result of a comparison to select elements from 
one array or another. There is currently no way to conditionally execute code in the RPN-string, so they do not provide anything
like \texttt{IF \ldots THEN \ldots} functionality.
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
ODD & ( A1 -- A1 ) & A1 = 1 WHERE INT(A1) IS ODD ELSE 0 \\
GT & ( A1 A2 -- A1 A2 A3 ) & A3 = (A1 > A2) ? 1 : 0 ; \\
LT & ( A1 A2 -- A1 A2 A3 ) & A3 = (A1 < A2) ? 1 : 0 ; \\
LE & ( A1 A2 -- A1 A2 A3 ) & A3 = (A1 <= A2) ? 1 : 0 ; \\
GE & ( A1 A2 -- A1 A2 A3 ) & A3 = (A1 >= A2) ? 1 : 0 ; \\
EQ & ( A1 A2 -- A1 A2 A3 ) & A3 = (A1 == A2) ? 1 : 0 ; \\
NE & ( A1 A2 -- A1 A2 A3 ) & A3 = (A1 != A2) ? 1 : 0 ; \\
NOT & ( A1 -- A1 ) & A1 = (A1 == 0) ? 1 : 0 ; \\
SEL & ( A1 A2 A3 -- A1 A2 A3 ) & A3 = (A3 == 0) ? A1 : A2 ; \\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Number Type Conversions}
These operators can the integer and fractional parts of a number and convert a number to the `nearest' integer in various ways.
Numbers are always kept as floating point internally, though.
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
INT & ( A1 -- A1 ) & TRUNCATION A1 = INT(A1) \\
FRAC & ( A1 -- A1 ) & FRACTIONAL PART A1 = FRAC(A1) \\
FLR & ( A1 -- A1 ) & A1 = FLOOR(A1) \\
CEIL & ( A1 -- A1 ) & A1 = CEILING(A1) \\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Graphics}
These operators provide a pretty complete set of drawing functions. If the \texttt{BBSTART} command has been given, they do not
actually draw anything. Instead, they accumulate a bounding box, which can be used by issuing a \texttt{BBSET} command,
which sets the plotting bounds to the accumulated bounding box. Using the \texttt{BBEND} command restores the
normal drawing functions of these operators.
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
M & ( C1 C2 -- ) & MOVE TO (C1,C2) \\
D & ( C1 C2 -- ) & DRAW TO (C1,C2) \\
C & ( C1 C2 C3 -- ) & DRAW CIRCLE, CENTER C1,C2 RADIUS C3. \\
A & ( C1 C2 C3 C4 C5 -- ) & DRAW ARC, CENTER C1,C2 RADIUS C3, ANGLES C4 TO C5. \\
BOX & ( C1 C2 C3 C4 -- ) & DRAW RECTANGLE, BOTTOM LEFT C1,C2 WIDTH C3 HEIGHT C4. \\
MK & ( C1 -- ) & DRAW MARKER WITH CODE NUMBER C1, CENTRE CURRENT POS. \\
HDSH & ( A1 -- A1 ) & DRAW RELATIVE (1,0) IF A1[I] > 0 ELSE MOVE \\
VDSH & ( A1 -- A1 ) & DRAW RELATIVE (0,1) IF A1[I] > 0 ELSE MOVE \\
PTHO & ( A1 A2 -- ) & DRAW POLYLINE X=A1,Y=A2, OPEN \\
PTHC & ( A1 A2 -- ) & DRAW POLYLINE X=A1,Y=A2, CLOSED \\
CRVO & ( A1 A2 -- ) & DRAW SMOOTH LINE X=A1,Y=A2, OPEN \\
CRVC & ( A1 A2 -- ) & DRAW SMOOTH LINE X=A1,Y=A2, CLOSED \\
BEZO & ( A1 A2 -- ) & DRAW CUBIC BEZIER X=A1,Y=A2, OPEN \\
BEZC & ( A1 A2 -- ) & DRAW CUBIC BEZIER X=A1,Y=A2, CLOSED \\
T & ( C1 -- ) & DRAW CONTENTS OF STRING REGISTER C1 AS TEXT. \\
TVF & ( C1 C2 -- C1 ) & DRAW C1 AS TEXT USING FORMAT STRING IN C2. \\
TVI & ( C1 C2 -- C1 ) & DRAW INT(C1) AS TEXT USING FORMAT STRING IN C2. \\
TS & ( C1 -- ) & DRAW SYMBOL WITH CODE NUMBER C1 \\
TM & ( C1 -- ) & DRAW MARKER WITH CODE NUMBER C1 AS TEXT \\
TC & ( C1 -- ) & DRAW CHARACTER WITH CODE C1 FROM CURRENT ALPHABET \\
TH & ( C1 -- ) & SET TEXT/MARKER/SYMBOL HEIGHT \\
TA & ( C1 -- ) & SET TEXT DRAWING ANGLE IN DEGREES CCW \\
TSC & ( -- ) & START TEXT CONTINUATION \\
TEC & ( -- ) & END TEXT CONTINUATION \\
TLEN & ( C1 -- C1 ) & LENGTH IN BOUNDS UNITS AT HEIGHT=1 OF STRING IN REGISTER C1. \\
ROT & ( A1 A2 C3 -- A1 A2 ) & ROTATE X=A1,Y=A2 BY C3 RADIANS. \\
TRN & ( A1 A2 C3 C4 -- A1 A2 ) & TRANSLATE X=A1, Y=A2 BY C3,C4. \\
SCL & ( A1 A2 C3 C4 -- A1 A2 ) & SCALE X=A1, Y=A2 BY C3,C4. \\
R2D & ( C1 -- C1 ) & RADIANS TO DEGREES. \\
D2R & ( C1 -- C1 ) & DEGREES TO RADIANS. \\
LAB & ( C1 C2 C3 C4 C5 -- ) & LABEL AT (C1,C2), LEN C3, ANG C4, SR C5 \\
\hline
\end{tabular}
}
\end{small}

\subsubsection{Output and Memory Functions}
As with a calculator, the RPN evaluator provides a small number of `memories' (9) to which values can be stored
and then retrieved.
\newpara
These operators also give a way of examining arrays on the stack or the whole stack, which can be very useful for debugging. 
\newpara
\begin{small}
 \texttt{
\begin{tabular}{|| l | l  | l ||}
\hline
Token & Actions & Description\\
\hline
STO or = & ( A1 C2 -- A1 ) & STORE A1[1] (A.K.A. C1) IN REGISTER C2 \\
RCL or \# & ( C1 -- C1 ) & RECALL CONST VALUE FROM REGISTER INT(C1) \\
P & ( -- ) & PRINT TOS ARRAY FIRST AND LAST ELEMENTS \\
PE & ( A1 C2 C3 -- A1 ) & PRINT ELEMENTS C2 TO C3 OF A1 IN FREE FORMAT \\
PC & ( C1 -- C1 ) & PRINT C1 (TOS A[1]) IN FREE FORMAT. \\
DUMP & ( -- ) & PRINT ALL STACK LEVELS FIRST AND LAST ELEMENTS \\
\hline
\end{tabular}
}
\end{small}

\subsection{The GPLPROC Procedure Library}\label{gplproc-sect}
\newpara
The file \texttt{GPLPROC} can be used to define named procedures for the RPN evaluator to use. This file is
automatically made \texttt{LOCAL} on NOS whenever \texttt{LOADPROC} is used.

\newpara
The format of named procedure definitions in GPLPROC is very simple.
\begin{lstlisting}
  PROCNAME [nlines]
  RPN-string
  . . .
  RPN-string
\end{lstlisting}

\newpara
For example:
\begin{lstlisting}
C AN UNROTATED ELLIPSE,  "XC YC A B"
ELLIPSE
CL,0,TWPI,360,XLIN,X,&,COS,3,#,*,1,#,+,S,SIN,4,#,*,2,#,+,PTHC
\end{lstlisting}
defines a single line procedure called ELLIPSE, which can be loaded into a Procedure Register
with:
\begin{lstlisting}
LOADPROC 1 ELLIPSE
\end{lstlisting}
would load ELLIPSE into Procedure Register 1, and
\begin{lstlisting}
EVAL @1 "1.0,2.0,2.0,0.5"
\end{lstlisting}
will then draw an ellipse.

\newpara
As with scripts (obey files), full line comments can be inserted by starting the line with
``\texttt{\#}'' or ``\texttt{C }``.

\newpara
If the procedure name is followed by the optional \texttt{nlines} value (an integer in the range 2 to 9),
procedures longer than (at the very most) 80 characters can be defined. This is implemented by putting
consecutive lines into successive Procedure Registers. All lines except the last have \texttt{,@n} added to their
ends automatically, where \texttt{n} is the procedure line number plus 1. This has three consequences:
\begin{itemize}
\item The procedure substitution mechanism will ``chain'' the Procedure Register contents together into one
  RPN string.
\item All lines (except the last) in such a procedure definition may have no more than 77 characters.
\item The first \texttt{nlines} Procedure Register contents will be overwritten.
\end{itemize}

\newpara
An example of a multi-line procedure definition is:
\begin{lstlisting}
C ANGLE PAIR "X Y LENGTH ROT1-DEGREES ROT2-DEGREES"
ANGLEPAIR 4
CL,0,1,2,XLIN,X,0,3,#,DUP,SCL,4,#,D2R,ROT,1,#,2,#,TRN,PTHO
4,#,9,=,5,#,4,=
CL,0,1,2,XLIN,X,0,3,#,DUP,SCL,4,#,D2R,ROT,1,#,2,#,TRN,PTHO
9,#,4,=,CL,1,#,2,#,3,#,2,/,4,#,5,#,A
\end{lstlisting}

\newpara
There is no specific limit to the number of procedures that can be defined in \texttt{GPLPROC},
although every \texttt{LOADPROC} just searches the file sequentially from the start for the name,
so it will get slow eventually. There is also no limit on the length of procedure names,
except for the universal 80 character line length restriction.


\section{Higher Level Drawing Commands}
\newpara
While \textbf{DIMFILM} provides a comprehensive set of graph plotting facilities (many -- but not all -- of which can
be accessed via \textbf{GPLOT}), its general purpose drawing facilities are somewhat limited, at least by today's
standards. To address this, \textbf{GPLOT} has added some ``higher level'' features, which ultimately use \textbf{DIMFILM}'s
functionality, but may make some tasks much easier. Rather than try to provide very general extensions, such as a stack
of transformation matrices as in \textbf{PostScript}, the \textbf{GPLOT} extensions are aimed at specific common tasks.

\newpara
These higher level drawing commands are based on three new components:
\begin{itemize}
\item \textbf{Boxed text}. These provide a simple way of creating a rectangle containing text (one or more
  lines) with several options. Such things are the basic building blocks of block diagrams and similar things.
  They can also be used to create tables.
\item \textbf{Decorated lines}. These are polylines, the ends of which can be ``decorated'' with arrow heads or things
  we call ``skips'' which can give the impression of one line ``jumping over'' another. Additionally, the
  midpoint of a line segment can contain a very short textual label (typically one or two characters) which
  will be drawn inside a circle.
\item \textbf{Labels}. These are single lines of text, enclosed in a box, from which an arrow points to a specified
  location. The length of the arrow, and the direction (given as an angle in degrees counter-clockwise
  around the ``pointed at'' position from the positive X axis)
  are also specified.
\end{itemize}

\subsection{Boxed text}
\newpara
These commands draw a boxed text and establish its parameters:
\begin{itemize}
\item \textttc{BOXTEXT [X Y]} --- This draws a boxed text object at the location $(x,y)$ (if supplied) or
  at the last incremented boxed text position (see \texttt{BOXPDELTAS}). \texttt{TEXT} is the text to be placed in
  the box. This may have up to 5 lines with lines separated by back-slash characters. All \textbf{DIMFILM} string
  markup applies. The appearance of the text and various other options are controlled by the following \texttt{BOXP\ldots}
  parameter setting commands.
\item \textttc{BOXPSIZE WIDTH HEIGHT BOTLEFT} --- This sets the size of the (outer) box. All text will be drawn
  within this box and it may, under some circumstances, be clipped against it. \texttt{WIDTH} and \texttt{HEIGHT} are the dimensions of the
  box in \texttt{BOUNDS} units. If \texttt{BOTLEFT} is \texttt{YES}, the box coordinates will be used for the bottom left point. If \texttt{BOTLEFT}
  is \texttt{NO}, they will be used as the centre point.
\item \textttc{BOXPBOX WHICH} --- Controls which box outlines are drawn. \texttt{WHICH} may be:
  \begin{itemize}
  \item \texttt{NONE} --- No outlines are drawn.
  \item \texttt{OUTER} --- The outer box, with dimensions specified with \texttt{BOXPSIZE}, will be drawn.
  \item \texttt{INNER} --- The inner box, tightly surrounding the text, will be drawn. This area is protected from hatching (if any),
    whether the outline is drawn or not.
  \item \texttt{BOTH} --- Both box outlines are drawn.
  \end{itemize}
\item \textttc{BOXPTEXT WIDTHFRAC MODE FLUSHLEFT} --- Controls how the text is drawn. \texttt{MODE} may be:
  \begin{itemize}
  \item \texttt{FIX} --- In this case, the text is not scaled to fit the box directly. Instead, a \texttt{SYMHT} is calculated so that
    \texttt{WIDTHFRAC} lines will fit inside the box. If any line is too long with this \texttt{SYMHT}, it will be clipped at the box
    edges. All boxed text objects with the same height and \texttt{WIDTHFRAC} will have a consistent text size in a diagram.
    \texttt{WIDTHFRAC} will typically be an integer, 1 or greater.
  \item \texttt{SCALE} --- In this case, the text is scaled so that the longest line occupied \texttt{WIDTHFRAC} of the box width.
    In this case, \texttt{WIDTHFRAC} will typically be a floating point number less than 1 and greater than 0.
    There may be no consistency between text sizes in different boxed texts in a diagram with the \texttt{SCALE} option.
  \end{itemize}
  If \texttt{FLUSHLEFT} is \texttt{YES}, the text will be left justified in the inner box.
  If \texttt{NO}, the text will be centred in the inner box.
\item \textttc{BOXPHATCH SPACING IANGLE MODE} --- This controls how the boxed text is hatched (or not). \texttt{MODE} may be:
  \begin{itemize}
  \item \texttt{NONE} --- No hatching will be drawn.
  \item \texttt{VERT} --- Hatch lines will be draw joining the bootom and top edges of the box.
  \item \texttt{HORIZ} --- Hatch lines will be drawn joining the left and right edges of the box.
  \item \texttt{BOTH} --- Both \texttt{HORIZ} and \texttt{VERT} hatching will be drawn.
  \end{itemize}
  \texttt{SPACING} is the distance between hatch lines along the edges in \texttt{BOUNDS} units. \texttt{IANGLE} is the number of spacings
  on the opposite edge that the end point of a hatch line will be displaced, controlling the angle at which
  it is drawn.
\item \textttc{BOXPDELTAS DX DY} --- Set the auto-increment of boxed text positions after each boxed text is drawn. If a \texttt{BOXTEXT}
  is specified without an explicit position, the result of adding these deltas to the last \texttt{BOXTEXT} position will be
  used as the new position. This is very useful for constructing tables, which can easily be built from abutting boxed text objects.
\end{itemize}

\subsection{Decorated lines}
These commands draw, or set the parameters of, a decorated polyline:
\begin{itemize}
\item \textttc{LINE LINESPEC} --- This defines and draws a decorated line. \texttt{LINESPEC} is a string
  (not quoted, as it cannot contain spaces) which describes the line using a series of \texttt{POINTSPECs}
  separated by \texttt{>} characters (which may be read as ``go to'' characters here). I.e.\\
  \texttt{LINE POINTSPEC>POINTSPEC...POINTSPEC}\\
  A \texttt{POINTSPEC} consists of a single character \texttt{TYPE}, then an \texttt{X} coordinate followed by a \texttt{Y}
  coordinate, optionally followed by a very short \texttt{ANNOTATION} string. \texttt{X, Y and ANNOTATION} are separated
  by commas. I.e.\\
  \texttt{<TYPE>X,Y[,ANNOTATION]}\\
  The possible values for \texttt{TYPE} are:
  \begin{itemize}
  \item \texttt{P} --- Plain. This point will be undecorated.
  \item \texttt{A} --- Arrow. This point will be decorated with an arrow head. If this is the first
    \texttt{POINTSPEC} in a \texttt{LINESPEC}, the arrow will point out from the start of the polyline
    If it is the last \texttt{POINTSPEC}, it will point out from the end of the polyline.
    If used on intermediate \texttt{POINTSPECs}, an arrow will be drawn at both the end of one line segment and the start of
    the next, with the arrows pointing towards each other (which is rarely useful).
  \item \texttt{S} --- Skip. This is (more or less) a quarter-circle. If this is the first
    \texttt{POINTSPEC} in a \texttt{LINESPEC}, the quarter-circle will start at the top of a circle and fall down to
    the line segment. If this is the last \texttt{POINTSPEC} in a \texttt{LINESPEC}, it will rise up from the line segment
    to the top of the quarter-circle. Using \texttt{S} on intermediate \texttt{POINTSPECs} will cause a half-circle to be drawn.
  \end{itemize}
\item \textttc{ARROWPARM TYPE SIZE SHARPNESS BARBEDNESS} --- Sets how arrow heads are to be drawn. \texttt{TYPE} may be:
  \begin{itemize}
  \item \texttt{OPEN}
  \item \texttt{CLOSED}
  \item \texttt{BARBED}
  \end{itemize}
  These are probably self-explanatory. \texttt{SIZE} is the tip-to-base length in \texttt{BOUNDS} units.
  \texttt{SHARPNESS} control how sharp the arrow head looks in the range 0.5 (very broad) to 5 (very sharp) with 2 being
  a good default. The \texttt{BARBEDNESS} controls how deep the barb is, using a fraction of the tip-to-base distance. 0.3
  is a good default. Note that these parameters also control the appearence of arrow heads in labels too.
\item \textttc{LINEPARM SKIPSCALE ANNOTSCALE} --- Sets the size at which skips and mid-line annotations are drawn.
  \texttt{SKIPSCALE} is half the length of a skip in \texttt{BOUNDS} units. That is, two abutting skips will cover this distance.
  \texttt{ANNOTSCALE} is twice the diameter of the annotation enclosing circle in \texttt{BOUNDS} units.
\end{itemize}

\subsection{Labels}\label{labels-sect}
These let you point at something with a short message. These commands draw labels:
\begin{itemize}
\item \textttc{ALABEL X Y LENGTH ANGLE TEXT} --- Add a label pointing at \texttt{BOUNDS} coordinates $(x,y)$.\\
  \texttt{LENGTH} is the distance from the point $(x,y)$ to the centre of the box containing the label text in \texttt{BOUNDS} units.
  \texttt{ANGLE} is the angle the arrow line makes with the +X axis in degrees.
  \texttt{TEXT} is a (short) label string, enclosed in double quotes if it contains spaces. If it is entirely spaces, the arrow
  is drawn without any box at its ``far'' end. All \textbf{DIMFILM} ``string markup'' can be used.
\item \textttc{GLABEL GX GY LENGTH ANGLE TEXT} --- Add a label pointing at graph coordinates $(x,y)$.\\
  This is useful for labelling points on graphs. Note that \texttt{LENGTH} is in \texttt{BOUNDS} units. It is not possible to use ``graph
  lengths'' as the axis ranges may be wildly different or log axes may be in effect. The arguments are the same as
  for \texttt{ALABEL} apart from the meaning of the coordinates.
\end{itemize}

\section{Drawing smooth curves}
GPLOT can draw smooth curves in two different ways, and either with commands or evaluator operators. It is best to
refer to the tutorial material on these facilities in Section~\ref{smooth-label}.

\section{Defining and drawing L-systems}
Leveraging the functionality added for general purpose function evaluation described above, a quite specialised but
fun facility for defining and drawing L-systems is also available. Lindenmayer (L) systems were invented by the theoretical
biologist Aristid Lindenmayer in the 1960's to describe the growth and development of multicellular organisms such as 
algae and plants. They can also be used to draw a variety of fractal curves.
\newpara
L-systems are somewhat abstract and hard to grasp, but the graphical results make them worth persevering with.
They are based on formal systems in which there is a predefined alphabet of allowed symbols, some of which can
be interpreted as drawing commands. Others are place holders which have no associated graphical interpretation.
Once an L-system is defined, it can be \emph{developed} over a number of iterations. Once fully developed, it
will be drawn by executing the drawing commands associated with certain symbols. 
The allowed symbols are arranged as strings, and the development of an L-system proceeds by a series of
string manipulations -- primarily string substitution.
\newpara
An L-system is defined by four things:
\begin{itemize}
\item An axiom string. This is the starting point from which the final string to be drawn will be developed over a given
	number of iterations. In \textbf{GPLOT}, this is stored in string register 1.
\item A set of production rules. These are used to rewrite the string in each iteration. There can be up to 8 rules,
	stored in string registers 2 to 9. These begin with the symbol to be substituted, followed by a colon, then the
	symbols which are to be substituted in place of that symbol each time the symbol is encountered in the current
	string (initially the axiom string, then the result of the previous application of the production rules).
\item A turning angle, used when interpreting the final string as graphics commands.
\item An initial angle, stored in memory register 3, as well as
	the initial $(x,y)$ starting point for drawing being in memory registers 1 and 2.
\end{itemize}
\newpara
The \textbf{GPLOT} L-system facility uses the following alphabet:\\
\texttt{F, A, B, C, D, E, M, X, Y, +, -, [, ]}\\
of which \texttt{A, B, C, D, E, F, M, X, Y} may be substituted with another string defined in a production rule.
The graphics state used when drawing an L-system string consists of the current $(x,y)$ position and a current
drawing angle along which a virtual pen can move. The symbols with a graphical interpretation are:
\begin{itemize}
\item \texttt{F} -- draw a unit length line segment at the current drawing angle.
\item \texttt{D} -- as F but two different substitutable draw symbols are needed.
\item \texttt{M} -- move by unit length at the current drawing angle.
\item \texttt{+} -- turn counter-clockwise by the turning angle.
\item \texttt{-} -- turn clockwise by the turning angle.
\item \texttt{[} -- push the current position and angle on to a stack.
\item \texttt{]} -- pop a position and angle off the stack and make them current.
\end{itemize}
\newpara
An example of defining an L-system as an OBEY file is:
\begin{verbatim}
STRING 1 X
STRING 2 F:FF
STRING 3 X:F-[[X]+X]+F[+FX]-X 
STO 3 90
LSYSTEM 2 $1 22.5
\end{verbatim}
The (single) parameter that must be passed to this is the number of iterations to perform
before drawing the result. This example draws something that looks remarkably similar to
a straw-like plant.

\section{Output Devices}\label{devinfolabel}
\textbf{GPLOT} supports these devices:
\begin{itemize}
\item \textttc{GTERM} --- \textbf{GTerm} colour graphics terminal.\\
   This is a Python program I wrote to allow APL to be used with its proper character set, as
   well as to function as a better alternative to an \texttt{xterm} emulation of a Tektronix 401x for
   vector graphics output (e.g. that from \textbf{GPLOT}). Unlike Tek 401x emulations, it supports colour,
   anti-aliasing\footnote{Ren\'{e} Richarz's 4014 emulator is nicely anti-aliased, but \texttt{xterm} is not.} 
   and anything displayed can be saved as SVG. \textbf{GTerm} runs on Linux and macOS, but not
   on any version of Windows.
\item \textttc{TEK4K} --- Tektronix 4014 graphics terminal emulation.\\
   This should work with any Tek 401x emulator. It has been tested with \texttt{xterm} and with Ren\'{e} Richarz's
   excellent 4014 emulator. The latter has much higher quality graphics than \texttt{xterm}
   and reproduces other features of the Tektronix
   DVST displays for a very realistic experience.
\item \textttc{EPSCOL NAME [SIZE]} --- Output to a colour EPS file.\\
   Output goes to the \texttt{LOCAL} file \texttt{NAME}. As of V0.58,
   `real' EPS is generated directly in NOS, using 6/12 character encoding which supports all printable ASCII
   characters. \texttt{SIZE} is of the form: \texttt{W,H+X+Y} where \texttt{W} is the width,
   \texttt{H} the height and \texttt{X} and \texttt{Y} are offsets from the bottom left -- the
   units are inches in all cases.
\item \textttc{SVG NAME [SIZE]} --- Output SVG (Scalable Vector Graphics) to a file. This can be included in HTML files, and
  this format is used by the \texttt{PLNOTES} application on NOS to insert graphs and graphics into documents.
  \texttt{SIZE} is of the form: \texttt{W,H} which are
  the width and height in ``pixels'' (although, this does not affect the ``resolution'', just
  the size browsers and other software assign to it).
\end{itemize}
\newpara
There is also an \textttc{EPSBIN} device, which supports only black and white (i.e. binary) output colours, but this
is no longer thought to be useful and will not be described further.
\newpara
The length of \texttt{NAME} must be kept to 4 (!) characters on NOS and COS. The full output file name is formed from
the name supplied here, followed by 3 leading zero padded decimal digits (starting at 001). With a 4 character
\texttt{NAME}, this makes 7 characters in total, which is the maximum NOS and COS file name length. If \texttt{NAME} is longer than 4
characters, it is truncated to 4 by \textbf{GPLOT}.
\newpara
On Unix, the length of \texttt{NAME} may be up 72 characters (before truncation by \textbf{GPLOT}). 
\newpara
At the end of each frame (i.e. when a \texttt{CLEAR} command is used or when \textbf{GPLOT} is exited), the frame number part
of the name is incremented after the output file has been written. So, if \texttt{NAME} is \texttt{EPXA} then a series of
output files may be generated on NOS and COS: \texttt{EPXA001, EPXA002 ...}
\newpara
On Unix systems, the name may be more descriptive, use mixed case and will also be automatically given the 
appropriate extension. However, the output file names will be translated to all
lower case by \textbf{GPLOT}. E.g. If \texttt{NAME} is \texttt{ExampleA}, the output files may be named
\texttt{examplea001.eps, examplea002.eps ...}.

\section{Building and Maintaining \textbf{GPLOT} and \textbf{DIMFILM}}

Please see the main \texttt{README.md} for the \textbf{GPLOT} project on Github
for detailed information on how to build and install \textbf{GPLOT} on both NOS
and ``Unix''.

\clearpage
\part{GPLOT Tutorial and Examples}
\clearpage

\section{Plotting graphs}

\subsection{The simplest graph}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr1001.eps}
  \caption{A very simple graph}
  \label{fig:gr1001}
\end{figure}

Let's start by plotting a very simple graph -- Figure \ref{fig:gr1001}.
Normally, data to be
plotted exists in disk files, but, in this first example, the data
will be internally generated by the \texttt{MEMTEST} command, which dynamically
allocates data arrays on NOS (static arrays are used on ``Unix-like'' systems)
and fills X,Y values with a sine wave.

\newpara
The script file (obey file) to generate this contains:
\begin{lstlisting}
# SIMPLEST GRAPH
#
RESET
MEMTEST
TITLE "A*L VERY SIMPLE GRAPH"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
XYLINE
\end{lstlisting}

\newpara
Although very minimal, there are a few points worth noting.

\begin{itemize}
\item For maximum NOS / ``Unix'' compatibility, it is best to use only UPPER CASE in obey files.
If you use lower case, it will work on both systems, but the results may be different. 
NOS (in \texttt{NORMAL} mode) will internally convert lower case to upper case. 
So ``A very simple graph'' will appear exactly as that on ``Unix'', but as ``A VERY SIMPLE GRAPH'' on NOS. 
Using upper case and \textbf{DIMFILM} ``string markup'' is portable and handles subscripts, superscripts, 
fractions and so on too. Note that \textbf{GPLOT} should \emph{not} be used in \texttt{ASCII} mode on NOS! 
\textbf{GPLOT} does not attempt to deal with 6/12 Display Code, but will convert it (mostly!) to upper case. 
However, internal arrays are not sized for 6/12 representations, so there will be problems 
(mainly strings being unexpectedly truncated rather than crashes, though).
\item The \texttt{RESET} command re-establishes a default state. If multiple obey files are used in one \textbf{GPLOT} session
without using \texttt{RESET} at the top of each file, the results will be unpredictable (the state 
at the end on one obey file will be inherited by the next).
\item This script is device independent. It can be used ``as is'' with any of the supported devices.
To generate SVG from it, we can use:
\begin{lstlisting}
/ GPLOT or $ gplot
? dev svg sveg 1200,800
? prefix obey-files
? obey obgraf1
? ex
\end{lstlisting}
which will create an SVG file called \texttt{sveg001} (\texttt{sveg001.svg} on ``Unix'' and VMS,
\texttt{sveg001\_svg} on NOS/VE) using a 
``resolution'' of 1200 by 800 pixels (with SVG, this is
really a ``size'' rather than a resolution, as the vector data can be scaled without losing detail).
\item The various annotations associated with a graph (title, axis labels, etc.) should appear before the command which plots the data
(\texttt{XYLINE} here).
\item The ranges of the X and Y axes are automatically determined from the supplied data.
\item The graph is drawn in a square area in the center of the output device ``canvas''. 
When plotting graphs, it is often better to fill the output canvas.
\item Everything is drawn in a single colour (red).
\end{itemize}

\newpara
We will address these last two deficiencies in the next example.

\subsection{Bounds, panes, devices and coordinate systems in \textbf{DIMFILM}}

\newpara
It is perhaps worth understanding why the graph appears in a centered square area on the device
even at this stage. 

\newpara
\textbf{DIMFILM} lets the user define a ``world coordinate system'' or ``user coordinates''.
These ``bounds''
are defined by four numbers,
\texttt{xlo} to \texttt{xhi} defining a range of X coordinates, and
\texttt{ylo} to \texttt{yhi} defining a range of Y coordinates. This
coordinate system is intended to be ``square'' in that a unit step in X
should have the same length when drawn by the output device as a unit
step in Y. The output devices each have their own ranges of valid
coordinates. In the case of the interactive devices (\textbf{GTerm} and the
Tektronix 4014), these ranges are fixed (not strictly true for \textbf{GTerm}).
The valid range of coordinates can be set by the user for the ``file''
devices, SVG and EPS, by defining the ``paper size'' when the device is
opened. The coordinate systems of these devices are also defined to be
``square''.

\newpara
\textbf{DIMFILM} also has the concept of a ``pane'', which is initially identical
to the ``bounds''. The ``pane'' is a rectangular subregion of the
bounds, specified by four numbers in bounds coordinates.

\newpara
For general purpose drawing, you want to have a ``square'' coordinate
system, so that circles when drawn are circles and not ellipses.

\newpara
For plotting graphs of data, though, ``squareness'' is not usually
important. \textbf{DIMFILM} determines the locations and sizes of the various
elements of a graph in terms of fractions of the pane. The graph will be
placed inside the pane, squashed and stretched as may be to fill it.

\newpara
The default initial bounds (and pane) are set to 0 to 1 by 0 to 1, which
is a square region. To maintain ``squareness'' while maximising the use
of the display area, the bounds region must cover either the height or
the width of the display (or both).

\newpara
To make the situation clearer, we can draw the limits of the device
(which we have set to a 1200 by 800 ``pixel'' region when we opened the
SVG device) and the outline of the bounds (and pane) region by adding
these commands:

\begin{lstlisting}
OUTLINE DEVICE
OUTLINE BOUNDS
\end{lstlisting}

\newpara
(see Figure~\ref{fig:gr1a001}).

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr1a001.eps}
  \caption{A simple graph showing the bounds}
  \label{fig:gr1a001}
\end{figure}

\newpara
The only way to use the full area of the display is for the bounds to
have the same \emph{aspect ratio} as the display. That is:

\begin{lstlisting}
xhi - xlo     width_display
---------  =  -------------
yhi - ylo     height_display
\end{lstlisting}

\subsection{NOS, Unix-like systems and compatibility}\label{nos-unix-like-systems-and-compatibility}
\newpara
Before moving on, it may be worth discussing how \textbf{GPLOT} tries to maximise
compatability between these two very different operating systems.

\newpara
Perhaps the most obvious thing when glancing at the first example is
that the script is entirely UPPER CASE. This need not be so, and the
following will work on both ``Unix-like'' systems and NOS (although
after transfer to NOS without using 6/12 coding - which should not be
used - it will appear in upper case there).

\begin{lstlisting}
# Simplest graph.
#
reset
memtest
title "A very simple graph"
xlabel "X axis"
ylabel "Y axis"
xyline
outline dev
\end{lstlisting}

\newpara
On ``Unix-like'' systems, the output will be identical to the first
script's output. However, on NOS, the title and labels will appear in
upper case.

\newpara
Using \textbf{DIMFILM's} ``string markup sequences'' (the \texttt{*L} here)
allows lower case to be plotted on NOS.

\newpara
If you really don't like using upper case for some reason, you can use
lower case and ``string markup'' and get the same result as using upper
case on both systems.

\newpara
\textbf{GPLOT} also tries to use heuristics to make file name related matters
transparent, although there are limits to this considering each NOS
account has a flat file system with maximum 7 letter/digit upper case
only file names!

\newpara
For NOS / ``Unix'' compatibilty, you will have to stick to 7 character
file names. However, you can specify a path for ``Unix'' that is
prefixed to each file name using the \texttt{PREFIX} command. This
prefix is not used for device output files, though, so they will be
created in the current working directory.

\newpara
If you don't care about NOS compatibility, you can use long file names,
so long as the entire path name does not exceed 72 characters.

\newpara
Note that NOS does not have file name extensions. In contrast,
``Unix-like'' systems pretty much rely on having file name extensions.
EPS output files will be given \texttt{.eps} extensions on ``Unix'' and VMS,
SVG files will be given \texttt{.svg}. On NOS/VE, the ``extensions'' are
\texttt{\_eps} and \texttt{\_svg}, as ``dot'' is the path element separator
and extensions are not formally defined. These should not be added to the file names you
type in or put in scripts.

\newpara
To help identify what files contain on NOS, I use the first two
characters as a sort of ``extension'' -- e.g.~\texttt{OB} for obey files
-- but this is just a personal convention which NOS knows nothing about.

\newpara
\textbf{GPLOT} converts all supplied file names (including any \texttt{PREFIX})
to lower case on ``Unix''. You cannot use upper or mixed case file names
in \textbf{GPLOT} on ``Unix''. This applies to all input and output files. Very
rarely, this will be undesirable, but it almost always simplifies
matters. On NOS, all file names are upper case and all lower case is
converted to upper case by NOS.

\subsection{Using different colours and filling the canvas}\label{using-different-colours-and-filling-the-canvas}
\newpara
Here is the same graph as above, but with different classes of things in
different colours and filling the output canvas (Figure~\ref{fig:gr2001}).

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr2001.eps}
  \caption{Better colours, filling the bounds}
  \label{fig:gr2001}
\end{figure}

\newpara
The code for this is:
\begin{lstlisting}
# USING COLOUR/STYLE GROUPS
#
RESET
GRAPHMODE ON
MEMTEST
CSGROUP GENERAL
COL 1 0 0
CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0.1 1
TITLE "A*L SIMPLE GRAPH WITH BETTER COLOURS"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
XYLINE
OUTLINE DEV
\end{lstlisting}

\newpara
To use the full area of the device, the command:
\begin{lstlisting}
GRAPHMODE ON
\end{lstlisting}

\newpara
was added. This just sets the bounds to have the same aspect ratio as
the display device internally. In this case, to match the aspect ratio
of 1200 by 800 (3:2), the bounds will be set to 0 to 1.5 by 0 to 1.

\newpara
Note that
\begin{lstlisting}
GRAPHMODE OFF
\end{lstlisting}
resets the bounds to 0 to 1 by 0 to 1 and if bounds are explicitly
specified, they just supersede the ones set by \texttt{GRAPHMODE}.

\newpara
In \textbf{GPLOT/DIMFILM} there are 3 ``different classes of things'', namely:
\begin{itemize}
\item
  Text (\texttt{TEXT}): this refers to all types of ``strings''.
\item
  Annotation (\texttt{ANNOT}): this refers to the various things that
  annotate graphs specifically.
\item
  Other (\texttt{GENERAL}): All elements not in the above classes. This
  includes all lines and points.
\end{itemize}
All of them are members of the class \texttt{ALL}.

\newpara
These 3 classes are called ``colour/style groups'' and the current class
is selected with the \texttt{CSGROUP} command. Following this,
\texttt{COLOUR} and \texttt{WIDTH} commands set the colour (as
normalised RGB) and line width for that \texttt{CSGROUP} only. Perhaps
oddly, the line style (solid, dashed, etc.) is \emph{not} set
independently for different groups in \textbf{DIMFILM}. The current line style applies to
all groups.

\newpara
Note that any command can be abbreviated -- so long as the abbreviation
remains unique, it will work. (Note that this is \emph{not} true of
evaluator operators, as we will see).


\subsection{Adding a grid or graticule}\label{adding-a-grid-or-graticule}
\newpara
In order to better see the values on plotted graphs, it is often useful
to have a grid or graticule over which the graphs are plotted (as with
traditional graph paper). This is easily added with the \texttt{GRID}
command:

\begin{lstlisting}
# ADD A GRID
#
RESET
GRAPHMODE ON
MEMTEST
CSGROUP GENERAL
COL 1 0 0
CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0.1 1
TITLE "A*L SIMPLE GRAPH WITH A GRID"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
GRID BOTH
XYLINE
OUTLINE DEV
\end{lstlisting}

\newpara
resulting in Figure~\ref{fig:gr3001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr3001.eps}
  \caption{Adding a grid}
  \label{fig:gr3001}
\end{figure}


\subsection{Changing the width of lines}\label{changing-the-width-of-lines}
\newpara
As with colour, the width of lines can easily be set independently for
each colour/style group with the \texttt{WIDTH} command. As an example,
see Figure~\ref{fig:gr4001}.

\begin{lstlisting}
# GRAPH PLOT WITH WIDER LINE
#
RESET
MEMTEST
GRAPHMODE ON
CSGROUP GENERAL
COL 1 0 0
WIDTH 3
CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0.1 1
TITLE "A*L SIMPLE GRAPH WITH A WIDER LINE"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
GRID BOTH
XYLINE
OUTLINE DEV
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr4001.eps}
  \caption{Adjusting line width}
  \label{fig:gr4001}
\end{figure}

\subsection{Different graph styles}\label{different-graph-styles}
\newpara
The graphs above are all drawn with the default ``framed'' graph style.
An alternative is the ``open'' style, shown in Figure~\ref{fig:gr5001}.

\begin{lstlisting}
# OPEN STYLE GRAPH
#
RESET
MEMTEST
GRAPHMODE ON
CSGROUP GENERAL
COL 1 0 0
WIDTH 3
CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0.1 1
GSTYLE OPEN
TITLE "A*LN OPEN STYLE SIMPLE GRAPH"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
XYLINE
OUTLINE DEV
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr5001.eps}
  \caption{Open style graph}
  \label{fig:gr5001}
\end{figure}

\newpara
Another alternative is the ``axes'' style, as shown in Figure~\ref{fig:gr7001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr7001.eps}
  \caption{Axes style graph}
  \label{fig:gr7001}
\end{figure}

\begin{lstlisting}
# AXES STYLE GRAPH
#
RESET
MEMTEST
CSGROUP GENERAL
COL 1 0 0
WIDTH 3
CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0.1 1
AXCUT 0.02 0
GSTYLE AXES
TITLE "A*LN AXES STYLE SIMPLE GRAPH"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
XYLINE
OUTLINE DEV
\end{lstlisting}

\newpara
To which a grid can be added in the obvious way (Figure~\ref{fig:gr8001}).

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr8001.eps}
  \caption{Adding a grid}
  \label{fig:gr8001}
\end{figure}

\begin{lstlisting}
# AXES STYLE GRAPH WITH GRID
#
RESET
GRAPHMODE ON
MEMTEST
CSGROUP GENERAL
COL 1 0 0
WIDTH 3
CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0.1 1
AXCUT 0.02 0
GSTYLE AXES
GRID BOTH
TITLE "A*LN AXES STYLE SIMPLE GRAPH WITH GRID"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
XYLINE
OUTLINE DEV
\end{lstlisting}


\subsection{Multiple graphs on the same axes and ``HERE'' data}\label{multiple-graphs-on-the-same-axes-and-here-data}
\newpara
To plot more than one graph on the same axes is quite straightforward.
First, note that we haven't explicitly specified the ranges of the axes
in any of the graphs so far. Instead, the system has looked at the data
and automatically found reasonable ranges for the axes. This is very
often the best approach.

\newpara
To plot more than one graph and keep automatically determining the axis
ranges can be done with the with two commands: \texttt{XYSAME} and
\texttt{ANNOT\ OFF}. The second prevents annotation being drawn multiple
times and the first keeps the axis ranges automatically determined from
the first data plotted.

\newpara
\textbf{GPLOT} also lets you specify data ``inline'' in a script file. Here is a
very simple example (Figure~\ref{fig:gr10001}) and the script that generated it.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr10001.eps}
  \caption{Multiple graphs, same axes}
  \label{fig:gr10001}
\end{figure}

\begin{lstlisting}
# 2 CURVE GRAPH WITH INLINE DATA
#
RESET
#
GRAPHMODE ON
GSTYLE BOXED
#
CSGROUP GENERAL
COL 1 0 0
WIDTH 1
STYLE SOLID
#
CSG TEXT
COL 0 0 0
STYLE SOLID
#
CSG ANNOT
COL 0 0.1 1
STYLE SOLID
#
#--- DEFINE SOME DATA INLINE 
READ HERE 1 2
0 0
1 1
2 0
EOF
#--- DRAW THAT WITH AUTO DETERMINED AXIS RANGES
GRID BOTH
TITLE "T*LWO CURVES, SAME AXES, INLINE DATA"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
XYLINE
#
#--- TURN OFF ANNOTATION AND KEEP AUTO DET RANGES FOR NEXT CURVE
ANNOT OFF 
XYSAME
#
#--- DEFINE SOME MORE DATA INLINE
READ HERE 1 2
0 1
1 0.1333
2 1
EOF
#
#--- DRAW THAT IN A DIFFERENT COLOUR AND WIDTH.
CSG GEN
COL 1 0 1
WIDTH 3
STYLE DASHDOT
XYLINE
OUTLINE DEVICE
\end{lstlisting}

\newpara
Note the \texttt{READ} command. This is described further in the section
on plotting data in files. For inline data, the keyword \texttt{HERE} is
used with it, and the data follows immediately. That data is terminated
by \texttt{EOF}. The numeric arguments to \texttt{READ} are ``column
numbers'' and will almost always be \texttt{1\ 2} for inline data.

\subsection{Multiple graphs and keys}\label{multiple-graphs-and-keys}
\newpara
\textbf{GPLOT} provides a straightforward (if inflexible) way of adding a key or
legend to help identify the meaning of the lines (or points) on graphs.

\newpara
Figure~\ref{fig:gr11001} is an example of three curves with a key and the generating script.
The data is again defined by ``HERE'' data.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr11001.eps}
  \caption{Multiple graphs with a key}
  \label{fig:gr11001}
\end{figure}

\begin{lstlisting}
# 3 CURVE GRAPH WITH INLINE DATA AND KEYS
#
RESET
GRAPHMODE ON
#
GSTYLE BOXED
#
CSGROUP GENERAL
COL 1 0 0
WIDTH 1
STYLE SOLID
#
CSG TEXT
COL 0 0 0
STYLE SOLID
#
CSG ANNOT
COL 0 0.1 1
STYLE SOLID
#
# --- DEFINE SOME DATA INLINE 
READ HERE 1 2
0 0
1 1
2 0
EOF
#
# --- WE WILL ADD KEYS.
USEKEY
#
# --- DRAW THAT WITH AUTO DETERMINED AXIS RANGES
GRID BOTH
TITLE "T*LHREE CURVES WITH KEYS"
XLABEL "X*L AXIS"
YLABEL "Y*L AXIS"
XYLINE
ADDKEY "F*LIRST"
#
# --- TURN OFF ANNOTATION AND KEEP AUTO DET RANGES FOR NEXT CURVE
ANNOT OFF 
XYSAME
#
# --- DEFINE SOME MORE DATA INLINE
READ HERE 1 2
0 1
1 0.1333
2 1
EOF
#
# --- DRAW THAT IN A DIFFERENT COLOUR AND WIDTH.
CSG GEN
COL 1 0 1
WIDTH 3
STYLE DASHDOT
XYLINE
ADDKEY "S*LECOND"
#
# --- DEFINE YET MORE DATA INLINE
READ HERE 1 2
0 1
0.2 0.2
0.4 0.8
0.6 0.4
0.8 0.6
1.0 0.5
1.2 0.6
1.4 0.4
1.6 0.8
1.8 0.2
2 1
EOF
#
# --- DRAW THAT IN A DIFFERENT COLOUR AND WIDTH.
CSG GEN
COL 0.1 0.7 0.1
WIDTH 2
STYLE SOLID
XYLINE
ADDKEY "T*LHIRD"
#
# --- DRAW THE LEGEND.
KEYS
OUTLINE DEV
\end{lstlisting}

\newpara
This allows adding keys for up to 20 curves (I find 10 curves on one
graph is as much as I can cope with). The maximum length of the key text
is also quite limited at a maximum of 15 characters (including any
markup sequences).

\newpara
The layout currently cannot be changed. The key/legend area is always
positioned to the right of the graph. This may be better than trying to
put the key on top of the graph, as it can be impossible to find a place
to put that without obscuring part of the data (at least, I've often
found that is the case over the decades). That approach could certainly
be added, though.

\subsection{Multiple curves with two different Y axis
ranges}\label{multiple-curves-with-two-different-y-axis-ranges}
\newpara
Sometimes it is useful to plot two (or more) curves with the same X axis
but, because they have significantly different Y ranges, two distinct Y
axes. This can be done by having one Y axis on the left of a graph and
another on the right.

\newpara
A simple example is shown in Figure~\ref{fig:gr12001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr12001.eps}
  \caption{Common X axis, two different Y ranges}
  \label{fig:gr12001}
\end{figure}

\begin{lstlisting}
# TWO CURVES, DIFFERENT AXIS RANGES
#
RESET
GRAPHMODE ON
CSG ANNOT
COL 0 0 1
CSG TEXT
COL 0 0 1
#
# --- GENERATE A SINE WAVE.
EVAL 0.1,TWPI,2,*,0.1,+,201,XLIN,X,SIN
#
# --- PLOT IT WITH AUTO AXIS RANGES.
XLAB "X"
YLABEL "S*LINE VALUE"
TITLE "T*LWO CURVES, DIFFERENT Y AXIS RANGES"
XYL
ANNOT OFF
#
# --- DEFINE A TRIANGLE WAVE SHAPE.
READ HERE 1 2
0 0
5 100
10 0
EOF
#
# --- PLOT THAT WITH AUTO AXIS, PUT VALUES ON RIGHT
CSG ALL
COLOUR 0 0 0
RIGHTANNOT ON
RYLABEL "R*LIGHT EDGE (TRIANGLE VALUES)"
XYL
OUTLINE DEV
\end{lstlisting}

\newpara
This example includes the first use of the evaluator so far (to create
the sine wave curve). It is not essential to this example, though.

\newpara
Note that the axis ranges are still automatically determined
(\texttt{XYSAME} is not used for obvious reasons). The
\texttt{ANNOT\ OFF} command is need though, before the
\texttt{RIGHTANNOT} command is used.

\newpara
It is possible to create a key for such a graph too (Figure~\ref{fig:gr13001}).

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr13001.eps}
  \caption{Two different Y ranges and a key}
  \label{fig:gr13001}
\end{figure}

\begin{lstlisting}
# TWO CURVES, DIFFERENT AXIS RANGES, KEY
#
RESET
GRAPHMODE ON
CSG ANNOT
COL 0 0 1
CSG TEXT
COL 0 0 1
#
# --- GENERATE A SINE WAVE.
EVAL 0.1,TWPI,2,*,0.1,+,201,XLIN,X,SIN
#
# --- WE WILL USE KEYS.
USEKEY
#
# --- PLOT IT WITH AUTO AXIS RANGES.
XLAB "X"
YLABEL "S*LINE VALUE"
TITLE "T*LWO CURVES, DIFFERENT Y AXIS RANGES"
XYL
ADDKEY "S*LINE"
ANNOT OFF
#
# --- DEFINE A TRIANGLE WAVE SHAPE.
READ HERE 1 2
0 0
5 100
10 0
EOF
#
# --- PLOT THAT WITH AUTO AXIS, PUT VALUES ON RIGHT
CSG ALL
COLOUR 0 0 0
RIGHTANNOT ON
RYLABEL "R*LIGHT EDGE (TRIANGLE VALUES)"
XYL
ADDKEY "T*LRIANGLE"
#
# --- DRAW LEGEND.
KEYS
OUTLINE DEV
\end{lstlisting}

\subsection{Plotting data stored in a disk file}\label{plotting-data-stored-in-a-disk-file}
\newpara
So far, we have plotted data that has been generated by \textbf{GPLOT} or stored
as ``HERE'' data in the command stream. Very often, the data to be
plotted will be in disk files, though.

\newpara
\textbf{GPLOT} provides a very simple, albeit basic, way of reading such data and
plotting it. Given a file containing the same number of numeric items on
each line, with those items separated by spaces or a comma (and perhaps
spaces), \textbf{GPLOT} can treat the n-th number on each line as an entry in a
column of numbers. The columns are numbered 1, 2, 3, etc.

\newpara
Any line that begins with \texttt{\#} or \texttt{C} (upper case C, not
lower case) will be skipped as a comment. Any entirely blank lines will
also be skipped.

\newpara
The \texttt{READ} command is followed by the name of the data file to be
read then the column numbers for the X and Y coordinates.

\newpara
Figure~\ref{fig:gr14001} is an example of some real measured data stored in a file
(\texttt{DAEG1}) and plotted.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr14001.eps}
  \caption{Measured data from a file}
  \label{fig:gr14001}
\end{figure}

\begin{lstlisting}
# READ AN X,Y DATA FILE AND PLOT THE CONTENTS
#
RESET
GRAPHMODE ON
#
# --- READ THE DATA FILE, FIRST 2 COLUMNS, SPACE OR COMMA SEP.
GET DAEG1
READ DAEG1 1 2
#
# --- DRAW THE GRAPH
CSG ANNOT
COL 0 0 0
CSG TEXT
COL 0 0 0
TITLE "M*LAINS VOLTAGE ON 7-*UAUG*L-2025"
XLABEL "H*LOURS W.R.T MIDNIGHT 6/7 *UA*LUGUST"
YLABEL "V*LOLTS (*URMS - 220V *LNOMINAL)"
XYLINE
#
OUTLINE DEV
\end{lstlisting}

\newpara
The data file will usually have at least two columns. However, a single
column of data can be plotted. That data will become the Y values and
the X values will be the line number (starting at 0). Use a 0 column
number to do this. For example:

\begin{lstlisting}
READ DAEG1 0 2
\end{lstlisting}

\subsection{Labelling points on a graph}\label{labelling-points-on-a-graph}
\newpara
It is sometimes useful to point out something on a graph.
Figure~\ref{fig:gr15001} is an example of this.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr15001.eps}
  \caption{Labelling points on a graph}
  \label{fig:gr15001}
\end{figure}

\newpara
This is quite easy to do, in this case by adding the following commands
between \texttt{XYLINE} and \texttt{OUTLINE}:

\begin{lstlisting}
#
# --- ADD A LABEL OR TWO
CSG ALL
COL 0 0 0
GLABEL 9.8 192.0 0.1 165 "W*LHAT HAPPENED?"
CSG TEXT
COL 0.7 0.384 0.025
GLABEL 14 191.5 0.05 165 "E*LEK"
\end{lstlisting}

\newpara
The \texttt{GLABEL} command's first two arguments are the graph
coordinates to which the label's arrow should point. The third argument
is the length of the arrow in \emph{bounds coordinates} (which will be 0
to 1 by 0 to 1 by default, or 0 to (device aspect ratio) by 0 to 1 if
\texttt{GRAPHMODE\ ON} is in effect). The fourth argument is the angle
of the arrow around the location it is pointing at, counter-clockwise
from \texttt{+X} in degrees. The final argument is the text for the
label, which will be drawn in a box at the blunt end of the arrow.

\subsection{Data with uncertainties (error bars) in Y}\label{data-with-uncertainties-error-bars-in-y}
\newpara
If your data has an uncertainty measure associated with it, that can be
plotted as an error bar on the graph. The meaning of this value is
entirely up to you, of course. For common meanings see this
\href{https://en.wikipedia.org/wiki/Error_bar}{Wikipedia article}.

\newpara
Using a concocted data file (\texttt{DAEG2}) which looks like this:

\begin{lstlisting}
0.0,0.0,0.0
0.1,0.01,0.004
0.2,0.04,0.01
0.3,0.09,0.041
0.4,0.16,0.083
0.5,0.25,0.013
0.6,0.36,0.022
0.7,0.49,0.033
0.8,0.64,0.054
0.9,0.81,0.065
1.0,1.0,0.1
\end{lstlisting}

\newpara
(note the use of comma separated instead of blank separated values
here), the following script will plot a graph with error bar data taken
from column 3:

\begin{lstlisting}
# READ AN X,Y,E DATA FILE AND PLOT THE CONTENTS
#
RESET
GRAPHMODE ON
#
# --- READ THE DATA FILE, FIRST 3 COLUMNS. THIS ONE USES COMMAS.
GET DAEG2
READ DAEG2 1 2 3
#
# --- DRAW THE GRAPH
CSG ANNOT
COL 0 0 0
CSG TEXT
COL 0 0 0
CSG GEN
COL 0.8 0.1 0.1
TITLE "L*LOOKS LIKE X*+2$+ WITH SYMMETRICAL ERRORS"
XLABEL "X"
YLABEL "Y"
XYLINE
OUTLINE DEV
\end{lstlisting}

\newpara
This results in Figure~\ref{fig:gr16001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr16001.eps}
  \caption{Symmetric Y error bars}
  \label{fig:gr16001}
\end{figure}

\newpara
The column given as the third argument to \texttt{READ} supplies the
delta from the values taken from the column given as the second argument
to \texttt{READ} at which error bar limits will be drawn above and below
the value.

\subsection{Data with asymmetric uncertainties in Y}\label{data-with-asymmetric-uncertainties-in-y}
\newpara
It is possible that your data has potential deviations that are larger
in the negative direction than in the positive direction, perhaps
because the underlying data distribution is not normal, but skewed, or
perhaps the device making measurements has errors that are proportional
to the magnitude of the measured values. To visualise this, you need
asymmetric error bars in Y.

\newpara
To illustrate this, we have concocted another data file
(\texttt{DAEG3}):

\begin{lstlisting}
0.0,0.0,0.0,0.0,0.0
0.1,0.01,0.004,0.006,0.002
0.2,0.04,0.01,0.12,0.033
0.3,0.09,0.041,0.032,0.092
0.4,0.16,0.083,0.043,0.161
0.5,0.25,0.013,0.09,0.251
0.6,0.36,0.022,0.022,0.3617
0.7,0.49,0.033,0.021,0.5
0.8,0.64,0.054,0.066,0.666
0.9,0.81,0.065,0.032,0.814
1.0,1.0,0.1,0.05,0.997
\end{lstlisting}

\newpara
Note this has 5 columns but here we will use the first four.
\newpara
To plot this with asymmetrical error bars only requires a change to
\texttt{READ}. The \texttt{XYLINE} (or \texttt{XYPOINT}) command will
plot whatever the last \texttt{READ} has read.
\newpara
Note the command: \texttt{ASYMYERRORS\ YES} which explicitly turns on
this behaviour. This is not needed, however, as it is the default.

\begin{lstlisting}
# READ AN X,Y,EU,EL DATA FILE AND PLOT THE CONTENTS
#
RESET
GRAPHMODE ON
#
# --- READ THE DATA FILE, FIRST 4 COLUMNS. THIS ONE USES COMMAS.
ASYMYERRORS YES
GET DAEG3
READ DAEG3 1 2 3 4
#
# --- DRAW THE GRAPH
CSG ANNOT
COL 0 0 0
CSG TEXT
COL 0 0 0
CSG GEN
COL 0.8 0.1 0.1
TITLE "L*LOOKS LIKE X*+2$+ WITH ASYMMETRICAL ERRORS"
XLABEL "X"
YLABEL "Y"
XYLINE
OUTLINE DEV
\end{lstlisting}

\newpara
This results in Figure~\ref{fig:gr17001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr17001.eps}
  \caption{}
  \label{fig:gr17001}
\end{figure}

\newpara
Note that the column specified as the 3rd argument to \texttt{READ} is
the delta from the 2nd argument column value to the \emph{upper} limit
of the error bar, and the column specified as the 4th argument is the
(negative) delta to the \emph{lower} limit of the error bar.

\newpara
It is easy to plot points on top of this. This might be useful when the
points are derived from real measurements and a curve has been fitted to
these measurements. As an example of this, we take the point Y
coordinates from the 5th column of \texttt{DAEG3} using this script:

\begin{lstlisting}
# READ AN X,Y,EU,EL DATA FILE AND PLOT THE CONTENTS
#
RESET
GRAPHMODE ON
#
# --- READ THE DATA FILE, FIRST 3 COLUMNS. THIS ONE USES COMMAS.
ASYMYERRORS YES
GET DAEG3
READ DAEG3 1 2 3 4
#
# --- DRAW THE GRAPH
CSG ANNOT
COL 0 0 0
CSG TEXT
COL 0 0 0
CSG GEN
COL 0.8 0.1 0.1
TITLE "*LX*+2$+ WITH ASYMMETRICAL ERRORS AND POINTS"
XLABEL "X"
YLABEL "Y"
XYLINE
#
# --- PLOT POINTS
XYSAME
ANNOT OFF
CSG GEN
COL 0 0 1
SYMHT 0.04
READ DAEG3 1 5
XYPOINT
#
OUTLINE DEV
\end{lstlisting}

\newpara
This results in Figure~\ref{fig:gr18001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr18001.eps}
  \caption{gr18001}
  \label{fig:gr18001}
\end{figure}


\subsection{Data with symmetric uncertainties in Y and X}\label{data-with-symmetric-uncertainties-in-y-and-x}
\newpara
It is also easy to plot data with uncertainty estimates in both axes
(see Figure~\ref{fig:gr1x001}).
This requires the same 4 data columns as used above, but with the
command:

\begin{lstlisting}
ASYMYERRORS NO
\end{lstlisting}

\newpara
Note that this \emph{must} appear \emph{before} the \texttt{READ}
command, as it causes data to be rearranged internally immediately after
it is read. In this case, the 3rd column is interpreted as symmetric Y
error and the 4th as symmetric X error.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr1x001.eps}
  \caption{Y and X error bars}
  \label{fig:gr1x001}
\end{figure}


\subsection{Interpolating the data points}\label{interpolating-the-data-points}
\newpara
The supplied data can be interpolated for the purposes of plotting
``smooth'' curves through, rather than straight lines between, the
supplied data. This is generally frowned upon in science, but
\textbf{GPLOT/DIMFILM} can do it!

\newpara
In addition to \texttt{LINEAR} interpolation (which is usually
pointless, as the appearance of the graph does not change), a cubic (3rd
order) or quintic (5th order) polynomial can be drawn through the data
points. At least 3 points must be supplied for cubic, and 5 for quintic,
interpolation. The data must be sorted in X. The number of points to be
found between each supplied point must be specified. If the data is not
reasonably ``well behaved'', there can be numerical issues.

\newpara
To demonstrate this capability, Figure~\ref{fig:gr1i001} shows a very simple example.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr1i001.eps}
  \caption{Smooth interpolated curves through data points}
  \label{fig:gr1i001}
\end{figure}

\newpara
This is created by the following script:

\begin{lstlisting}
# INTERPOLATION
#
RESET
GRAPHMODE ON
#
# --- SOME DATA - VERY UNDERSAMPLED SIN(X)
READ HERE 1 2
0.00000  0.00000
0.78540  0.70711
1.57080  1.00000
2.35619  0.70711
3.14159  0.00000
3.92699 -0.70711
4.71239 -1.00000
5.49779 -0.70711
6.28319  0.00000
EOF
#
# --- SETUP THE GRAPH
USEKEY
CSG ANNOT
COL 0 0 0
CSG TEXT
COL 0 0 0
CSG GEN
COL 0.8 0.1 0.1
YRANGE -1.2 1.2
TITLE "I*LNTERPOLATIONS"
XLABEL "X"
YLABEL "Y"
#
# --- LINEAR INTERPOLATION, 9 INTERMEDIATES.
INTERPOLATE LINEAR 9
XYLINE
ADDKEY "L*LINEAR"
#
# --- POINTS BEING INTERPOLATED.
XYSAME
MARKER 20
XYPOINT
#
# --- CUBIC
COL 0.1 0.8 0.1
INTERPOLATE CUBIC 9
XYLINE
ADDKEY "C*LUBIC"
#
# --- QUINTIC
COL 0.1 0.1 0.8
INTERPOLATE QUINTIC 9
XYLINE
ADDKEY "Q*LUINTIC"
#
# --- FINISH THE GRAPH
KEYS
\end{lstlisting}


\subsection{Log Linear Plots}\label{log-linear-plots}
\newpara
It is possible to use a logarithmic Y axis and linear X axis. An example
of this is shown in Figure~\ref{fig:gr20001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr20001.eps}
  \caption{Log Y, linear X, $y=x^2$}
  \label{fig:gr20001}
\end{figure}

\newpara
Well, if we were hoping for a straight line with log Y for this
function, we are going to be disappointed! Here is the script for this:

\begin{lstlisting}
# LOG Y AXIS
#
RESET
GRAPHMODE ON
CSG ANNOT
COL 0 0 1
CSG TEXT
COL 0 0 1
#
# --- SQUARES OF SOME NUMBERS.
READ HERE 1 2
1 1
2 4
3 9
4 16
5 25
6 36
7 49
8 64
9 81
10 100
EOF
#
# --- WE WILL USE KEYS.
USEKEY
#
# --- PLOT IT WITH LOG Y AXIS
XLAB "*LX"
YLABEL "*LLOG(Y)"
TITLE "*LY=X*+2$+ WITH LOG Y AXIS"
GRID BOTH
YLOG
XYLINE
ADDKEY "L*LOG"
ANNOT OFF
#
# --- PLOT IT WITH LINEAR Y AXIS, VALUES ON RIGHT
CSG ALL
COLOUR 0 0 0
RIGHTANNOT ON
RYLABEL "Y (L*LINEAR)"
YLIN
XYL
ADDKEY "L*LINEAR"
#
# --- DRAW LEGEND.
KEYS
#
# OUTLINE DEV
\end{lstlisting}

\newpara
Let's try a power function instead (Figure~\ref{fig:gr2a001}).

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr2a001.eps}
  \caption{Log Y, linear X, $y=2^x$}
  \label{fig:gr2a001}
\end{figure}

\newpara
Ah hah! This time we are in luck -- a straight line using a log-linear
plot!

\subsection{Log Log Plots}\label{log-log-plots}
\newpara
It is also easy to plot data with both log Y and log X axes. This script
will do that with the same data as shown in the first log-linear plot
(but with the values scaled up to see what happens):

\begin{lstlisting}
# LOG X AND Y AXIS
#
RESET
GRAPHMODE ON
#
CSG ANNOT
COL 0 0 1
CSG TEXT
COL 0 0 1
#
# --- SQUARES OF SOME NUMBERS.
READ HERE 1 2
1.0E7 1
2.0E7 4
3.0E7 9
4.0E7 16
5.0E7 25
6.0E7 36
7.0E7 49
8.0E7 64
9.0E7 81
1.0E8 100
2.0E8 400
3.0E8 900
4.0E8 1600
5.0E8 2500
6.0E8 3600
7.0E8 4900
8.0E8 6400
9.0E8 8100
1.0E9 10000
EOF
#
# --- WE WILL USE KEYS.
USEKEY
#
# --- PLOT IT WITH LOG X AND Y AXES
XLAB "*LLOG(X)"
YLABEL "*LLOG(Y)"
TITLE "*LY=(*,X$,10*+7$+$.)*O*+2$+$* WITH LOG X AND Y AXES"
GRID BOTH
XLOG
YLOG
XYLINE
ADDKEY "L*LOG"
#
# --- PLOT IT WITH LINEAR Y AXIS, VALUES ON RIGHT
ANNOT OFF
CSG ALL
COLOUR 0 0 0
RIGHTANNOT ON
RYLABEL "Y (L*LINEAR)"
YLIN
XYL
ADDKEY "L*LINEAR"
#
# --- DRAW LEGEND.
KEYS
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr21001.eps}
  \caption{$y=\left(\frac{x}{10^7}\right)^2$}
  \label{fig:gr21001}
\end{figure}

\newpara
And we now have a straight line on the log-log plot for this function,
as shown in Figure~\ref{fig:gr21001}.

\newpara
Note that one of the main reasons people plot experimental data with
log-linear or log-log axes is in the hope of seeing something like a
straight line when they do so, which gives them a clue to the form of a
mathematical model which might ``explain'' the experimental data (or, at
least, approximate it).

\subsection{Histograms and multiple plots in one figure}\label{histograms-and-multiple-plots-in-one-figure}
\newpara
Histograms are another common type of plot and \textbf{GPLOT} can draw them in
various styles. There are no facilities for binning raw data so that
histograms can be drawn, however. Other software must prepare counts of
data points that fall into bins of specified ranges. All \textbf{GPLOT} deals
with are the counts and bin numbers for each count.

\newpara
As a minimal example, here is a single column of counts that can be
represented by a histogram (file \texttt{DAEG4}):

\begin{lstlisting}
100
123
90
20
10
1
200
233
129
43
77
6
2
9
64
99
12
18
111
87
\end{lstlisting}

\newpara
The following script draws histogram plots of this data in four
different styles:

\begin{lstlisting}
# READ A COUNTS ONLY DATA FILE AND MAKE HISTOGRAMS.
#
RESET
#
# --- READ THE DATA FILE, FIRST COLUMN ONLY.
GET DAEG4
READ DAEG4 0 1
#
# --- SET COLOURS
CSG ANNOT
COL 0 0 0
CSG TEXT
COL 0 0 0
CSG GEN
COL 0.8 0.1 0.1
#
# --- SET THE AXIS RANGES AND USE INT LABELS.
XRANGE -1 20
YRANGE 0 240
AXCUT NO
INTVALUES BOTH
#
# --- SET AXIS LABELS.
XLABEL "C*LLASS NUMBER"
YLABEL "C*LOUNT"
#
# --- ABUT STYLE IN BOTTOM LEFT.
PANE 0 0.5 0 0.5
HISTSTYLE ABUT
TITLE "C*LOUNTS HISTOGRAM (ABUTTING BARS)"
XYHIST
OUTLINE PANE
#
# --- SHADED ABUT STYLE IN BOTTOM RIGHT.
PANE 0.5 1 0 0.5
HISTSTYLE ABUT+SHADE
TITLE "C*LOUNTS HISTOGRAM (ABUTTING SHADED BARS)"
XYHIST
OUTLINE PANE
#
# --- SPECIFIED WIDTH BARS IN TOP LEFT.
PANE 0 0.5 0.5 1
HISTSTYLE WIDE 0.25
TITLE "C*LOUNTS HISTOGRAM (SPECIFIED WIDTH BARS)"
XYHIST
OUTLINE PANE
#
# --- THIN LINES IN TOP RIGHT.
PANE 0.5 1 0.5 1
HISTSTYLE LINES
TITLE "C*LOUNTS HISTOGRAM (IMPULSES)"
XYHIST
OUTLINE PANE
#
OUTLINE DEV
\end{lstlisting}

\newpara
The result is shown in Figure~\ref{fig:gr22001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr22001.eps}
  \caption{Histograms and sub-figures using \texttt{PANE} explicitly}
  \label{fig:gr22001}
\end{figure}

\newpara
In addition to showing how to draw histogram plots, this example shows a
number of other new features.

\begin{itemize}
\item
  We explicitly specify X and Y axis ranges rather than letting the
  software choose. This is done with the \texttt{XRANGE} and
  \texttt{YRANGE} commands.
\item
  We prevent lines being drawn for the axes -- vertical and horizontal
  lines that pass through (0,0) (or another point specified with
  \texttt{AXCUT}) -- by using: \texttt{AXCUT\ NO}
\item
  We try to use integers for the axis values instead of floating point
  numbers using \texttt{INTVALUES\ BOTH}. This option can be requested
  for X, Y, both or neither axis. It may not always be honoured, as it
  will be impossible for many axis ranges. But in this case, it is a
  reasonable request and it works.
\end{itemize}

\newpara
The most obvious new feature, though, is that the four plots showing the
different histogram drawing styles appear in a single ``figure''.

\newpara
This can be done easily with \textbf{DIMFILM}, as graphs are plotted inside any
specified ``pane'' (see above), so all you have to do is use
\texttt{PANE} appropriately.

\newpara
Actually, though, that needs some (trivial) manual calculation, but it
may also need to account for the device aspect ratio if the output
canvas is to be filled. To further simplify creating multiple plots in a
single ``figure'', \textbf{GPLOT} has the \texttt{SUBFIGGRID} command (which can
be abbreviated, fortunately). This lets you specify a rectangular
arrangement of ``sub-figures'' and the current sub-figure to be drawn
(before any plotting commands) and calculates an appropriate pane for
you, accounting for the device's aspect ratio (if \texttt{GRAPHMODE\ ON}
has been used). It also lets you ``shrink'' the figure, so there is some
white space between it and its neighbours.

\newpara
An example of using this is shown in Figure~\ref{fig:gr29001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr29001.eps}
  \caption{Histograms and sub-figures using \texttt{SUBFIGGRID}}
  \label{fig:gr29001}
\end{figure}


%% \begin{figure}
%%  \centering
%%  \includegraphics[width=\maxwidth]{../../temp/gr28001.eps}
%%  \caption{gr28001}
%%  \label{fig:gr28001}
%% \end{figure}

\newpara
The script for that is very similar to the one above, but with these
changes:

\begin{lstlisting}
# READ A COUNTS ONLY DATA FILE AND MAKE HISTOGRAMS.
#
RESET
GRAPHMODE ON
...
#
# --- ABUT STYLE IN BOTTOM LEFT.
SUBFIG 2 2 1 1 0.95
HISTSTYLE ABUT
...
#
# --- SHADED ABUT STYLE IN BOTTOM RIGHT.
SUBFIG 2 2 2 1 0.95
HISTSTYLE ABUT+SHADE
...
#
# --- SPECIFIED WIDTH BARS IN TOP LEFT.
SUBFIG 2 2 1 2 0.95
HISTSTYLE WIDE 0.25
...
#
# --- THIN LINES IN TOP RIGHT.
SUBFIG 2 2 2 2 0.95
HISTSTYLE LINES
...
#
OUTLINE DEV
\end{lstlisting}


\subsection{Multiple plots with keys in one figure.}\label{multiple-plots-with-keys-in-one-figure.}
\newpara
The ``sub-figures'' feature also works with graphs with keys (some
juggling of panes is involved internally). An example of this is
Figure~\ref{fig:gr27001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr27001.eps}
  \caption{Different plots, some with keys, in one figure}
  \label{fig:gr27001}
\end{figure}

\newpara
This redraws four of the example plots shown above. Some minor changes
to the scripts that drew them were made (any \texttt{RESET},
\texttt{GRAPHMODE} or other commands that changed the bounds or pane
were removed). These modified versions are stored in the script files
\texttt{OBGF28A}, \texttt{OBGF28B}, \texttt{OBGF28C} and
\texttt{OBGF28D}. These are then ``called'' from a ``master'' script
file \texttt{OBGF28M} (obey files can be nested up to 5 levels deep):

\begin{lstlisting}
# FOUR DISPARATE PLOTS, ONE FIGURE.
#
#===========================
RESET
GRAPHMODE ON
# --- BOTTOM LEFT OF 4
SUBFIG 2 2 1 1 0.98
#
OBEY OBGF28A
#===========================
RESET
GRAPHMODE ON
# --- TOP RIGHT OF 4
SUBFIG 2 2 2 2 0.98
#
OBEY OBGF28B
#
# ========================
RESET
GRAPHMODE ON
# --- TOP LEFT OF 4
SUBFIG 2 2 1 2 0.98
#
OBEY OBGF28C
# ========================
# --- BOTTOM RIGHT OF 4
RESET
GRAPHMODE ON
SUBFIG 2 2 2 1 0.98
#
OBEY OBGF28D
OUTLINE PANE
#
OUTLINE DEV
\end{lstlisting}

\newpara
(Note that files will be stored on ``Unix-like'' systems with lower case
file names but may be referred to in upper case in \textbf{GPLOT} -- all file
names are converted internally to lower case by \textbf{GPLOT} on ``Unix'' before
being accessed. These names could appear in lower case -- as could all
commands -- and it would work)

\newpara
Please example the ``called'' scripts for more information.

\newpara
When generating a multi-plot ``figure'', you must keep the grid size
constant in the \texttt{SUBFIG} command (e.g.~\texttt{SUBFIG\ 2\ 2}) for
every sub-figure. This is probably obvious, but nothing can check for
this.

\newpara
Note the repetition of \texttt{RESET} and \texttt{GRAPHMODE\ ON} for
each sub-figure. Without this, the various colours and styles set in one
sub-figure script would be inherited by the next. These must occur
\emph{before} the \texttt{SUBFIG} command, so they cannot be left in the
script files.

\section{Beyond graph plotting}

\subsection{Using the RPN evaluator to plot simple functions}\label{using-the-rpn-evaluator-to-plot-simple-functions}

\newpara
\textbf{GPLOT} includes a feature for calculating function values rather than
reading them from files. This is the Reverse Polish Notation (RPN)
evaluator, which provides features very similar to those you would find
on classic HP calculators.

\newpara
One difference is that the RPN evaluator often operates on \emph{arrays}
rather than scalar values, in a way that might be familiar to people who
have used \textbf{NumPy} or an APL-like language, perhaps. But with RPN thrown in
for extra confusion!

\newpara
The evaluator has quite a few features beyond those needed for simple
function plotting, and its main limitation is perhaps that the
``program'' length is limited by the 80 character input line limit
(beyond which all input is truncated).

\newpara
A complete description of the available operators can be found in the
``cheat sheet'' below (which uses a notation familar to \textbf{FORTH} users) and
in the PDF format \textbf{GPLOT} manual. Here, we just give some examples as an
introduction.

\newpara
Admittedly, the RPN evaluator may not be all that easy to use (the
\texttt{DUMP} operator is helpful when debugging), but it opens up a lot
of possibilities.

\newpara
When dealing with data from files, \textbf{GPLOT} uses between 2 and 4 arrays to
store the data to be plotted. Two are used to store X and Y coordinates.
If symmetric error bars are to be plotted a third array is used to store
that, and asymmetric Y error bars or Y and X error bars use a fourth
array.

\newpara
The RPN evaluator treats these four arrays as the first four levels of a
stack. If \texttt{READ} is used, their contents will be overwritten by
the read data and the array length seen by the evaluator will be the
number of points read.

\newpara
To provide ``room'' for any but the simplest calculations, another 4
stack levels (arrays) are provided ``above'' to four used for data from
\texttt{READ}. (This can be configured with the \texttt{NSTACK}
command).

\newpara
It is possible to use the first two X and Y levels of the stack as
inputs to the evaluator. More often, though, the contents of the X array
are set to cover some range of values by the \texttt{ERANGE} command or
certain evaluator operators, and the evaluator sets the Y values in the
Y array. This is how it can fairly straightforwardly plot mathematical
functions.

\newpara
The evaluator ``cheat sheet'' below tries to show this stack of arrays
diagrammatically.

\newpara
As a first, very simple, example, let's compute ``y=x\^{}2''. In
previous examples the data has been precomputed and read from a file
(often a ``HERE'' file). This script generates the Y values for a
defined range of X values and plots the result (left hand subfigure,
Figure~\ref{fig:gr30001}).

\begin{lstlisting}
RESET
GRAPHMODE ON
#
CSG ANNOT
COL 0 0 0
CSG TEXT
COL 0 0 0
#
ERANGE 1 1 100 100
EVAL X,2,**
#
XLABEL "X"
YLABEL "Y"
TITLE "X*+2"
GRID BOTH
XYLINE
#
OUTLINE DEV
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gr30001.eps}
  \caption{Graphs of functions calculated by the evaluator}
  \label{fig:gr30001}
\end{figure}

\newpara
The two commands that generate the data to be plotted are
\texttt{ERANGE} and \texttt{EVAL}. The \texttt{ERANGE} command defines a
range of X values for which the function is the be evaluated. In the
case given here, it is similar to the \textbf{NumPy} ``linspace'' function. The
first argument is the logarithm base, which, if 1, indicates we want to
sample a linear range. The next two values are the start and end X
values, and the final argument is the number of steps to take between
start and end. \texttt{ERANGE} puts its output in the X array, which is
also stack level 0.

\newpara
The RPN evaluator does not use the X array as a ``normal'' part of the
stack. It can be read via the \texttt{X} operator, which pushes its
contents on the stack. The X array can be written to by the
\texttt{SETX} operator. Otherwise, it is not accessed.

\newpara
The \texttt{EVAL} operator needs one argument (a second is optional)
which is an ``RPN string'' containing operators and operands for the
evaluator to \ldots er \ldots evaluate. It may be enclosed in double quotation
marks.

\newpara
Whatever the evaluator leaves in the stack level 1 or Y array can be
plotted against the X array contents using \texttt{XYLINE} or the other
graphing commands.

\newpara
To make the evaluator more useful, there are 9 ``procedure registers''
which can contain ``RPN strings''. These can be executed by the
evaluator using the notation:

\begin{lstlisting}
EVAL @1
EVAL @1,@3
\end{lstlisting}

\newpara
which ``calls'' one or more procedure register contents (sequentially).
The contents of a ``procedure register'' can be set with the
\texttt{PROC} command. They can also be set with the \texttt{LOADPROC}
command, which looks for a named procedure in the file \texttt{GPLPROC}
and loads it into a specified ``procedure register'' if it is found.

\newpara
Note that the \textbf{GPLOT} evaluator does not actually do a ``call and return''
when it sees \texttt{EVAL\ @1}, etc. Instead, it uses string
substitution to replace \texttt{@1} with the string in procedure
register 1. It does this repeatedly, if necessary, until there are no
remaining \texttt{@n} sequences in the substituted string.

\newpara
There are also 9 \emph{scalar} ``memory'' registers, which can be set
with the \texttt{STO} command and recalled with \texttt{RCL}. Often,
parameters for procedures are put into these registers with \texttt{STO}
then accessed in the RPN with the \texttt{RCL} or (as an abbreviation)
\texttt{\#}.

\newpara
To make evaluating procedures with parameters more straightforward, the
optional second argument to \texttt{EVAL} is a comma separated list of
numeric values to \texttt{STO} into consecutive scalar registers
(starting with the 1st) before running the RPN string. For example,

\begin{lstlisting}
EVAL @1 "1,2,3,4"
\end{lstlisting}

\newpara
would put 1 in scalar register 1, 2 in register 2, and so on, then
``call'' the procedure in ``procedure register'' 1.

\newpara
Finally, there are 9 ``string registers'' which can be set with
arbitrary strings (maximum 80 characters) using the \texttt{STRING}
command. These can then be used in an RPN procedure for plotting text.

\newpara
Returning to plotting simple functions, this script graphs a slightly
more complex function:

\begin{lstlisting}
CSG ALL
COL 0 0 0
WIDTH 1
CSG GENERAL
COL 0 0 1
WIDTH 2
#
ERANGE 1 0 13 801
EVAL X,TWPI,*,SIN,X,PI,2,SQRT,*,*,SIN,+
#
XLABEL "*LX (ARGUMENT)"
YLABEL "*LY (NEVER REPEATS)"
TITLE "*LY=SIN(2 PI X) + SIN(2*+*,1$,2$.$+ PI X)"
XYL
\end{lstlisting}

\newpara
This is plotted in the righthand sub-figure of Figure~\ref{fig:gr30001}.
This function is
mathematically interesting, as it never repeats (i.e.~its period is
infinite). This will not be the case when it is plotted on a digital
computer, though, as all numbers on such machines are rational, but the
period will be enormous.


\subsection{General drawing - Part 1: Basic functions}\label{general-drawing---part-1-basic-functions}

\newpara
\textbf{DIMFILM} provides some basic drawing capabilities apart from its
extensive graph plotting functionality. Graph plotting is based on these
lower level capabilities, as you would expect.

\newpara
There is a simple but sound foundation for general drawing with the
\texttt{BOUNDS} command, which establishes a user defined coordinate
system, the \texttt{PANE} command, which sets up a rectangle in bounds
coordinates outside of which no drawing will occur (a ``clip to inside''
region) and the \texttt{BLANK} command, which sets a rectangle inside of
which no drawing will occur (a ``clip to outside'' region). These
commands map directly to \textbf{DIMFILM} subroutines.

\newpara
For convenience, \textbf{GPLOT} adds a \texttt{CANVAS} command, which just sets
the bounds and the pane to the same coordinate ranges.

\newpara
All general purpose drawing uses the coordinates established by
\texttt{BOUNDS}. If no explicit \texttt{BOUNDS} command is given, this
defaults to 0 to 1 by 0 to 1, which will be a square region, centered in
the output device drawable rectangle. As noted above, to use the full
area of the output device, the aspect ratio of the bounds must match the
aspect ratio of the device. This can be done automatically for graph
plotting applications using \texttt{GRAPHMODE\ ON}, but you will
generally want to choose your own coordinate ranges for general drawing,
often bearing the device aspect ratio in mind when doing do.

\newpara
The low level drawing operations available are \texttt{MOVE} to move the
``current position'' to a specified coordinate, \texttt{DRAW} to draw
from the current postion to a new position (which becomes the current
position) in a straight line, \texttt{CIRCLE} which draw a circle of a
given radius at a given position, \texttt{ARC} which draws a segment of
a circle, and \texttt{RECT} which draws a rectangle.

\newpara
Two \textbf{GPLOT} commands build slightly on this: \texttt{CRECT} draws a
rectangle centered on a given location and \texttt{PATH} uses the
contents of the X and Y arrays to draw a polyline.

\newpara
Although \textbf{DIMFILM} does
not support the drawing of any kinds of smooth curves for general
drawing purposes (\texttt{INTERPOLATE} can interpolate smooth curves
between data points for graph plotting, but this can't be used for
general drawing), the latest version of \textbf{GPLOT} has two means
of drawing such things. One calculates a curve that passes through
a supplied set of points with the constraint the curve's first and
second derivatives are continuous. The second means draws a curve
defined by a cubic B\'{e}zier control polygon.

\newpara
\textbf{DIMFILM} has very limited geometric transformation support and \textbf{GPLOT} does
not provide access to this. \textbf{GPLOT} does provide a more comprehensive
geometric transformation capability through its RPN evaluator, though.

\newpara
While these graphics facilities are fairly basic, there is also a rather
comprehensive set of facilities for drawing text using vector fonts.
These are accessed through the \texttt{TEXT} and \texttt{CTEXT}
commands, with various properties set by the \texttt{SYMHT},
\texttt{SYMANG} and \texttt{FONT} commands. The fonts are specific to
\textbf{DIMFILM} (there is no way to use any ``system fonts''!) and are, in this
implementation, some of the Hershey fonts. The available fonts can be
listed with the \texttt{LISTFONT} command.

\newpara
Special ``marker'' characters can also be drawn using the
\texttt{MARKER} command with the optional 2nd argument set to
\texttt{YES}.

\newpara
The text output facility allows ``markup'' to be included in the string
to draw, and this extends to sub-scripts, super-scripts, and fractions,
which can be nested to two levels. Mathematical notation can, to a
useful degree, be accommodated by this. Although we have high quality
font drawing everywhere now (and for the last few decades), when \textbf{DIMFILM}
was first released (1973), this was cutting edge. Mathematical notation
is still not readily expressible everywhere it might be useful even
today, in fact.

\newpara
An example which shows most of the basic drawing operations in action
is Figure~\ref{fig:gd01001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gd01001.eps}
  \caption{Basic drawing functions}
  \label{fig:gd01001}
\end{figure}

\newpara
The script for this is a little long, but may be worth presenting in
full:

\begin{lstlisting}
RESET
CANVAS 0 22 0 16
#
CSG TEXT
COL 0 0 0
CSG GEN
COL 0 0 0
#
# DRAW CIRCLES
CIRCLE 3 3 1
STYLE DASH
CIRCLE 19 3 1
STYLE DOT
COL 0 0 1
CIRCLE 19 13 1
STYLE DASHDOT
COL 1 0 0
CIRCLE 3 13 1
STYLE SOLID
COL 0 0 0
#
# DRAW ANGLE
MOVE 7 9
DRAW 10 9
MOVE 7 9
DRAW 9.5981 10.5
ARC 7 9 2 0 30
MOVE 9.45 9.5
SYMHT 0.5
TEXT "*:83=30"
#
# DRAW CENTER CROSS + MARKERS
COL 1 0 0
MOVE 2 8
DRAW 20 8
MOVE 11 2
DRAW 11 14
MOVE 11 8
COL 0 0 0
MARKER 9 Y
MARKER 23 Y
#
# DRAW CIRCLE CROSSES AND MARKERS
MOVE 1 13
DRAW 5 13
MOVE 3 11
DRAW 3 15
SYMHT 3
MOVE 3 13
MARKER 9 Y
#
MOVE 17 13
DRAW 21 13
MOVE 19 11
DRAW 19 15
MOVE 19 13
MARKER 24 Y
#
MOVE 1 3
DRAW 5 3
MOVE 3 1
DRAW 3 5
MOVE 3 3
MARKER 13 Y
#
MOVE 17 3
DRAW 21 3
MOVE 19 1
DRAW 19 5
MOVE 19 3
MARKER 3 Y
#
# DRAW ROUND CORNER RECTANGLE
WIDTH 3
ARC 7 6 1 180 270
ARC 15 6 1 270 360
ARC 7 10 1 90 180
ARC 15 10 1 0 90
MOVE 6 6
DRAW 6 10
MOVE 16 6
DRAW 16 10
MOVE 7 5
DRAW 15 5
MOVE 15 11
DRAW 7 11
WIDTH 1
#
# ODDITIES
MOVE 7 7
DRAW 8 6
DRAW 9 7
DRAW 10 6
#
MOVE 12 9
DRAW 13 10
DRAW 14 9
DRAW 15 10
#
READ HERE 1 2
12 6
14 6
15 7
12 7
EOF
PATH C
#
SYMHT 0.5
MOVE 11 15
CTEXT 0 "*=G*LENERAL DRAWING BASIC COMMANDS EXAMPLE$="
MOVE 11 1
CTEXT 12 "MOVE, DRAW, CIRCLE, ARC, MARKER, TEXT, CTEXT, PATH"
#
CSG GEN
COL 0 0 1
OUTLINE BOUNDS
OUTLINE DEV
\end{lstlisting}

\newpara
Most of this is likely to be self explanatory. The only points that may
be unclear are:

\begin{itemize}
\item
  The use of a ``special character'' from the symbol font (which is
  loaded with \texttt{MATH.SMALL} by default) to draw the ``theta''
  character. This is done by: \texttt{TEXT\ "*:83=30"} where the
  ``theta'' is selected by character number (83) using string markup.
  How do we know which character number to use? By looking at ``font
  tables'' which can be generated with one of the supplied script files
  (\texttt{obfont} for ``normal'' alphabets, \texttt{obsyms} for symbols
  and \texttt{obmarks} for markers). This is explained further in a
  later section (below).
\item
  The \texttt{MARKER} command, which will draw a specified marker (which
  is determined by a number) at the current position \emph{if} a second
  argument (\texttt{YES} - abbreviated, any case) is supplied. If only
  one argument is supplied, the \texttt{MARKER} command sets the marker
  number to use for points when plotting graphs.
\item
  Polyline paths can be drawn with the \texttt{PATH} command with
  coordinates defined by a \texttt{HERE} file. This is quite a
  convenient way of setting up a path, actually. The path may be open
  or closed depending on the argument to \texttt{PATH} which may be
  \texttt{C} for closed or \texttt{O} for open.
\end{itemize}

\newpara
While you can draw a lot with these basic drawing commands, it can get
pretty tedious and long winded. Some of that is inevitable, but some
things could be ``automated''. In this case, the end coordinate for the
non-horizontal ``angle'' line has to be set by
\texttt{DRAW\ 9.5981\ 10.5} where those numbers were found by hand with a
calculator! This is the sort of thing a computer ought to be able to do
for you!

\newpara
To help with this, in addition to simple evaluation of
\texttt{y\ =\ f(x)} functions, the ``evaluator'' was added.


\subsection{The RPN Evaluator for drawing 2D parametric functions}\label{the-rpn-evaluator-for-drawing-2d-parametric-functions}
\newpara
Bridging the graph plotting and general drawing worlds is drawing
functions of a parameter, \texttt{t}, that trace out a path on the 2D
plane. These are of the form:

\begin{lstlisting}
x = f(t)
y = g(t)
\end{lstlisting}

\newpara
Such functions can generate very pleasing patterns and often appear in
``recreational mathematics''. Some of the most familiar examples are the
curves generated by the ``Spirograph'' ``toy'' (see this
\href{https://en.wikipedia.org/wiki/Spirograph}{Wikipedia article}),
which we will come to shortly.

\newpara
As a simpler example (from the point of view of \textbf{GPLOT} only!) we start
with the ``Farris mystery curve''. The ``mystery'' is that a five-fold
symmetry appears from formulae which contain mostly even numbers and no obvious
source of such a symmetry.

\newpara
While ``Spirograph'' uses two wheels, with one rotating in slip-free
contact with the other, the Farris curves (many variations are possible)
can be generated with three wheels in slip-free contact.

\newpara
Figure~\ref{fig:g1fm001} shows the ``original'' mystery curve.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/g1fm001.eps}
  \caption{The Farris Mystery Curve}
  \label{fig:g1fm001}
\end{figure}

\begin{lstlisting}
# FARRIS MYSTERY CURVE
#
RESET
CANVAS -2 2 -2 2
#
MAXPOINTS 3000
#
EVAL 0,TWPI,2001,XLIN
PROC 2 X,SIN,X,6,*,SIN,2,/,+,X,14,*,COS,3,/,+
PROC 1 X,COS,X,6,*,COS,2,/,+,X,14,*,SIN,3,/,+
EVAL @1,@2,PTHO
#
CSG ALL
COL 0 0 0
MOVE 0  -1.66
CTEXT 1.3 "*LX = COS(T) + *,COS(6T)$,2$. + *,SIN(14T)$,3$." 
MOVE 0  -1.9
CTEXT 1.3 "*LY = SIN(T) + *,SIN(6T)$,2$. + *,COS(14T)$,3$." 
MOVE 0, 1.9
CTEXT 2 "*IF*LARRIS MYSTERY CURVE"
#
OUTLINE BOUNDS
\end{lstlisting}

\newpara
The script that generates this is quite short and simple. The first
\texttt{EVAL} fills the X array (stack level 0) with 0 to 2 pi in 2001
linear steps. Two procedures are then defined (stored in procedure
registers 1 and 2). \texttt{PROC\ 1} calculates X values and
\texttt{PROC\ 2} finds Y values. The second \texttt{EVAL} evaluates
these two procedures in the order that leaves the calculated coordinates
on stack for use by the path drawing operator \texttt{PTHO}.

\newpara
It is easy to plot this curve as a graph (i.e.~with value labelled axes,
etc.) simply by replacing \texttt{PTHO} with operators that set the
calculated X and Y values into the X and Y arrays (stack levels 0 and 1)
used by graph plotting commands (here \texttt{XYLINE}). This is
shown in Figure~\ref{fig:g2fm001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/g2fm001.eps}
  \caption{The Farris Mystery Curve graphed}
  \label{fig:g2fm001}
\end{figure}

\begin{lstlisting}
# FARRIS MYSTERY CURVE PLOTTED AS A GRAPH.
#
CANVAS -2 2 -2 2
#
MAXPOINTS 3000
CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0 1
CSG GEN
COL 1 0 0
#
EVAL 0,TWPI,2001,XLIN
PROC 2 X,SIN,X,6,*,SIN,2,/,+,X,14,*,COS,3,/,+
PROC 1 X,COS,X,6,*,COS,2,/,+,X,14,*,SIN,3,/,+
EVAL @1,@2,SETX,POP,SETY
GRAPHMODE OFF
TITLE "T*LHE *UF*LARRIS MYSTERY CURVE GRAPHED"
XLABEL "*LX = COS(T) + *,COS(6T)$,2$. + *,SIN(14T)$,3$."
YLABEL "*LY = SIN(T) + *,SIN(6T)$,2$. + *,COS(14T)$,3$."
GRID BOTH
XYLINE
\end{lstlisting}

\newpara
The Spirograph is a toy invented by Denys Fisher in 1962-64 and fondly
remembered by people of a certain age. It is a simple mechanism which
can trace out hypotrochoid and epitrochoid curves based on two wheels
(with gear teeth, so they can stay in contact without slipping). One
wheel is fixed and the other rotates on the inside or outside of the
fixed wheel. This second wheel has holes in which the tip of a pen can
be placed to draw curves. If the moving wheel rotates inside the fixed
wheel, a hypotrochoid curve is traced out, and if it is outside, an
epitrochoid curve is drawn.

\newpara
Much less accessible mechanisms were developed in the 19th century to
draw such curves for use in banknote engraving as they are visually
attractive and are (or were) difficult to forge without specialised
machinery.

\newpara
Drawing these curves with \textbf{GPLOT} is an interesting exercise. They can be
defined with three integer parameters:

\begin{itemize}
\item
  \texttt{R}, the radius of the fixed wheel.
\item
  \texttt{RL}, the radius of the smaller, moving, wheel.
\item
  \texttt{P}, the distance of the ``pen hole'' from the centre of the
  moving wheel.
\end{itemize}

\newpara
We want to be able to change these easily, so we want to define a script
that we can call like this:

\begin{lstlisting}
OB OBSPIRO "65 25 30"
\end{lstlisting}

\newpara
where we pass the values of \texttt{R}, \texttt{RL} and \texttt{P} to
the script. This is a good opportunity to show how to pass parameters to
scripts and to use ``nested scripts'' to reuse code in the way that
subroutines and functions allow in more sophisticated programming
environments.

\newpara
The script \texttt{OBSPIRO} uses these parameters to calculate how many
times the moving wheel needs to circle the fixed wheel to complete a
closed curve, as well as the degree of symmetry of the curve. Note that
the parameters passed to the script are referred to as \texttt{\$1},
\texttt{\$2}, etc. as they are in Unix scripting languages. Note also
that it is possible to use parameters in the RPN strings used by
\texttt{EVAL}. This can be very useful.

\newpara
One ``problem'' with the parametrised Spirograph simulation is that we
don't know how big the pattern will be -- i.e.~what the range of
coordinates will be -- so we can't easily set the \texttt{BOUNDS} for
the drawing.

\newpara
The \texttt{OBSPIRO} script deals with this using the \texttt{BBSTART},
\texttt{BBEND} and \texttt{BBSET} commands. Between \texttt{BBSTART} and
\texttt{BBEND}, the \texttt{DRAW} command doesn't draw anything (all
drawing ultimately comes down to \texttt{MOVE} and \texttt{DRAW}).
Instead, the range of \texttt{X} and \texttt{Y} coordinates is
accumulated. \texttt{BBSET} can then be used to set these accumulated
ranges as the \texttt{BOUNDS}, optionally scaled about the center by a
scale factor (here, \texttt{1.2}).

\newpara
The tracing out of the Spirograph is done by the script
\texttt{OBSPIRC}, which \texttt{OBSPIRO} ``calls'' twice: once to find
the pattern's bounds and once to draw the pattern.

\newpara
In general, parameters can be passed to obey scripts in two ways:
\begin{itemize}
\item
  Using parameters as described above, where, for example,
  \texttt{OB\ X\ "1\ 2\ 3"} results in \texttt{\$1}, \texttt{\$2} and
  \texttt{\$3} in the script \texttt{X} being read as \texttt{1},
  \texttt{2} and \texttt{3} as a result of \emph{text (string)
  substitution}.
\item
  Numerical values and strings can be passed through registers. This is
  necessary if values are calculated by \texttt{EVAL} to be used in a
  ``nested'' script.
\end{itemize}

\newpara
The \texttt{OBSPIRO} script demonstrates all these features.

\begin{lstlisting}
# SPIROGRAPH PATTERNS - OBSPIRO
#
# FOR MORE INFORMATION, SEE:
#   HTTPS://LINUXGAZETTE.NET/133/LUANA.HTML
#   HTTPS://APERIODICAL.COM/2021/12/THE-MATHEMATICS-OF-SPIROGRAPH/
#
RESET

# THE CONTROL PARAMETERS SHOULD ALL BE INTEGERS.
#
# $1 = R = BIG CIRCLE RADIUS
# $2 = RL = LITTLE CIRCLE RADIUS (MOVES AROUND BIG CIRCLE, IN CONTACT)
# $3 = P = LITTLE CIRCLE PEN RADIUS (FROM CENTRE OF LITTLE CIRCLE)

# THE DEGREE OF SYMMETRY OF THE PATTERN IS MAX(R/GCD(R,RL),RL/GCD(R,RL))

# THE NUMBER OF REVOLUTIONS AROUND THE BIG CIRCLE NEEDED TO JOIN
# UP TO THE START OF THE PATTERN IS:
# NR = RL / GCD(R,RL) (GCD=GREATEST COMMON DIVISOR)

# THE PARAMETER RANGE NEEDED TO DRAW THE THING IS THEN:
# T = [0:2*PI*NR]
#
# AND:
# X(T) = COS(T) * (R - RL) + COS(((R - RL) / RL) * T) * P
# Y(T) = SIN(T) * (R - RL) - SIN(((R - RL) / RL) * T) * P

# CALCULATE NR AND STORE IN REG 9. SAVE GCD(R,RL) IN REG 8.
# NOTE THE DOUBLE QUOTES ARE NEEDED FOR PARAMETER SUBSTITUTION TO WORK
EVAL "$2,$1,$2,GCD,8,=,/,9,="

# FIND THE DEGREE OF SYMMETRY. STORE IN REG 8.
EVAL "$1,8,#,/,$2,8,#,/,MAX,8,="

# FIND THE BOUNDING BOX AND SET BOUNDS.
BBSTART
OB OBSPIRC "$1 $2 $3"
BBEND
BBSET 1.2

# DRAW THE SPIROGRAPH
CSG GENERAL
COL 1 0 0
WIDTH 2
OB OBSPIRC "$1 $2 $3"

# DRAW ANNOTATION (OR NOT)
# CSG GENERAL
# COL 0 0 1
# WIDTH 2
# CIRCLE 0 0 $1
# EVAL "$1,$2,-,0,$2,C"
# EVAL "$1,$2,-,$3,+,0,$3,20,/,C"
# EVAL "$1,0,M,$1,$3,+,$2,-,$3,20,/,-,0,D"

# ADD A PARAMETER DISPLAY
CSG TEXT
COL 0 0 0
BOUNDS 0 1 0 1
MOVE 0.05 0.05
SYMHT 0.02
TEXT "R=$1, *LR=$2, P=$3"
STRING 9 "S*LYMMETRY="
STRING 8 "(I2)"
EVAL "0.05,0.1,M,9,T,TSC,8,#,8,TVI,TEC"
FONT 2 SCRIPT.SIMPLEX
MOVE 0.8 0.95
SYMHT 0.07
CTEXT 0 "*2S*LPIROGRAPH!"
FONT 2 SERIF.COMPLEX

CSG GEN
COL 0 0 0
OUTLINE BOUNDS
\end{lstlisting}

\newpara
The \texttt{OBSPIRC} script does the actual work of calculating pattern
coordinates and drawing the result.

\begin{lstlisting} 
# SPIROGRAPH PATTERN CORE - OBSPIRC

# $1 = R = BIG CIRCLE RADIUS
# $2 = RL = LITTLE CIRCLE RADIUS (MOVES AROUND BIG CIRCLE, IN CONTACT)
# $3 = P = LITTLE CIRCLE PEN RADIUS (FROM CENTRE OF LITTLE CIRCLE)
# REG 9 = NR = NUMBER OF REVOLUTIONS AROUND BIG CIRCLE
#
# T = [0:2*PI*NR]
#
# X(T) = COS(T) * (R - RL) + COS(((R - RL) / RL) * T) * P
# Y(T) = SIN(T) * (R - RL) - SIN(((R - RL) / RL) * T) * P

STO 1 $1
STO 2 $2
STO 3 $3
MAXPOINTS 3000

ERANGE 1 0 6.28 2001
EVAL 0,TWPI,2001,XLIN,X,9,RCL,*,SETX
EVAL 1,RCL,2,RCL,-,5,STO  ; [5] = R - RL
EVAL 5,RCL,2,RCL,/,6,STO  ; [6] = (R - RL)  / RL
PROC 1 X,COS,5,RCL,*,6,RCL,X,*,COS,3,RCL,*,+ ; X
PROC 2 X,SIN,5,RCL,*,6,RCL,X,*,SIN,3,RCL,*,- ; Y
EVAL @1,@2,PTHO
\end{lstlisting}

\newpara
This is quite similar to the ``Farris Mystery Curve'' script in its
approach. Note that it stores the parameters it receives in registers
for use in the RPN, although direct substitution could be used. It first
generates an angle parameter at 2001 points that ``goes around'' the
required number of times to generate a closed pattern, then it finds the
path coordinates based on the angle and draws the result with the open
path operator, \texttt{PTHO}.

\newpara
Figures\ref{fig:g1sp001}, \ref{fig:g2sp001} and \ref{fig:g3sp001} are some examples
of the output of \texttt{OBSPIRO} with different
parameter sets.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/g1sp001.eps}
  \caption{Spirograph Example 1}
  \label{fig:g1sp001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/g2sp001.eps}
  \caption{Spirograph Example 2}
  \label{fig:g2sp001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/g3sp001.eps}
  \caption{Spirograph Example 3}
  \label{fig:g3sp001}
\end{figure}

\newpara
Still sticking with procedurally generated patterns, but moving away
from traditional continuous functions of a variable, there is a
traditional form of Japanese Sashiko stitching called Hitomezashi,
developed in the Edo period.

\newpara
These stitch patterns consist of short stitches of a single unit length,
made either horizontally or vertically. If two random sequences of
length \texttt{N} are generated, one for the horizontal direction and
another for the vertical, and a stitch is made if the value of the
sequence is odd (and not made if it is even) then a very attractive
pattern results.

\newpara
I came across this thanks to this
\href{https://www.youtube.com/watch?v=JbfhzlMk2eY}{Numberphile}, video
on YouTube, which gives an excellent explanation of things.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gemz001.eps}
  \caption{A Hitomezashi stitch pattern}
  \label{fig:gemz001}
\end{figure}

\newpara
The following obey script draws such patterns:

\begin{lstlisting}
# GENERATE HITOMEZASHI STITCH PATTERNS
#
RESET
CANVAS 0 41 0 41
BLANK 30.5 40.5 37.5 40.5

ERANGE 1 0 40 41
PROC 1 1,RAND,0.5,+,FLR,1,EL,X,+,ODD
EVAL 333,SEED

CSG GEN
COL 0 0 1
WIDTH 3
ITEVAL 0 40 1 0,I,M,@1,HDSH
ITEVAL 0 40 1 I,0,M,@1,VDSH

CSG ANNOT
COL 1 0 0
WIDTH 5
OUTLINE BLANK

UNBLANK
MOVE 35.5 39
CSG TEXT
COL 0 0 0
WIDTH 1
CTEXT 9 "H*LITOMEZASHI"

OUTLINE DEV
\end{lstlisting}

\newpara
This introduces a new version of \texttt{EVAL} -- iterated evaluation or
\texttt{ITEVAL}. This repeatedly runs an RPN procedure with a ``loop
variable'' that iterates from a start value to a stop value (inclusive --
Fortran DO-loop rules apply) by a step value. The ``loop variable''
value can be accessed inside the RPN using the \texttt{I} operator.

\newpara
This example also shows how to use \texttt{BLANK} and \texttt{UNBLANK}
to temporarily protect a rectangular region so that it cannot be drawn
in.


\subsection{General drawing - Part 2: Evaluator assisted}\label{general-drawing---part-2-evaluator-assisted}

\newpara
It is possible to use the evaluator to assist with general drawing
tasks. In many cases, it is necessary to calculate coordinates from a
small set of supplied parameters in order to complete the drawing task.
A good example of this was the ``labelled angle line pair'' shown in the
manual general drawing section, where we used a calculator to find the
coordinates of the label text literally by hand.

\newpara
Probably the most convenient way of using the evaluator for such tasks
is to add procedures to the \emph{evaluator procedure library} which
consists of the file \texttt{GPLPROC} (\texttt{gplproc} on Unix-like
systems, with any specified \texttt{PREFIX} prepended).

\newpara
The procedures in this library are, to some extent, a way to extend
\textbf{GPLOT's} capabilities, or, at least, make some things much more
convenient than they otherwise would be.

\newpara
The contents of \texttt{GPLPROC} include comments that document its
procedures. Please read it for full information. To understand its
features, here are a couple of examples.

\newpara
This \texttt{RELLIPSE} procedure draws an ellipse (which \textbf{GPLOT/DIMFILM}
cannot do directly). It has five parameters, the center position
\texttt{(XC,YC)}, the semi-major and semi-minor axis lengths and a
rotation angle (a rotation of the ellipse axes).

\begin{lstlisting}
C A ROTATED ELLIPSE "XC YC A B ANGLE-DEGREES"
RELLIPSE
CL,0,TWPI,360,XLIN,X,&,COS,S,SIN,3,#,4,#,SCL,5,#,D2R,ROT,1,#,2,#,TRN,PTHC
\end{lstlisting}

\newpara
To use this procedure to draw a rotated ellipse, two \textbf{GPLOT} commands are
needed:

\begin{lstlisting}
LOAD 1 RELLIPSE
EVAL @1 "5,1,0.5,0.9,33"
\end{lstlisting}

\newpara
The first line loads the required procedure into a procedure register (1
here), then the second executes it, passing it the required arguments.
If a given procedure is to be ``called'' multiple times, it need only be
loaded once, of course.

\newpara
The second example shows a useful feature unique to \texttt{GPLPROC}. A
major limitation of the evaluator is that RPN strings are limited to 80
characters. This is not enough for many ``real world'' applications.
When a procedure is loaded from \texttt{GPLPROC}, it can span multiple
lines. In such a case, the procedure is loaded into multiple successive
procedure registers and \texttt{,@n} sequences are automatically added
to line ends so that the when the procedure is called from an
\texttt{EVAL} command, a single long procedure is assembled and
executed. A side effect of this scheme is that lines can be no more than
77 characters long if another line follows in the procedure definition.

\begin{lstlisting}
C GEAR "X Y R1 R2 N-TEETH ROT-DEGREES"
GEAR 2
CL,0,5,#,&,1,+,XLIN,3,#,4,#,X,2,/,ODD,SEL,X,TWPI,*,5,#,/,6,#,D2R,+,&
COS,S,SIN,3,G,*,S,3,G,*,1,#,2,#,TRN,PTHO
\end{lstlisting}

\newpara
Note that the number of lines in the full procedure (2 here) must be
given after the procedure name. These procedures must be loaded into a
procedure register number that leaves enough successive registers to
hold the full thing. Here, for example, \texttt{LOAD\ 8\ GEAR} would
work, but \texttt{LOAD\ 9\ GEAR} would not.

\newpara
The script \texttt{OBPRTST} calls every procedure currently defined in
\texttt{GPLPROC} as shipped. The output of that is shown in
Figure~\ref{fig:gdea001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gdea001.eps}
  \caption{Examples of each procedure in \texttt{GPLPROC}}
  \label{fig:gdea001}
\end{figure}

\newpara
It is intended that \textbf{GPLOT} users add their own procedures to
\texttt{GPLPROC} to ``extend'' \textbf{GPLOT} to do things they want to do.

\subsection{General drawing - Part 3: Higher level drawing}\label{general-drawing---part-3-higher-level-drawing}

\newpara
Although the evaluator can ``extend'' the capabilities of \textbf{GPLOT} to some
extent, it has some pretty severe limitations and inconveniences. The
main limitations are the maximum size of procedures and the complete
lack of branching and looping features. In practice, you cannot ``draw
anything'' with \textbf{GPLOT/DIMFILM} in the way that you can with PostScript,
for example.

\newpara
There are some drawing operations beyond the (very) basic facilities
described above which are sufficiently generally useful to ``build in''
to \textbf{GPLOT}. This hopefully makes it relatively easy to draw things that
are commonly useful (easier than using PostScript, for example), while
acknowledging that there are still fundamental limitations to what can
be drawn.

\newpara
To this end, \textbf{GPLOT} has three ``higher level'' drawing ``primitives'':

\begin{itemize}
\item
  Decorated lines
\item
  Boxed text
\item
  Labels with pointing arrows.
\end{itemize}

\newpara
These can be used for a broad range of diagrams, but especially block
diagrams.

\newpara
A \textbf{decorated line} is a series of connected and directed line
segments, the ends of which may have:

\begin{itemize}
\item
  Arrow heads. These will automatically point in the correct direction
  (hopefully).
\item
  ``Half skips''. These are (close to) quarter circles, and if a line
  ends and begins with one of these, it can give the appearence of
  skipping over another line, as was commonly seen in older circuit
  diagrams.
\item
  No decorations or ``plain''.
\end{itemize}

\newpara
Such a line is drawn by the \texttt{LINE} command which takes a string
that defines the line segments and their decorations. Each coordinate or
\emph{point description} defining a ``vertex'' in the ``polyline'' has
the following components:

\begin{lstlisting}
<decoration>x,y[,<annotation_string>]

<decoration> = P (plain) or A (arrow) or S (half skip)

<annotation_string> is a short string (currently limited to 5 characters).
It may contain \textbf{DIMFILM} string markup. It cannot contain spaces.
\end{lstlisting}

\newpara
The annotation string, if supplied, will be drawn in a circle at the
mid-point of the line segment ended by the point description that
specifies it. This is intended to be a \emph{very short} label.

\newpara
The point descriptions are separated by \texttt{"\textgreater{}"}
characters, which can be read in this context as ``to''.

\newpara
Here is an example that defines a two segment decorated line, starting
with no decoration and ending in an arrow head with a label,
\texttt{"Le"}, in the middle of the first of the two line segments:

\begin{lstlisting}
LINE P7,6>P7,21,L*LE>A16,21
\end{lstlisting}

\newpara
Additional characteristics of decorated lines are specified by the
\texttt{ARROWPARM} and \texttt{LINEPARM} commands. The latter sets scale
factors for drawing skips and annotations, while the former sets the
type, size and appearance of arrow heads. Note that the width and colour
of decorated lines are set in the usual way (lines, arrows and skips are
in \texttt{CSG\ GENERAL}, annotation text in \texttt{CSG\ TEXT}).

\newpara
\textbf{Boxed text} is intended to be a fairly flexible component for
constructing block diagrams, tables and many other drawings. The element
is basically text centered in a box of a specified size at a specified
position (given either by centre or bottom left).

\newpara
A number of other features can be added, though.

\begin{itemize}
\item
  The inside of the box can be ``filled'' with hatched lines.
\item
  A second box, inside the first and surrounding the text, can be drawn.
  It is a \texttt{BLANK} region, and it can be outlined.
\item
  The text may have multiple lines (up to 5), separated by backslashes.
\item
  The text may be centered or left justified.
\item
  The text can contain \textbf{DIMFILM} string markup.
\item
  The position of the boxed text can be automatically ``stepped'' by
  specified X and Y ``deltas'' after eah one is drawn. This makes it
  much easier to use this for constructing tables and other things.
\end{itemize}

\newpara
The main command for this element is \texttt{BOXTEXT}, which draws a
given text string at a position given by either a supplied coordinate,
or, if the coordinate is omitted, at the position of the last
\texttt{BOXTEXT} incremented by previously specified deltas.

\newpara
A number of secondary commands set current characteristics of
\texttt{BOXTEXT}. These are:

\begin{itemize}
\item
  \texttt{BOXPSIZE} which sets the box size and how the position
  coordinate is to be interpreted.
\item
  \texttt{BOXPHATCH} which sets the hatching parameters (or turns it
  off).
\item
  \texttt{BOXPTEXT} which sets how text is drawn inside the box. There
  are two distinct modes: \texttt{FIX} and \texttt{SCALE}. In
  \texttt{FIX} mode, the \texttt{WIDTHSCALE} parameter sets how many
  lines will fit in the box height, while in \texttt{SCALE} mode, it
  sets the fraction of the box width the text should be scaled to fill.
\item
  \texttt{BOXPBOX} which controls whether the outer and inner boxes are
  outlined.
\item
  \texttt{BOXPDELTAS} which sets the automatic position step after each
  \texttt{BOXTEXT} is drawn.
\end{itemize}

\newpara
\textbf{Labels} are the same graphical entities used to label points on
a graph, but the coordinates of the thing they point at is in bounds
rather than graph coordinates.

\newpara
Figure~\ref{fig:gh1b001} is a simple example of how
these facilities can be used to draw a
small block diagram.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gh1b001.eps}
  \caption{A simple block diagram}
  \label{fig:gh1b001}
\end{figure}

\begin{lstlisting}
RESET
BOUNDS 0 42 0 26

CSG TEXT
COL 0 0 0
CSG ANNOT
COL 0 0 0
WID 2

BOXPSIZE 10 6 NO

BOXT "B*LOX 1" 7 3
BOXT "B*LOX 2" 21 3
BOXT "C*LURIOUS\*UB*LOX 3" 35 3

BOXT "B*LOX 4" 35 13

BOXPHATCH 0.05 8 HORIZ
BOXPBOX BOTH
BOXT "B*LOX 5\*UA*LN ODDITY" 21 21

CSG GEN
COL 0 0 0
ARROWPARM BARBED 0.8 2 0.3
LINEPARM 0.5 1.5
LINE P12,3>A16,3
LINE P26,3>A30,3
LINE P35,6>A35,10
LINE A35,16>P35,21,R*LT>A26,21
LINE P7,6>P7,21,L*LE>A16,21

LINE P12.5,12.5>P13.2,12.5>A14.1,14.1
ALABEL 13.2 12.5 2 300 "What is this thing?"

OUTLINE DEVICE
\end{lstlisting}

\newpara
It may look painful to create a diagram such as this by entering
coordinates, and perhaps it is. However, it may be less painful than it
seems at first. A key simplification is to use an integer coordinate
system with the box size a useful multiple of the unit size (e.g.~so
that middle of the box edges is easy to find). It is also helpful to
have a grid printed out (!) with the coordinate system shown over a
specified range (\texttt{BOUNDS}). As an aid to this, the script
\texttt{OBGRID} can draw such a grid which can be used as the background
of the diagram as it is developed (e.g.~using the \textbf{GTerm} device)
or printed to help sketch out the diagram.
An example of the use of a grid is shown in Figure~\ref{fig:ghbb001}.

\newpara
Surely it would be easier to just use, say, Inkscape? Perhaps. I have
drawn many block diagrams with Inkscape and in some ways it is obviously
easier. But it still takes longer than might be expected to get to a
``final'' result. It is also very difficult (at least for me) to get
lines and boxes to ``snap'' together precisely (I usually give up on
perfecting this, to be honest). The \textbf{GPLOT} approach at least results in
exact alignment of all elements! In summary, I'm not sure it is all that
more time consuming to get to an acceptable result. Which approach you
prefer (using a mouse and relying on hand/eye coordination or working
out and typing in coordinates) is a matter of personal taste. Obviously,
if you want to draw a portrait of your dog, Inkscape (or a similar
program) is the only sane choice! For more exactly defined tasks, a
``language based'' approach can make sense, as proved by the success of
vector graphics description languages such as PGF/Tikz.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/ghbb001.eps}
  \caption{Using a grid to assist with planning a block diagram}
  \label{fig:ghbb001}
\end{figure}

\begin{lstlisting}
#
# DRAW A GRID WITH NUMBERED AXES. USEFUL FOR BLOCK DIAGRAMS.
# CALL WITH BOUNDS AS PARAMETERS.
#
BOUNDS $1 $2 $3 $4
CSG ALL
COL 0.8 0.8 0.8
STRING 9 "(I2)"
ITEVAL $3 $4 1 "$1,I,M,$2,I,D"
ITEVAL $1 $2 1 "I,$3,M,I,$4,D"
ITEVAL $3 $4 1 "$4,$3,-,100,/,TH,$1,I,M,I,9,TVI"
ITEVAL $1 $2 1 "$4,$3,-,100,/,TH,I,$3,0.5,+,M,I,9,TVI"
\end{lstlisting}

\newpara
For a more sophisticated example of a block diagram drawn with \textbf{GPLOT},
look at the script \texttt{OBMODIO} which draws the block diagram at the
top of the Github \texttt{README.md} document showing
the component parts of the Git-MODIFY
inter-operability scheme. This is shown in Figure~\ref{fig:iocd001}.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/iocd001.eps}
  \caption{Git-MODIFY Inter-operability scheme components diagram}
  \label{fig:iocd001}
\end{figure}

\newpara
An example of using \textbf{GPLOT} (primarily \texttt{BOXTEXT}) to produce a
drawing other than a block diagram is shown below. This documents the
key bindings for the NOS 2 Full Screen Editor with a Macbook laptop
keyboard.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/gh2b001.eps}
  \caption{A diagram showing the key layout for FSE on a MacBook}
  \label{fig:gh2b001}
\end{figure}

\newpara
Further examples of how the ``higher level drawing'' features can be
used can be seen in the \texttt{OBCHT1} and \texttt{OBCHT2} scripts
which generate the \textbf{GPLOT} ``cheat sheet'' which can be found at the end
of this document.

\subsection{General drawing - Part 4: Smooth curves}\label{smooth-label}

\newpara
It is nice to be able to draw smooth curves in some cases, but \textbf{DIMFILM} itself has
no facilities for this (except for interpolating points on graphs for data with
monotonically increasing X).

\newpara
Late in the day (V0.90), \textbf{GPLOT} added smooth curve drawing features. These are based
on cubic B\'{e}zier curves. 

\newpara
Given that \textbf{GPLOT} is a text command based system, it isn't possible to interactively
adjust ``handles'' on B\'{e}zier curves to get the shape you want. This is one reason smooth
curves were omitted for a long time.

\newpara
To help avoid this problem, one of the two smooth curve facilities generates a curve
that passes \textit{through} the points supplied. Internally, a B\'{e}zier curve is used, but the
``handle'' points (through which the curve does \textit{not} pass) are calculated ``behind the scenes''
so that the curve has continuous first and second derivatives -- i.e. it is really
smooth!

\newpara
The points through which the curve passes are supplied in the same way as for plotting
graphs and for the \texttt{PATH} command.

\newpara
This script is a very simple example of the \texttt{CURVE} command with the open and closed
boundary options. The points specified are shown with point markers so you can see the
curve passes through them.

\begin{lstlisting}
RESET
#
BOUNDS -1 5 -1 4
OB OBGRID "-1 5 -1 4"
#
READ HERE 1 2
0.0 1.0
3.0 1.0
2.0 3.0
1.5 0.0
EOF
# - DRAW POINT MARKERS
STRING 1 "(I2)"
COL 1 0 0
2DITEVAL 1 4 1 "X,I,EL,3,G,I,EL,3,G,S,0.3,TH,M,7,MK,I,1,TVI"
# - OPEN CURVE
COL 1 0 1
CURVE O
# - CLOSED CURVE
COL 0 0 1
CURVE C
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/scsc001.eps}
  \caption{Example of open and closed \texttt{CURVE} commands}
  \label{fig:scsc001}
\end{figure}

\newpara
The way the markers are drawn introduces a new way of calling the evaluator. The
\texttt{2DITEVAL} command works in the same way as the \texttt{ITEVAL} command, but preserves the
contents of the second stack level which contains Y coordinates when data is \texttt{READ}.

\newpara
In some cases, though, a perfectly smooth curve is not what is wanted. For this reason,
a ``plain'' B\'{e}zier curve drawing command is also supplied. This takes a B\'{e}zier control
polygon from the usual X and Y arrays. The curve will pass through every third point
in the coordinate arrays. The two intermediate points are locations that ``attract'' the
curve to them and are the points that are adjusted using ``handles'' in interactive systems.
Many textbooks and online educational materials can be consulted for more details if
desired. Note that the curve will only be ``smooth'' if the points before and after a
point through which the curve passes, and that point, all lie on a straight line. Otherwise,
more or less ``sharp'' changes in direction will occur -- which may be what is desired.

\newpara
This script shows how to draw an open B\'{e}zier curve:
\begin{lstlisting}
RESET
#
BOUNDS -1 21 -1 9
OB OBGRID "-1 21 -1 9"
#
READ HERE 1 2
0 4
2 8
9 3
10 2
13 0
19 3
20 7
EOF
#
# DRAW THE CONTROL POLYGON
COL 0.4 0.4 0.4
PATH O
#
# DRAW THE CONTROL POINTS
STRING 1 "(I2)"
COL 1 0 0
2DITEVAL 1 7 1 "X,I,EL,3,G,I,EL,3,G,S,0.3,TH,M,7,MK,I,1,TVI"
#
# DRAW AN OPEN BEZIER CURVE USING THIS CONTROL POLYGON.
BEZIER O
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/scbo001.eps}
  \caption{Example of an open \texttt{BEZIER} curve}
  \label{fig:scbo001}
\end{figure}

\newpara
One thing which can be done with a \textit{closed} B\'{e}zier curve is to draw an
almost exact circle. This is an interesting test, in fact. A circle
drawing script is:
\begin{lstlisting}
RESET
#
BOUNDS -1.5 1.5 -1.5 1.5
OB OBGRID "-1.5 1.5 -1.5 1.5"
READ HERE 1 2
1 0
1 0.55228
0.55228 1
0 1
-0.55228 1
-1 0.55228
-1 0
-1 -0.55228
-0.55228 -1
0 -1
0.55228 -1
1 -0.55228
EOF
#
# DRAW THE CONTROL POINTS. WITH NUMERIC LABELS.
COL 1 0 0
STRING 1 "(I2)"
2DITEVAL 1 9 1 "X,I,EL,3,G,I,EL,3,G,S,0.2,TH,M,7,MK,0.1,TH,I,1,TVI"
STRING 1 "(I3)"
2DITEVAL 10 12 1 "X,I,EL,3,G,I,EL,3,G,S,0.2,TH,M,7,MK,0.1,TH,I,1,TVI"
#
# DRAW A CLOSED BEZIER CURVE THROUGH THESE POINTS. SHOULD BE A CIRCLE.
COL 0 0 1
BEZIER C
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/scbc001.eps}
  \caption{Example of a closed \texttt{BEZIER} curve}
  \label{fig:scbc001}
\end{figure}

\newpara
These smooth curve drawing facilities can also be accessed from the evaluator.
Four operators have been added: 

\begin{itemize}
\item \texttt{CRVO} draws an open smooth curve through the points in the top two stack levels.
\item \texttt{CRVC} draws a closed smooth curve through those points.
\item \texttt{BEZO} draws an open B\'{e}zier curve using the control polygon in the top two stack levels.
\item \texttt{BEZC} draws a closed B\'{e}zier curve.
\end{itemize}

\newpara
You must be careful with the number of points supplied to the \texttt{BEZO} and \texttt{BEZC} operators, as
valid control polygons must have a specific number of points. An open B\'{e}zier curve control
polygon must conform to $((N - 1) \mod 3) = 0$, where N is the number of supplied points. A
closed B\'{e}zier curve control polygon must conform to $(N \mod 3) = 0$.

\newpara
These constraints also apply to the \texttt{BEZIER} command.

\newpara
Here is a very simple script that shows these operators in use. This also used the \texttt{2DEVAL}
command to call the evaluator. Like \texttt{2DITEVAL}, this preserves the contents of the array
normally used to hold the \texttt{Y} values from a \texttt{READ} command.

\begin{lstlisting}
RESET
#
BOUNDS -1 5 -1 5
#
READ HERE 1 2
0 1
3 1
2 3
1.5 0
EOF
#
COL 1 0 0
2DEVAL "X,S,CRVC"
#
READ HERE 1 2
0.0 4.0
0.0 1.0
1.0 0.0
4.0 0.0
EOF
#
COL 0 0 1
2DEVAL "X,S,BEZO"
\end{lstlisting}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/scev001.eps}
  \caption{Smooth curves drawn with the RPN evaluator}
  \label{fig:scev001}
\end{figure}


\subsection{L-Systems}\label{l-systems}
\newpara
L-systems or Lindenmeyer systems are a type of formal grammar (as in
mathematical logic) developed by Aristid Lindenmeyer, a theoretical
biologist, in 1968 to model the processes of plant development. They can
be used to generate a variety of attractive images, beyond plants and
trees, including self-similar fractals. See this
\href{https://en.wikipedia.org/wiki/L-system}{Wikipedia} article for
more background information.

\newpara
Lindenmeyer systems generating 2D vector graphics are included in \textbf{GPLOT}.
The implementation is based on Paul Bourke's description of a 1991
commercial product (probably now long dead) which can be found
\href{https://paulbourke.net/fractals/lsys/}{here}. As with many of Paul
Bourke's web pages, this is very informative and inspirational.

\newpara
L-systems work by manipulating strings, the characters of which either
represent graphical actions (such as moving forward, drawing a line, or
turning through an angle) or are ``variables'' with no associated
graphical meaning.

\newpara
An L-system is defined by an ``axiom string'' and a set of ``re-writing
rules'', and, in our case, also a fixed ``turning angle''. The ``axiom
string'' must be set in string register 1 and up to 8 ``re-writing
rules'' can then appear in string registers 2 to 9 (used consecutively).
The initial line angle is set by storing the angle (in degrees) in
numeric register 3, with the $(x,y)$ coordinates
of the origin of the system in registers 1 and 2.

\newpara
The characters allowed (``vocabulary'') are:
\texttt{F\ A\ B\ C\ D\ E\ M\ X\ Y\ +\ -\ {[}\ {]}} Seven of these are
associated with specific actions. Any alphabetic character can be
substituted with a string by a re-writing rule. The seven ``action
characters'' are:

\begin{itemize}
\item
  \texttt{F} - draw a unit length line segment at the current drawing
  angle.
\item
  \texttt{D} - as \texttt{F}, but some systems need two substitutable
  drawing characters.
\item
  \texttt{M} - move by a unit length at the cureent drawing angle.
\item
  \texttt{+} - turn counter-clockwise by the turning angle.
\item
  \texttt{-} - turn clockwise by the turning angle.
\item
  \texttt{{[}} - push the current position and drawing angle on a stack.
\item
  \texttt{{]}} - pop the current position and drawing angle off a stack.
\end{itemize}

\newpara
This is all very abstract, of course! Paul Bourke's web page gives a
simple example which is quite easy to follow, but more complex systems
are not obvious (to me, anyway).

\newpara
Figure~\ref{fig:lsys001} is a classic example of a plant drawn with an L-system,
drawn by the following script.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/lsys001.eps}
  \caption{A Lindenmeyer plant also demonstrating other facilities}
  \label{fig:lsys001}
\end{figure}

\begin{lstlisting}
# PROCEDURE TO DRAW AN ALGORITHMICALLY DEFINED
# PLANT USING A LINDENMAYER SYSTEM.
# USAGE:
#  OBEY OBPLANT <ITERATIONS>
#   ITERATIONS BETWEEN 5 AND 8 SEEMS REASONABLE.

# INITIALISE GPLOT STATE.
RESET
GRAPHMODE ON

# SET THE COLOUR OF THE PLANT.
CSG GENERAL
COL 0.05 0.6 0.03

# DEFINE THE LINDENMAYER SYSTEM FOR THE PLANT.
STRING 1 X
STRING 2 F:FF
STRING 3 X:F-[[X]+X]+F[+FX]-X 
STO 3 90

# DRAW THE PLANT
LSYSTEM 2 $1 22.5

# SETUP TO ADD ANNOTATION
GRAPHMODE OFF
BOUNDS 0 1.33 0 1
CSG TEXT
COL 0 0 0

# DEMONSTRATE CTEXT CENTRED TEXT.
MOVE 0.3325 0.265
CTEXT 0.532 "L*LINDENMAYER *UP*LLANT"
MOVE 0.3325 0.185
CTEXT 0.4655 "X, F:FF, X:F-[[X]+X]+F[+FX]-X, 22.5*L DEGREES, $1 ITERATIONS."

# DEMONSTRATE ROTATED TEXT VIA THE RPN EVALUATOR.
STRING 5 "GPLOT/DIMFILM D*LEMONSTRATION AND TEST SCRIPT"
STRING 6 "  DIMFILM 1972-95, GPLOT 2013-"
EVAL "1.31,0.05,M,90,TA,5,T,1.31,0.6,M,6,T"

# ADD THE GPLOT VERSION INFO, DRAWING CENTRED TEXT
# VIA A STORED PROCEDURE.
VERSION 9
LOADP 1 ECTEXT
EVAL @1 "0.3325,0.125,0.45,9"

OUTLINE DEV
\end{lstlisting}

\newpara
Note that, in general, the complexity of the drawing explodes as the
number of iterations increases. The \textbf{GPLOT} L-system implementation uses
scratch files to avoid memory limitations on NOS, so large outputs are
possible, but the compute times also explode! The maximum stack depth is
set to 20, although this doesn't seem to be much of a limitation in
practice.

\newpara
Here are some other examples.

\newpara
A complicated, bristly plant (Figure~\ref{fig:lsbr001}) is
drawn by the following script.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/lsbr001.eps}
  \caption{A bristly looking plant}
  \label{fig:lsbr001}
\end{figure}

\begin{lstlisting}
RESET

# SET THE COLOUR OF THE PLANT.
CSG GENERAL
COL 0.05 0.6 0.03

# DEFINE THE LINDENMAYER SYSTEM FOR THE PLANT.
STRING 1 ABFFF
STRING 2 A:[+++C][---C]YA
STRING 3 C:+X[-C]B
STRING 4 X:-C[+X]B
STRING 5 Y:YB
STRING 6 B:[-FFF][+FFF]F

# INITIAL DRAWING ANGLE.
STO 3 90

# DRAW.
LSYSTEM 5 $1 20
\end{lstlisting}

\newpara
Figure~\ref{fig:lssm001} shows a Minkowski island, after 4 iterations.
L-systems can generate most
(all?) 2D fractal curves. Several such curves follow.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/lssm001.eps}
  \caption{A Minkowski Island (4 iterations)}
  \label{fig:lssm001}
\end{figure}

\begin{lstlisting}
RESET

STRING 1 F+F+F+F
STRING 2 F:F+F-F-FF+F+F-F

STO 3 0

CSG GENERAL
COL 0.9 0 0.1

LSYSTEM 1 $1 90
\end{lstlisting}

\newpara
Figure ~\ref{fig:lssp001} shows a 
Sierpinski gasket after 6 iterations, drawn by this script.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/lssp001.eps}
  \caption{A Sierpinski Gasket (6 iterations)}
  \label{fig:lssp001}
\end{figure}

\begin{lstlisting}
RESET

STRING 1 F+F+F        ; AXIOM
STRING 2 F:F-F+F+F-F  ; GENERATOR

STO 3 0               ; INITIAL ANGLE

CSG GENERAL
COL 0.9 0 0.1

# DRAW THE GASKET
LSYSTEM 1 $1 120
\end{lstlisting}

\newpara
Figure~\ref{fig:lsks001} shows a Koch ``snowflake'' drawn with rectangular elements
is drawn by this script.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/lsks001.eps}
  \caption{A Koch Snowflake (4 iterations)}
  \label{fig:lsks001}
\end{figure}

\begin{lstlisting}
RESET

STRING 1 F+F+F+F
STRING 2 F:FF+F-F+F+FF

STO 3 0

CSG GENERAL
COL 0.9 0 0.1

LSYSTEM 1 $1 90
\end{lstlisting}

\newpara
Finally, Figure~\ref{fig:lsgo001} shows a Gosper curve or ``flowsnake''
after 4 iterations, drawn by this script.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/lsgo001.eps}
  \caption{A Gosper Flowsnake curve (4 iterations)}
  \label{fig:lsgo001}
\end{figure}

\begin{lstlisting}
RESET

STRING 1 F
STRING 2 F:F-D--D+F++FF+D-
STRING 3 D:+F-DD--D-F++F+D

STO 3 90

CSG GENERAL
COL 0.9 0 0.1

LSYSTEM 2 $1 60
\end{lstlisting}

\clearpage
\part{Appendices}
\clearpage

\section{Fonts}
\newpara
As previously noted, the fonts that can be used in \textbf{GPLOT} are taken
from the Hershey vector fonts (originally published in 1967).
Figure~\ref{fig:fosm001} is a ``font sampler'' giving a quick overview
of what is available.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/fosm001.eps}
  \caption{A font sampler}
  \label{fig:fosm001}
\end{figure}

\newpara
The pages that follow give full font tables for the
alphabetic, symbol and marker fonts. These can be used to
find the character numbers needed to insert special characters
in text, as well as showing all the fonts in detail.

\subsection{Alphabetic fonts}
This script will draw an alphabetic font table.
\begin{lstlisting}
PROC 1 I,10,I0IJ,M,I,TC   ; DRAW CHARACTER I AT IJ
PROC 2 I,0.5,-,1,STO,0.5,CHS,M,1,RCL,9.5,D
PROC 3 0.5,CHS,I,0.5,-,1,STO,M,9.5,1,RCL,D
PROC 4 I,10,I0IJ,0.4,-,SWAP,0.4,-,SWAP,M,I,1,TVI
STRING 1 "(I2)"
FONT 1 $1 
CANVAS -1 10 -1 10
CSG ALL
COLOUR 0 0 0
WIDTH 1
SYMHT 0.3 
ITEVAL 1 96 1 @1
FONT 1 SANS.SIMPLEX 
SYMHT 0.2 
COLOUR 0.5 0.5 0.5
ITEVAL 1 96 1 @4
COLOUR 1 0 0
ITEVAL 0 10 1 @2
ITEVAL 0 10 1 @3
MOVE 4.5 9.75
SYMHT 0.4
CTEXT 0 $1
\end{lstlisting}
The argument to this script is the font name.

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f01t001.eps}
  \caption{Sans Simplex}
  \label{fig:f01t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f02t001.eps}
  \caption{Sans Simplex Mono}
  \label{fig:f02t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f03t001.eps}
  \caption{Sans Simplex Greek}
  \label{fig:f03t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f04t001.eps}
  \caption{Sans Duplex}
  \label{fig:f04t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f05t001.eps}
  \caption{Serif Complex}
  \label{fig:f05t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f06t001.eps}
  \caption{Serif Complex Small}
  \label{fig:f06t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f07t001.eps}
  \caption{Serif Complex Greek}
  \label{fig:f07t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f08t001.eps}
  \caption{Serif Complex Greek Small}
  \label{fig:f08t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f09t001.eps}
  \caption{Serif Triplex}
  \label{fig:f09t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f10t001.eps}
  \caption{Serif Complex Italic}
  \label{fig:f10t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f11t001.eps}
  \caption{Serif Complex Italic Small}
  \label{fig:f11t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f12t001.eps}
  \caption{Serif Triplex Italic}
  \label{fig:f12t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f13t001.eps}
  \caption{Script Simplex}
  \label{fig:f13t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f14t001.eps}
  \caption{Script Complex}
  \label{fig:f14t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f15t001.eps}
  \caption{Gothic Triplex}
  \label{fig:f15t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f16t001.eps}
  \caption{Gothic Triplex German}
  \label{fig:f16t001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f17t001.eps}
  \caption{Gothic Triplex Italian}
  \label{fig:f17t001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f18t001.eps}
  \caption{Cyrillic Complex}
  \label{fig:f18t001}
\end{figure}


\clearpage
\subsection{Symbol fonts}

\newpara
This script draws a symbol font table:
\begin{lstlisting}
PROC 1 I,10,I0IJ,M,I,TS   ; DRAW SYMBOL I AT IJ
PROC 2 I,0.5,-,1,STO,0.5,CHS,M,1,RCL,9.5,D
PROC 3 0.5,CHS,I,0.5,-,1,STO,M,9.5,1,RCL,D
PROC 4 I,10,I0IJ,0.4,-,SWAP,0.4,-,SWAP,M,I,1,TVI
STRING 1 "(I2)"
FONT S $1 
CANVAS -1 10 -1 10
CSG ALL
COLOUR 0 0 0
WIDTH 1
SYMHT 0.3 
ITEVAL 1 96 1 @1
FONT 1 SANS.SIMPLEX 
SYMHT 0.2 
COLOUR 0.5 0.5 0.5
ITEVAL 1 96 1 @4
COLOUR 1 0 0
ITEVAL 0 10 1 @2
ITEVAL 0 10 1 @3
MOVE 4.5 9.75
SYMHT 0.4
CTEXT 0 $1
\end{lstlisting}
The argument is the font name.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f01s001.eps}
  \caption{Math symbols}
  \label{fig:f01s001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f02s001.eps}
  \caption{Cartographic symbols}
  \label{fig:f02s001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f03s001.eps}
  \caption{Astronomical symbols}
  \label{fig:f03s001}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f04s001.eps}
  \caption{Astrological symbols}
  \label{fig:f04s001}
\end{figure}

\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f05s001.eps}
  \caption{Musical symbols}
  \label{fig:f05s001}
\end{figure}

%% \clearpage
\subsection{Marker font}

\newpara
This script draws a marker font table:
\begin{lstlisting}
PROC 1 I,10,I0IJ,M,I,TM   ; DRAW MARKER I AT IJ
PROC 2 I,0.5,-,1,STO,0.5,CHS,M,1,RCL,9.5,D
PROC 3 0.5,CHS,I,0.5,-,1,STO,M,9.5,1,RCL,D
PROC 4 I,10,I0IJ,0.4,-,SWAP,0.4,-,SWAP,M,I,1,TVI
STRING 1 "(I2)"
FONT M $1 
CANVAS -1 10 -1 10
CSG ALL
COLOUR 0 0 0
WIDTH 1
SYMHT 0.3 
ITEVAL 1 96 1 @1
FONT 1 SANS.SIMPLEX 
SYMHT 0.2 
COLOUR 0.5 0.5 0.5
ITEVAL 1 96 1 @4
COLOUR 1 0 0
ITEVAL 0 10 1 @2
ITEVAL 0 10 1 @3
MOVE 4.5 9.75
SYMHT 0.4
CTEXT 0 $1
\end{lstlisting}
The argument is the font name.

\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/f01m001.eps}
  \caption{Principal marker font}
  \label{fig:f01m001}
\end{figure}


\section{Ancillary Tools and Notes}
\newpara
\textbf{GPLOT} comes with some tools which may be helpful when using it, and perhaps more generally.
When using \textbf{GTerm}, but especially when using a Tektronix 401x emulated terminal, it is useful to
set certain things on ``Unix-like'' systems to get the best results. Some notes on that can be found here.

\newpara
Installation instructions for the tools can be found in the Github \texttt{README.md} for the \textbf{GPLOT} project.

\subsection{EPSView}
\newpara
The script \texttt{epsview.sh} can be used to display Encapsulated PostScript (EPS) files created by
\textbf{GPLOT}. This is particularly
useful on recent versions on macOS, where the ability to display EPS files simply by clicking on them has been removed
by Apple in recent versions, but it also can be useful on Linux.

\newpara
The most basic usage is:
\begin{lstlisting}
$ epsview.sh epsfile
\end{lstlisting}
On macOS, this will open a new \texttt{Preview} window or tab displaying the contents of the given EPS file after
it has been converted to PDF by Ghostscript. The supplied
name need not be given the extension \texttt{.eps} -- this will be added if it isn't there.

\newpara
On Linux, \texttt{xdg-open} is used to open the EPS file (after conversion to PDF). This should find an
appropriate application to display the converted PDF file.

\newpara
The following options are available:
\begin{itemize}
\item \textttc{-p} --- Also output a PNG image file version of the EPS file.
  This will be named as the input file but with a \texttt{.png}
  extension.
\item \textttc{-c} --- Try to remove (crop) any ``margins'' from the EPS document.
\item \textttc{-f} --- Apply ``fixup'' heuristics to EPS files generated on COS.
  Unfortunately, these become upper case when transferred from COS to NOS. No transfer options
  have been found that prevent this (so far), so try to correct for this. This is only relevant
  to \textbf{DIMFILM} EPS output from COS.
\end{itemize}

\subsubsection{Making ImageMagick work for PDF files on Linux}
\newpara
It is possible that the \texttt{-p} option will not work on Linux systems because \textbf{ImageMagick} believes PDF output
from \textbf{Ghostscript} is a ``security'' problem. This will not be the case with conversions of \textbf{GPLOT} output
to PDF (honest!). If you get a ``security policy'' message using this option, a configuration file can be
edited to make things work.

\begin{lstlisting}
sudo nano /etc/ImageMagick-6/policy.xml
\end{lstlisting}
Find this string:
\begin{lstlisting}
<policy domain="coder" rights="none" pattern="PDF" />
\end{lstlisting}
and change it to:
\begin{lstlisting}
<policy domain="coder" rights="read|write" pattern="PDF" />
\end{lstlisting}

\newpara
Whether you run into this is probably dependent on the exact versions of \textbf{Ghostscript}
and \textbf{Imagemagick} that are
installed on your system. And possibly on the phase of the moon too.

\subsection{SVGView}
\newpara
The Python program \texttt{svgview} is an ``as minimal as can be'' SVG file viewer which can be used to
have a quick look at SVG files created by \textbf{GPLOT/DIMFILM} (and most others, probably). This
is based on PySDL2 and is comparatively lightweight (relative to a web browser or Inkscape,
anyway!).

\newpara
To display an SVG file in a pop-up window:
\begin{lstlisting}
svgview afile.svg
\end{lstlisting}
(the extension need not be \texttt{.svg} or present at all). There is only one
option: \textttc{-w n} which lets the width of the window (and also the resolution at which
the SVG is rasterised) be set to \textttc{n} pixels. The default is 1280.

\newpara
A trivial Bash script uses this program to display every \texttt{.svg} file in the current working
directory in turn. This can help with verifying correct operation of \textbf{GPLOT/DIMFILM} as
explained below.

\subsection{NOSFTP}
\newpara
If EPS and SVG graphics files are generated on NOS, it might be necessary to move them to other
``mainstream'' systems for further use. NOS 2.8.7 has a very good FTP server and this is probably
the most straightforward way of moving the files between NOS and ``Unix-like'' systems.

\newpara
It is possible to use any FTP client to communicate with the NOS FTP server, and this is
fairly straightforward. However, the NOS file system has some very unusual features not seen
on ``mainstream'' systems and extra information must be sent when accessing NOS files. This
extra information is easy to forget. NOSFTP is a small Python program that adds the extra
information ``behind the scenes'' so you don't have to remember it.

\newpara
To run NOSFTP:
\begin{lstlisting}
$ nosftp [options] username hostname
\end{lstlisting}
Here, \textttc{username} is the account name on NOS you want to access and \texttt{hostname} is the name of the host
running DtCyber (or its IP address). Before logging in, you will be prompted to enter the password for the
NOS account and the NOS FTP server will be contacted. After that, you will be prompted to enter
commands. The following commands are available:
\begin{itemize}
\item \textttc{quit} or \textttc{exit} or \textttc{bye} --- Close the FTP server connection and exit NOSFTP.
\item \textttc{get nosname localname ascii|display|binary} --- Get a file from the NOS FTP server. You should
  use \texttt{ascii} if transferring EPS or SVG files so that lower case is correctly preserved.
\item \textttc{put localname nosname [display]} --- Send a file to the NOS FTP server. This command
  tries to be ``intelligent'' (which may have been a mistake). If NOSFTP ``thinks'' the file is binary data,
  it will save it as a \emph{direct access} file on NOS, otherwise it will save it as an \emph{indirect access} file.
  For non-binary files, it will send the file to be stored as ASCII unless
  the optional \texttt{display} option is supplied,
  in which case it will be stored as Display Code (with any lower case converted to upper case).
  If sending \texttt{OBEY} files, you should use the \texttt{display} option.
\item \textttc{bput localname nosname [direct]} --- Send a binary file (you determine it is binary rather than
  NOSFTP guessing it is). By default, this is stored on NOS as an \emph{indirect access} file. To store it as a
  \emph{direct access} file, add the direct option.
\item \textttc{mget listname display|ascii extension} --- Given a list of files, one per line in a file called
  \texttt{listname}, fetch each file in turn. All the files will be treated in the same way, so they must be
  of the same ``kind''. The files must not be binary. The character set for every file can be \texttt{display}
  (upper case only) or \texttt{ascii} (mixed case). On the receiving end, all the files will be given the
  \texttt{extension} specified. The names given in the file \texttt{listname} must be valid NOS file names.
  Files with invalid NOS names are skipped, but the rest of the transfers will take place.
\item \textttc{mput listname display|ascii} ---  Given a list of files, one per line in a file called
  \texttt{listname}, send each file in turn. The file names in \texttt{listname} must be valid NOS file names.
  No name transformations are made, so the files to be sent must have the same names on the ``Unix-like''
  system with no extensions. The files must not be binary. If lower case is to be preserved, the \texttt{ascii}
  option should be used. For \texttt{OBEY} files, use the \texttt{display} option.
\item \textttc{dir} --- Show a compact list of all permanent files stored on the NOS account.
\item \textttc{info nosname} --- List full information on a single NOS permanent file.
\item \textttc{del nosname} --- Delete a NOS permanent file.
\item \textttc{lpwd} --- Print the local working directory name.
\item \textttc{lcd localdir} --- Change the local working directory.
\item \textttc{ls [string]} --- List the local working directory, optionally restricting output
  to file names containing string.
\end{itemize}

\newpara
The following command line options are available:
\begin{itemize}
\item \textttc{-e ``NOSFTP command''} --- Execute the supplied command, then exit.
\item \textttc{-p password} --- Use the plain text password to login to the NOS FTP server. Terrible
  for ``security'' but may be practically useful.
\item \textttc{-d 0|1|2} --- Set the debug level to help diagose problems. Should not be necessary!
\end{itemize}

\subsection{SGFormat}
\newpara
\textbf{SGFormat} is a RUNOFF style document formatter. It  was written to
try to format the original DIMFILM manual
by working from the \texttt{.SG} version of the documentation.

\newpara
The DIMFILM manual was held in three different formats. Two of these were binary: one for an early
version of Microsoft Word (.msw extension) and one for some version of Wordstar (.ws2). The files date from the
mid-1980's and I have not been able to find any software which can read them. Perhaps the appropriate
versions of Word and WordStar still exist somewhere and could be run under something like DOSBox but
there is no clear way of using these files today. This is (another) lesson in the fragility of
digital data, even when significant trouble is taken to preserve it (e.g. through use of multiple
different data formats).

\newpara
However, the third format was of the ``text with mark-up'' type and was definitely related to RUNOFF.
Again, though, I have not been able to locate any software which can process this specific version
of RUNOFF-like mark-up. The file extension (.SG) doesn't seem to be known in relation to any
kind of document processing software. Some 40 years ago, though, it must have been.

\newpara
As a readable text based format, it was the obvious choice from which to try to recreate the DIMFILM
manual. A first attempt to do this in 2008 with a C program gave results which were marginally useful but not
really acceptable. This showed that a pretty complete implementation of a document formatter was needed
to get decent results. Fortunately, that is much easier using Python in 2025 than it was using C 17
years earlier.

\newpara
Although SGFormat exists solely because the DIMFILM manual needed to be recreated, it
could be used to create new documents in the unlikely event anyone wants to do that. The output is
plain text and PDF (via PostScript).

\newpara
Mark-up in this riff on RUNOFF consists of two types:
\begin{itemize}
\item Full line commands, beginning with a dot or period: \texttt{.} We'll call these ``body commands''
  below.
\item Commands embedded in lines of text. These are single letters following a dollar sign: \texttt{\$}. We'll
  call these ``line commands'' below.
\end{itemize}
Characters which need to be escaped are preceeded by two tildes: \texttt{\textasciitilde\textasciitilde}

\newpara
It should be said that, since there is no information available on the \texttt{.SG} format anywhere
(that I have found), it isn't certain what the commands should really do! However, what we
have chosen to do for them seems to give a reasonable result for the \textbf{DIMFILM} manual. Also,
although there are many options that can be set (see below), and these work as intended at their
defaults, no real tests have been done on what happens when these are set to other values.

\subsubsection{Body commands}
The following body commands are implemented. The commands maybe be in lower or upper case.
\begin{itemize}
\item \textttc{.} --- Output a blank line if a single dot is the only thing on an input line.
\item \textttc{.justify} --- Turn on justification for smooth (not ragged) right edge.
\item \textttc{.part} --- Begin a new Part of the document.
\item \textttc{.chapter} --- Start of a new Chapter within a Part.
\item \textttc{.section} --- Start of a new Section within a Chapter.
\item \textttc{.subsection} --- Start of a new Sub-section within a Section.
\item \textttc{.appendix} --- Start of a new Appendix. As per Chapter, but keep counts separate.
\item \textttc{.foot} --- Start of Footer text definition.
\item \textttc{.endf} --- End of Footer text definition.
\item \textttc{.head} --- Start of Header text definition.
\item \textttc{.endh} --- End of Header text definition.
\item \textttc{.tabset [n,n,...n]} --- Define a new set of tab stops or revert to default if no stops given.
\item \textttc{.display} --- Start of a literal section for ASCII art or code that should not
  be split across pages. The text in such a section is centered horizontally, based on
  the maximum length of a line in the section. Tab commands
  should not appear in lines in such sections.
\item \textttc{.endd} --- End a \texttt{.display} section.
\item \textttc{.copy} --- Start a literal section, as per \texttt{.display}, but do not centre the contents
  horizonatlly and process tab stops if present.
\item \textttc{.endc} --- End a \texttt{.copy} section.
\item \textttc{.page n} --- Set the page number to integer \texttt{n}.
\item \textttc{.newpage} --- Start a new page.
\item \textttc{.blank [n]} --- Output n blank lines, or 1 if \texttt{n} omitted.
\item \textttc{.contents} --- Insert table of contents in the output here.
\end{itemize}

\newpara
The following body commands may appear, but are (intelligently) ignored: \texttt{.macro},
\texttt{.endm}, \texttt{.nl}, \texttt{.fill},
\texttt{.contig}, \texttt{.ee}, \texttt{.tt}, \texttt{.space}, \texttt{.footlength}, \texttt{.headlength},
\texttt{.set}, \texttt{.parspace}, \texttt{.table}, \texttt{.endtable}.

\subsubsection{Line commands}
These appear within ``normal'' (i.e. not body command) lines of input text.
\begin{itemize}
\item \textttc{(space)} as first character on line --- Paragraph break.
\item \textttc{\$T} --- Go to next tab stop in a \texttt{.copy} section.
\item \textttc{\$T} --- If first thing on an input line outise a \texttt{.copy} section,
  indent by body tab size (see below).
\item \textttc{\$I} --- Indent by body indent size if not in a \texttt{.copy} section (see below).
\item \textttc{\$C} --- Centre the following text to the end of the line or \$E. Do not use in a \texttt{.copy} section.
\item \textttc{\$E} --- Right justify the following text to the end of the line.
\item \textttc{\#} --- Insert a non-removeable space.
\item \textttc{\textasciitilde\textasciitilde\#} --- Insert a hash character.
\item \textttc{\textasciitilde\textasciitilde\_} --- Insert an underscore. Unescaped underscores are deleted.
\item \textttc{\textasciitilde\textasciitilde\$} --- Insert a dollar sign.
\item \textttc{\textasciitilde\textasciitilde\textasciitilde} --- Insert a tilde.
  To avoid inadvertantly escaping a following \texttt{\$},
  add a space between the \texttt{\textasciitilde\textasciitilde\textasciitilde} and \texttt{\$}.
\item \textttc{\textasciitilde\%date} --- Insert a specifed date (see below) or today's date if not explicitly set.
\item \textttc{\textasciitilde\%page }--- Insert the current output page number.
  Negative page numbers are output as Roman
  numerals.
\end{itemize}

\newpara
Note that \texttt{\$C} and \texttt{\$E} can be used on a single line to split it into 3 sections: left justified,
centered and right justified. This is useful when defining a footer. For example:
\begin{lstlisting}
 .foot

 DIMFILM$c~%page $eDRAFT DOCUMENT
 Preliminary User Guide $e~%date
 .endf
\end{lstlisting}
This will put \texttt{DIMFILM} at the left (left justified), the page number in the centre,
and \texttt{DRAFT DOCUMENT}
right justified (and on a second line, \texttt{Preliminary User Guide} left justified and a date
right justified) at the foot of every output page.

\subsubsection{Control file}
A document is described by a JSON format control file. This defines the source files that
make up the document and all processing options to be applied to it.

\newpara
The following keys must be present in a control file.
\begin{itemize}
\item \textttc{source\_files} --- The value for this must be a list naming the input files.
\item \textttc{source\_dir} --- The value for this is a string naming the directory where the source files can be found.
  This is pre-pended to each source file name before trying to open it.
\item \textttc{output\_stem} --- Set the name of the output file, omitting any extension. A plain text file with the
  extension \texttt{.txt} and a PDF file with extension \texttt{.pdf} will be created based on this.
\item \textttc{output\_dir} --- The value for this is a string naming the directory in which to write output files.
\end{itemize}

\newpara
There are many more optional keys.
\begin{itemize}
\item \textttc{page\_lines} --- The value should be a string representing a decimal integer, giving the number of
  lines on a page, not including header and footer lines. Default is 58.
\item \textttc{line\_width} --- The value should be a string representing a decimal integer, giving the number of
  characters in a line across the page. Default is 80.
\item \textttc{body\_tab\_size} --- Set the tab size for \texttt{\$T} outside \texttt{.copy} regions.
  Default is 6.
\item \textttc{body\_indent\_size} --- Set the indent size for \texttt{\$I}. Default is 3.
\item \textttc{min\_justify\_words} --- Set the minimum number of words on an output line above which
  right flush justification will be done. If this is done with too few words, very large unsightly gaps
  appear between the (few) words present. Default is 8.
\item \textttc{ps\_page\_height\_points} --- Set the PostScript/PDF page height in points. Default is 842 (A4).
\item \textttc{ps\_page\_width\_points} --- Set the PostScript/PDF page width in points. Default is 595 (A4).
\item \textttc{ps\_top\_margin\_points} --- Set top margin height for PostScript/PDF in points. Default is 54 (0.75 inch).
\item \textttc{ps\_left\_margin\_points} --- Set left margin width for PostScript/PDF in points. Default is 54 (0.75 inch).
\item \textttc{ps\_text\_size\_points} --- Set the character height for PostScript/PDF in points. Default is 10.
\item \textttc{ps\_leading} --- Set the spacing between lines for PostScript/PDF in points. Default is 3.
\item \textttc{ps\_font\_name} --- Set the name of the font to be used for PostScript/PDF. Default is Courier.
  This should be a monospaced font and allowed values will be operating system dependent.
\item \textttc{ps\_paper} --- Set the paper size by name for PostScript/PDF output.
  Known values are \texttt{a4}, \texttt{letter} and \texttt{legal}. Setting this overrides any previously
  specified \texttt{ps\_page\_height\_points} and \texttt{ps\_page\_width\_points} values.
\item \textttc{specific\_date\_string} --- Set a specific date to be output when \texttt{\textasciitilde\%date}
  is used. The format is \texttt{YYYY,MM,DD}. If this option is not used, today's date will be output.
\item \textttc{default\_tabset} --- The value should be a string containing comma separated integers in ascending
  order. For example: ``\texttt{10,15,20,35}''. These tab stops will be used throughout the document unless
  the \textttc{.tabset} body command is used.
\end{itemize}

\newpara
As a concrete example, this is the control file for the \textbf{DIMFILM} manual.
\begin{lstlisting}
{
    "source_files" : [
        "DIMFORM.SG",
        "DIMINTRO.SG",
        "DIMPART1.SG",
        "DIMPART2.SG",
        "DIMPART3.SG",
        "DIMPART4.SG",
        "DIMAPP1.SG",
        "DIMAPP2.SG",
        "DIMAPP3.SG",
        "DIMAPP4.SG"
    ],

    "source_dir" : "../../historic/DIMFILM/DOCS",

    "specific_date_string" : "1984,06,23",

    "output_stem" : "dimfilm-manual",

    "output_dir" : "."
}
\end{lstlisting}

\subsubsection{Running SGFormat}
To run this tool (after it has been installed) use:
\begin{lstlisting}
sgformat [-h] [-d] ctrlname
\end{lstlisting}
where \texttt{ctrlname} in the name of the JSON format control file for the document.

\newpara
The \texttt{-d} option turns on debugging mode and should not normally be used.

\subsection{Terminal configuration on ``Unix-like'' systems}
\newpara
By default, ``terminals'' on ``Unix-like'' systems are assumed to have certain characteristics defined by
the terminal type \texttt{xterm-256color}. This is based on the DEC VT-100 escape sequences with many extensions.
Users very rarely need to know about their ``terminal type'' these days, but neither \textbf{GTerm} nor Tektronix 401x
conform to the \texttt{xterm-256color} ``standard'' (to say the least). \textbf{GTerm} largely just ignores extraneous
escape sequences it receives, but Tektronix 401x terminals (with some emulators) may be more sensitive. In both cases,
things work better if the terminal is explicitly configured.

\newpara
Although there are many alternative approaches, using Bash rather than zsh and setting the prompt to something
minimal is recommended. For example:
\begin{lstlisting}
$ bash
$ export PS1='$ '
\end{lstlisting}

\subsubsection{Tektronix 401x}
\begin{lstlisting}
$ export TERM=tek4014
$ tset -e ^H
\end{lstlisting}

\subsubsection{GTerm}
\begin{lstlisting}
$ export TERM=dumb
$ tset
\end{lstlisting}

\subsection{A stripped down telnetd for ``Unix-like'' systems}
\newpara
The \textbf{DtCyber} simulator provides terminal access through a built-in telnet server. Most other historic computer system simulators
do the same for terminals. However, \textbf{GPLOT} can run on ``Unix-like'' systems and it is often useful to run it with
\textbf{GTerm} (or, maybe, a Tektronix 401x emulator). In the past, that hasn't been a problem, because ``Unix-like'' systems
came with a telnet server (of course). However, there are now two issues:
\begin{itemize}
\item Some systems (e.g. macOS) no longer ship with telnet servers at all, for ``security'' reasons.
\item Telnet servers have been disfavoured for over a decade now, since \textbf{ssh} is a much better choice for most purposes --- but
  not for all. Maintaining them has been low priority, and this has shown in terms of bugs that come and go from release to
  release. The standard \texttt{telnetd} is also quite complex --- much more so than it needs to be for most likely applications
  these days.
\end{itemize}

\newpara
To get around these issues, we can use a patched version
of \textbf{mini-telnetd} which can be built on today's versions of macOS and Linux.
This is a very barebones telnet server which nonetheless does everything needed for using \textbf{GTerm} on macOS and Linux.
The \textbf{mini-telnetd} Github repository can be found here: \url{https://github.com/Troll338cz/mini_telnetd}.

\newpara
After cloning this, use the file: \texttt{tools/mini\_telnetd.patch} to patch the source and build it with \texttt{make}.
\begin{lstlisting}
git apply mini_telnetd.patch
\end{lstlisting}

\newpara
On macOS, \textbf{mini-telnetd} can be run as follows (note \texttt{sudo} is not required):
\begin{lstlisting}
$ mini-telnetd -p 2323 -l /usr/bin/login
\end{lstlisting}

\newpara
On Linux, \textbf{mini-telnetd} must be run as \texttt{sudo}. However, the login program binary location need not be specified,
as the default \texttt{/bin/login} is correct there.
\begin{lstlisting}
$ sudo mini-telnetd -p 22323 
\end{lstlisting}

\subsection{Building documentation on a ``Unix-like'' system}
\newpara
The \textbf{DIMFILM} and \textbf{GPLOT} PDF manuals are stored ``pre-built'' in the Git repository. If you want to rebuild them,
the directories \texttt{doc/dimfilm} and \texttt{doc/gplot} contain \texttt{build.sh} scripts that will build them from source. For
the \textbf{DIMFILM} manual, the \textbf{GPLOT} tools must have been installed and
the Python \texttt{venv} used for that installation must be active
(see \texttt{README.md}).

\newpara
For the \textbf{GPLOT} manual, in addition to the \textbf{DIMFILM} requirements, a complete TeX/LaTeX environment
must have been installed. This is done by installing \textbf{TexLive} on Linux or \textbf{MacTex} on macOS.

\subsection{Verifying GPLOT/DIMFILM is working correctly}

The "test suite" for \textbf{GPLOT} (and, indirectly, \textbf{DIMFILM}) consists of the obey files that
create the figures in this document. These aren't exhaustive tests, of course, but
if the full set of Figures can be correctly generated on a system for all four
supported devices, it is likely that (almost?) everything is working correctly.

\newpara
To aid with verification, there are two obey files which generate all the figures
in EPS or SVG format. These are \texttt{OBALEPS} and \texttt{OBALSVG},
which both rely on \texttt{OBALTST}.

\newpara
To run these on NOS, use:
\begin{lstlisting}
ATTACH,GPLOT.
GPLOT,GET=YES,SAVE=YES,OBEY=OBALEPS.
GPLOT,GET=YES,SAVE=YES,OBEY=OBALSVG.
\end{lstlisting}

\newpara
You may want to fetch the result files to some system on which they can be
viewed after each step, as the \texttt{OBALSVG} stage will overwrite the EPS files
generated by \texttt{OBALEPS} (the output files have the same names -- NOS file names
have no extensions and are too short to add anything meaningful to distinguish 
EPS from SVG).

\newpara
These tests will take some time to run and consume a lot of resources, so
it is recommended to use:
\begin{lstlisting}
SETTL,*.
SETJSL,*.
\end{lstlisting}
to prevent running into time and resource limits.

\newpara
To fetch the output files from NOS to a "Unix-like" system, you can use NOSFTP
with a fetch list. This list is in a file \texttt{fetch-list} which can be recreated
with \texttt{get-images-list.sh} if \texttt{OBALTST} is modified (it scans that obey file for
output image information). For example, to get all SVG files generated by the above
on NOS into a directory called \texttt{temp2}:
\begin{lstlisting}
$ mkdir temp2
$ cd temp2
$ nosftp tester nuc1
Password for NOS account: 
Contacting NOS FTP server on host: nuc1
230 USER LOGGED IN, PROCEED.
220 SERVICE READY FOR NEW USER.
Local cwd now: /Volumes/qemu-main/gitprojects/gplot2/temp2
NOS FTP> mget ../obey-files/fetch-list ascii svg
... getting: gr1001 ( 1 )
... retrieving file: gr1001
226 CLOSING DATA CONNECTION.
...
...
... getting: fin001 ( 73 )
... retrieving file: fin001
226 CLOSING DATA CONNECTION.
Got 73 of 73 files OK

NOS FTP> bye

Exiting normally.
221 SERVICE CLOSING CONTROL CONNECTION. LOGGED OUT.

$ ls
cht1001.svg f02t001.svg f05t001.svg f11t001.svg f17t001.svg	
g2fm001.svg gh1b001.svg gr12001.svg gr18001.svg gr21001.svg	
gr30001.svg iocd001.svg lsys001.svg cht2001.svg f03s001.svg	
f06t001.svg f12t001.svg f18t001.svg g2sp001.svg gh2b001.svg	
gr13001.svg gr1a001.svg gr22001.svg gr3001.svg  lsbr001.svg
f01m001.svg f03t001.svg f07t001.svg f13t001.svg fin001.svg	
g3sp001.svg ghbb001.svg gr14001.svg gr1i001.svg gr27001.svg	
gr4001.svg  lsgo001.svg f01s001.svg f04s001.svg f08t001.svg	
f14t001.svg fosm001.svg gd01001.svg gr10001.svg gr15001.svg	
gr1x001.svg gr28001.svg gr5001.svg  lsks001.svg f01t001.svg	
f04t001.svg f09t001.svg f15t001.svg g1fm001.svg gdea001.svg	
gr1001.svg  gr16001.svg gr20001.svg gr29001.svg gr7001.svg	
lssm001.svg f02s001.svg f05s001.svg f10t001.svg f16t001.svg	
g1sp001.svg gemz001.svg gr11001.svg gr17001.svg gr2001.svg	
gr2a001.svg gr8001.svg  lssp001.svg
\end{lstlisting}

\newpara
There is a script which will run the \textbf{SVGView} tool on all SVG
files in a directory to make the output easy to examine:
\begin{lstlisting}
svgviewall.sh
\end{lstlisting}
This is installed when the other tools described above are
installed.

\newpara
To verify correct operation on the two interactive devices,
use \textbf{GPLOT} interactively, choose the device
(\texttt{GTERM} or \texttt{TEK4K}) then use:
\begin{lstlisting}
OBEY OBALTST
\end{lstlisting}
and inspect the output visually. The obey script pauses
after each output "frame" for the user to type \texttt{(return)}
(or \texttt{Q (return)} to stop the script). On "Unix-like"
systems, you may need to use \texttt{PREFIX} to specify where obey
files are to be found first.

\newpara
To run the EPS and SVG format verification tests on
"Unix-like" systems, use:
\begin{lstlisting}
gplot obey=obaleps
gplot obey=obalsvg
\end{lstlisting}
from the \texttt{obey-files} directory (the generated
files can be tidied
up afterwards, as desired).

\newpara
The output files will have \texttt{.svg} or \texttt{.eps} extensions in 
this case, of course. This will also work on VMS and NOS/VE (with different
``extension'' separator characters on the latter).



\section{Acknowledgements and history}
\newpara
\textbf{GPLOT} is entirely reliant on \textbf{DIMFILM}, written by Dr. John C. Gilbert at The University of London
Computer Centre (U.L.C.C.) and maintained primarily by him between 1972 and the mid-1990's. One goal of \textbf{GPLOT} is to
preserve \textbf{DIMFILM}. I can find almost no trace of this excellent software elsewhere.

\newpara
\textbf{GPLOT} uses character
string parsing subroutines written by Dr. Adrian Clark circa 1985. Dr. Clark also wrote a \textbf{DIMFILM} device
driver for Tektronix storage tube terminals on which the \textbf{GPLOT} Tektronix support
is based.

\newpara
The version of \textbf{DIMFILM} used here came to me from Dr. Gilbert via Dr. Clark in 2005. Due to a malfunctioning hardware
RAID controller, the U.L.C.C. production version was no longer available and the version we have here
was assembled by Dr. Gilbert from various sources. Unfortunately, it did not include the original font data. I had a
working version of \textbf{DIMFILM} using Hershey fonts by 2007 (it was very much a hobby project!). Not many changes were made.
The original, unmodified, source is retained in the \texttt{historic} sub-tree of the source repository.

\newpara
As noted above,
the original (albeit ``interim'') \textbf{DIMFILM} manual was preserved in several formats, including a very early version
of Microsoft Word and some mid-1980's version of WordStar. I have failed to find any software which can use these
files. Fortunately, the manual was also kept in a RUNOFF style format (i.e. plain text with markup). I never found
a RUNOFF style formatting program that could process these files either (the files have the extension \texttt{.sg} which
doesn't seem to be known to the Internet for text processing purposes). However, it was possible to write a
formatter in Python from scratch to get a PDF version of this essential manual.

\newpara
The first usable version of \textbf{GPLOT} (0.1, late 2013) 
could not output EPSF files as such, but used a
limited character set format that could be trivially translated to EPSF. V0.2 (2022) improved Tektronix 401x support. V0.58
(developed between late 2022 and early 2023) added significant -- if idiosyncratic -- facilities for function evaluation 
and other programmability features, as well as SVG output. It also exposed a lot more of \textbf{DIMFILM's} capabilities and directly
generated "true" EPS files. Most of what can be done with \textbf{DIMFILM} using a specially
written Fortran program can now be done from \textbf{GPLOT}. V0.59 fixed some bugs in parameter substitution. V0.6 (July 2025)
tidied up a few things and supported building on ``Unix-like'' systems as well as NOS. This version also uses the NOS MODIFY --
Git inter-operability tools so that the source can be managed equally well on NOS or with Git, with changes made on one system
being automatically reflected in the other. This version also automatically generates minor variations of the source code
needed for building on COS (\textbf{DIMFILM} library only) and Unix, using a single, NOS compatible,
code base. Many further changes and additions were made
between July and October 2025 -- many of them a direct result of trying to use it (e.g. to produce the figures
in this manual). The additions include the ``higher level drawing'' functions.
Ports to VAX/VMS and NOS/VE (the latter must be considered experimental at present) were done in November and December 2025.
Smooth curve drawing features based on cubic B\'{e}zier curves were added in early January 2026.

\newpara
The current version (0.90) may be genuinely useful (I find it to be).
I consider this version to be complete in a sense, in that it may have taken the basic structure of the program as
far as it reasonably can be taken. I am not currently planning on doing further work on \textbf{GPLOT} (beyond bug fixes if
necessary), but perhaps others will add to it.

\section{Cheat sheet or Reference card}
Very often, a reminder of \textbf{GPLOT} commands and operators is all that is needed when
using it. Such a cheat sheet (or, more formally, reference card) follows. This is
also available as a separate PDF file for easy printing.

\clearpage
\begin{figure}
  \centering
  \includegraphics[angle=90,scale=1.5]{../../temp/cht1001.eps}
\end{figure}


\clearpage
\begin{figure}
  \centering
  \includegraphics[angle=90,scale=1.5]{../../temp/cht2001.eps}
  \label{fig:cht2001}
\end{figure}


\clearpage
\begin{figure}
  \centering
  \includegraphics[width=\maxwidth]{../../temp/fin001.eps}
  \caption{THE END}
  \label{fig:fin001}
\end{figure}


\end{document}

