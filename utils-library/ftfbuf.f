C======================================================================
C FTFBUF - LIBRARY FOR SYSTEM LEVEL RECORD AND Z-RECORD I/O.
C THIS IMPLEMENTS SOMETHING SIMILAR TO UNIX FOPEN/FREAD/FWRITE/FCLOSE
C USABLE FOR BINARY AND LINES OF CHARACTERS FILES. THE BASIC UNIT OF
C INFORMATION IS A 60 BIT WORD RATHER THAN A BYTE, THOUGH.
C
C A SYSTEM LEVEL RECORD (SLR) IS A CONTIGUOUS GROUP OF WORDS IN A
C SEQUENTIAL FILE ENDING IN AN END-OF-RECORD (EOR), END-OF-FILE (EOF)
C OR END-OF-INFORMATION (EOI) MARK (A "SHORT PRU" ON DISK FILES). IT
C IS NOT INTERPRETED BY THE SYSTEM - IT IS JUST "RAW DATA", MUCH LIKE
C A UNIX FILE. EACH READ OR WRITE TRANSFERS AN ENTIRE SYSTEM LEVEL
C RECORD STARTING AT THE CURRENT FILE POSITION TO A MEMORY BUFFER.
C
C OTHER "RECORD TYPES" ARE IMPLEMENTED BY STRUCTURING THE DATA INSIDE
C A SYSTEM LEVEL RECORD. THIS IS NORMALLY DONE BY THE CRM (CYBER
C RECORD MANAGER), BUT VARIABLE LENGTH LINES OF CHARACTERS ARE
C REPRESENTED BY Z-RECORDS WHICH END WITH A ZERO 12-BIT "BYTE" IN THE
C LOWEST ORDER BITS OF A WORD. THIS IS VERY WIDELY USED AND IS SIMPLE
C ENOUGH TO IMPLEMENT DIRECTLY HERE.
C
C FUNCTION SUMMARY:
C   INTEGER HANDLE = FBOPEN( UNITNO, FNAME, MODE )
C     OPEN FILE FNAME ON LUN UNITNO. MODE = 'RW+O' (OVERWRITE)
C   INTEGER STATUS = FBCLOSE( HANDLE, WEOR )
C     CLOSE FILE. IF WEOR WRITE EOF MARK ON FILE OPEN FOR WRITE
C   INTEGER STATUS = FBREAD( HANDLE, WBUF, MAXWRDS, NREAD )
C     READ SLR INTO WBUF(MAXWRDS). WORDS READ IN NREAD, RET 0 ON EOF.
C   INTEGER STATUS = FBWRITE( HANDLE, WBUF, NWRDS )
C     WRITE SLR OF NWRDS WORDS FROM WBUF(NWRDS)
C
C   INTEGER STATUS = FBZGET( WA, NWA, CWA, CA, NCH )
C     GET Z-RECORD FROM SLR WA(NWA) STARTING AT WORD CWA. PUT
C     CHARACTERS IN CHAR*160 CA AND RETURN COUNT IN NCH. RETURN
C     UPDATED CWA AS STATUS (-VE ON ERROR).
C   INTEGER STATUS = FBZPUT( WA, NWA, CWA, CA, NCH )
C     PUT Z-RECORD (TEXT LINE) INTO SLR WA(NWA) STARTING AT WORD CWA.
C     GET CHARACTERS FROM CHAR*160 CA(1:NCH). RETURN UPDATED CWA.
C
C   SUBROUTINE FBERR( STATUS, ERRMSG )
C     CONVERT A -VE ERROR CODE STATUS TO AN ERROR MESSAGE IN CHAR*80
C     BUFFER ERRMSG.
C
C NICK GLAZZARD 2021.
C======================================================================
C
      SUBROUTINE FBERR(IERR,ERRMSG)
C--------------------------------------------------------(FILE I/O)----
C DECODE AN FB FUNCTION ERROR CODE TO AN ERROR MESSAGE.
C IERR IS THE ERROR CODE AND ERRMSG RECEIVES THE MESSAGE.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER IERR
      CHARACTER*80 ERRMSG
C----
      INTEGER NMSGS
      PARAMETER( NMSGS=12 )
      CHARACTER*80 MSGS(0:NMSGS)
C
      MSGS(0) = 'SUCCESS.'
      MSGS(1) = 'FILE OPEN MODE MUST NOT HAVE BOTH R AND W.'
      MSGS(2) = 'FAILED TO OPEN FILE FOR READ.'
      MSGS(3) = 'FAILED TO CREATE FILE FOR WRITE.'
      MSGS(4) = 'FILE HANDLE IS NOT OPEN.'
      MSGS(5) = 'FAILED TO CLOSE FILE OPEN FOR READ.'
      MSGS(6) = 'FAILED TO WRITE END OF FILE MARKER.'
      MSGS(7) = 'FAILED TO CLOSE FILE OPEN FOR WRITE.'
      MSGS(8) = 'PARITY ERROR ON BUFFER READ!'
      MSGS(9) = 'FILE MUST BE OPEN FOR READ.'
      MSGS(10) = 'FBZGET: NO MORE Z RECORDS IN SLR. (SUCCESS).'
      MSGS(11) = 'FBZPUT: SLR BUFFER IS FULL. LINE TRUNCATED.'
      MSGS(12) = 'FBZPUT: NO ROOM TO PAD STRING ENDING IN COLON.'
C
      IERR = ABS(IERR)
      IF( IERR .GT. NMSGS )THEN
         ERRMSG = 'INVALID ERROR CODE. INTERNAL ERROR.'
      ELSE
         ERRMSG = MSGS(IERR)
      ENDIF
      RETURN
      END
C
      INTEGER FUNCTION FBOPEN(UNITNO,FNAME,MODE)
C---------------------------------------------------------(FILE I/O)---
C OPEN OR CREATE A FILE FOR BUFFERED I/O. THIS IS A GOOD APPROXIMATION
C TO RAW BINARY FILE ACCESS. UNITNO IS THE FORTRAN UNIT NUMBER TO USE,
C FNAME IS THE FILE NAME, AND MODE MAY CONTAIN ANY OF THE FOLLOWING
C LETTERS:
C        * R OPEN FOR READ (NO W MUST BE PRESENT)
C        * W CREATE OR OPEN FOR WRITE (NO R MUST BE PRESENT)
C        * + THE FILE WILL NOT BE REWOUND (WRITES APPEND)
C        * O OVERWRITE ANY EXISTING FILE OF SAME NAME
C RETURN A "FILE HANDLE" OR A NEGATIVE ERROR CODE.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER UNITNO
      CHARACTER*7 FNAME
      CHARACTER*(*) MODE
C----
      CHARACTER*7 CSTAT
      INTEGER HANDLE, I
      LOGICAL DOREAD, DOWRITE, DONTREW, DOOVER
C
      DOREAD = DOWRITE = DOOVER = DONTREW = .FALSE.
      DO 5 I=1,LEN(MODE)
         DOREAD = MODE(I:I) .EQ. 'R'
         DOWRITE = MODE(I:I) .EQ. 'W'
         DONTREW = MODE(I:I) .EQ. '+'
         DOOVER = MODE(I:I) .EQ. 'O'
 5    CONTINUE
C
      IF( DOREAD .AND. DOWRITE )THEN
         FBOPEN = -1
         RETURN
      ENDIF
C
      IF( DOREAD )THEN
         OPEN(UNIT=UNITNO,FILE=FNAME,ACCESS='SEQUENTIAL',STATUS='OLD',
     +        FORM='BUFFERED',ERR=999)
         REWIND(UNIT=UNITNO)
         HANDLE = UNITNO
         GOTO 1
 999     HANDLE = -2
      ELSE
         IF( DOOVER )THEN
            CSTAT = 'UNKNOWN'
         ELSE
            CSTAT = 'NEW'
         ENDIF
         OPEN(UNIT=UNITNO,FILE=FNAME,ACCESS='SEQUENTIAL',STATUS=CSTAT,
     +        FORM='BUFFERED',ERR=998)
         HANDLE = 1000 + UNITNO
         GOTO 1
 998     HANDLE = -3
      ENDIF
C
 1    CONTINUE
C
      IF( .NOT. DONTREW )THEN
         REWIND(UNIT=UNITNO)
      ENDIF
C
      FBOPEN = HANDLE
      RETURN
      END
C
      INTEGER FUNCTION FBCLOSE(HANDLE,WEOF)
C------------------------------------------------------(FILE I/O)------
C CLOSE THE BUFFERED FILE OPEN ON HANDLE.
C IF WEOF, WRITE AN EXPLICIT EOF MARK ON A FILE OPEN FOR WRITING.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER HANDLE
      LOGICAL WEOF
C----
      INTEGER RORW, IUNIT, STATUS
C
C---- IS THE FILE OPEN?
C
      STATUS = 0
      IF( HANDLE .LT. 0 )THEN
         STATUS = -4
      ENDIF
C
C---- CLOSE AS APPROPRIATE FOR READ OR WRITE.
C
      RORW = HANDLE / 1000
      IUNIT = HANDLE - 1000 * RORW
      IF( RORW .EQ. 0 )THEN
         CLOSE(UNIT=IUNIT,ERR=999)
         GOTO 1
 999     STATUS = -5
      ELSE
         IF( WEOF )ENDFILE(UNIT=IUNIT,ERR=998)
         CLOSE(UNIT=IUNIT,ERR=997)
         GOTO 1
 998     STATUS = -6
         GOTO 1
 997     STATUS = -7
      ENDIF
C
 1    CONTINUE
      FBCLOSE = STATUS
      RETURN
      END
C
      INTEGER FUNCTION FBREAD(HANDLE,WBUF,MAXWRDS,NREAD)
C---------------------------------------------------------(FILE I/O)---
C READ A SYSTEM LOGICAL RECORD OF MAXIMUM SIZE MAXWRDS WORDS, INTO
C WBUF FROM THE FILE OPEN ON HANDLE. IF NO ERROR, RETURN ZERO ON EOF
C OR THE NUMBER OF WORDS READ OR A NEGATIVE ERROR CODE.
C ALWAYS RETURN THE NUMBER OF WORDS READ IN NREAD.
C N.B. IT MIGHT BE POSSIBLE TO BOTH READ DATA AND REACH EOF. NOT SURE.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER HANDLE, MAXWRDS, NREAD
      BOOLEAN WBUF(MAXWRDS)
C----
      INTEGER RORW, IUNIT, STATUS
      INTEGER LENGTH
      REAL UNIT
C
      IF( HANDLE .LT. 0 )THEN
         FBREAD = -4
         RETURN
      ENDIF
      RORW = HANDLE / 1000
      IUNIT = HANDLE - 1000 * RORW
      NREAD = 0
      IF( RORW .NE. 0 )THEN
         FBREAD = -9
         RETURN
      ENDIF
C
      BUFFER IN (IUNIT,0) (WBUF(1),WBUF(MAXWRDS))
      STATUS = UNIT(IUNIT,WBUF(1),WBUF(MAXWRDS))
C
C---- -1 IS OK, 0 IS EOF, 1 IS PARITY ERROR!
C
      IF( STATUS .EQ. 1 )THEN
         FBREAD = -8
         RETURN
      ENDIF
C
C---- GET THE NUMBER OF WORDS READ.
C
      NREAD = LENGTH(IUNIT)
      IF( STATUS .LT. 0 )THEN
         FBREAD = NREAD
      ELSE
         FBREAD = 0
      ENDIF
      RETURN
      END
C
      INTEGER FUNCTION FBWRITE(HANDLE,WBUF,NWRDS)
C------------------------------------------------------(FILE I/O)------
C WRITE A SYSTEM LOGICAL RECORD OF SIZE NWRDS FROM WBUF TO THE FILE
C OPEN ON HANDLE. RETURN 0 IF OK ELSE A NEGATIVE ERROR CODE.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER HANDLE, NWRDS
      BOOLEAN WBUF(NWRDS)
C----
      INTEGER IUNIT, RORW, STATUS
      REAL UNIT
C
      IF( HANDLE .LT. 0 )THEN
         FBWRITE = -4
         RETURN
      ENDIF
      RORW = HANDLE / 1000
      IUNIT = HANDLE - 1000 * RORW
C
      BUFFER OUT (IUNIT,0) (WBUF(1),WBUF(NWRDS))
      STATUS = UNIT(IUNIT,WBUF(1),WBUF(NWRDS))
      IF( STATUS .NE. -1 )THEN
         FBWRITE = -10
      ELSE
         FBWRITE = 0
      ENDIF
      RETURN
      END
C
      INTEGER FUNCTION FBGTC(W,IC)
C------------------------------------------------------(FILE I/O)------
C GET CHARACTER IC FROM WORD W. CHARACTERS ARE PACKED INTO WORDS
C IN ORDER (59). 1 . 2 . 3 . 4 . 5 . 6 . 7 . 8 . 9 . 10 .(0)
C 10 6 BIT CHARACTERS TO A 60 BIT WORD. END OF LINE IS SIGNALLED BY
C BITS (0..11) ALL ZERO (CHARACTERS 9 AND 10).
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      BOOLEAN W
      INTEGER IC
C----
      INTEGER JC
C
      JC = MAX(1, MIN(IC, 10))
      FBGTC = AND( SHIFT( W, -6*(10-JC) ), O"77" )
      RETURN
      END
C
      INTEGER FUNCTION FBZGET(WA,NWA,CWA,CA,NCH)
C-------------------------------------------------------(FILE I/O)-----
C GET A Z RECORD FROM A SYSTEM LOGICAL RECORD.
C EXTRACT A LINE OF UP TO 160 CHARACTERS FROM THE
C RECORD IN WA, LENGTH NWA, CURRENTLY AT CWA WORD. RETURN THE
C CHARACTERS IN CA AND COUNT IN NCH. RETURN THE UPDATED
C CWA OR A NEGATIVE CODE IF NO MORE Z RECORDS EXIST IN WA.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER NWA, CWA, NCH
      BOOLEAN WA(NWA)
      CHARACTER*160 CA
C----
      BOOLEAN CW
      LOGICAL RECTRM
      INTEGER IC, ITC, IWA, NC
      INTEGER FBGTC
      INTEGER ICV
C
C---- 6 BIT DISPLAY CODE CODES TO DISPLAY CODE CHARACTERS.
C
      CHARACTER*1 DSPCHR(0:63)
      DATA DSPCHR/':','A','B','C','D','E','F','G','H','I','J','K','L',
     +'M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1',
     +'2','3','4','5','6','7','8','9','+','-','*','/','(',')','$','=',
     +' ',',','.','#','[',']','%','"','_','!','&','''','?','<','>','@',
     +'\','^',';'/
C
C---- SET TOTAL OUTPUT CHARACTERS, ITC, TO 0. SET INITIAL INPUT WORD
C---- INDEX, IWA.
C
      ITC = 0
      IWA = CWA + 1
C
C---- RETURN HERE AFTER PROCESSING THE CURRENT WORD. CHECK WE HAVE
C---- NOT RUN OUT OF WORDS.
C
 7    CONTINUE
      IF( IWA .GT. NWA )THEN
         NCH = ITC
         FBZGET = -10
         RETURN
      ENDIF
C
C---- GET THE CURRENT WORD INTO CW. SEE IF THIS CONTAINS THE END OF
C---- A Z RECORD (LOWEST 12 BITS ZERO).
C
      CW = WA(IWA)
      RECTRM = (AND(CW,O"7777") .EQ. 0)
C
C---- FIND THE NUMBER OF VALID CHARACTERS IN THE CURRENT WORD.
C---- NEEDS TO BE DONE REGARDLESS OF RECTRM OR NOT.
C
      NC = 0
      DO 1 IC=10,1,-1
         IF( FBGTC(CW,IC) .NE. 0 )THEN
            NC = IC
            GOTO 2
         ENDIF
 1    CONTINUE
 2    CONTINUE
C
C---- IF NO VALID CHARACTERS IN WORD, END OF LINE. RETURN.
C
      IF( NC .EQ. 0 )THEN
         NCH = ITC
         FBZGET = IWA
         RETURN
      ENDIF
C
C---- COPY NC CHARACTERS FROM WORD TO CHARACTER ARRAY.
C---- TRUNCATE LINES LONGER THAN 160 CHARACTERS.
C
      DO 3 IC=1,NC
         IF( ITC .LT. 160 )THEN
            ITC = ITC + 1
            CA(ITC:ITC) = DSPCHR( FBGTC(CW,IC) )
         ENDIF
 3    CONTINUE
C
C---- IF THIS WAS THE LAST WORD OF A Z RECORD, RETURN.
C
      IF( RECTRM )THEN
         NCH = ITC
         FBZGET = IWA
         RETURN
      ENDIF
C
C---- GO AND GET ANOTHER WORD TO PROCESS.
C
      IWA = IWA + 1
      GOTO 7
      END
C
      SUBROUTINE FBPTC(W,IC,CH)
C------------------------------------------------------(FILE I/O)------
C INSERT A SINGLE CHARACTER, CH, AS THE IC-TH CHARACTER OF WORD W. IC
C SHOULD BE 1..10.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      BOOLEAN W
      INTEGER IC
      CHARACTER*1 CH
C----
      BOOLEAN CB
      INTEGER JC, DCCODE(0:63)
C
C---- ICHAR() OUTPUT (ASCII CODE - 32 BIZARRELY) TO DISPLAY CODE NUMBER
C
      DATA DCCODE/45,54,52,48,43,51,55,56,41,42,39,37,46,38,47,40,27,
     + 28,29,30,31,32,33,34,35,36,0,63,58,44,59,57,60,1,
     + 2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
     + 19,20,21,22,23,24,25,26,49,61,50,62,53/
C
      CB = DCCODE( ICHAR(CH) )
      JC = MAX(1, MIN(10, IC))
      W = OR( W, SHIFT( CB, 6*(10-JC) ) )
      RETURN
      END
C
      INTEGER FUNCTION FBZPUT(WA,NWA,CWA,CA,NCH)
C-------------------------------------------------------(FILE I/O)-----
C INSERT NCH CHARACTERS FROM CA INTO WORD BUFFER WA (SIZE NWA) WHERE
C THE FIRST WORD TO BE USED IS CWA. RETURN AN UPDATED CWA OR A
C NEGATIVE ERROR CODE. THIS REPRESENTS A LINE OF CHARACTERS AS A Z
C RECORD INSIDE A SYSTEM LOGICAL RECORD, WA.
C NCH MAY BE 0, IN WHICH CASE, WRITE AN EMPTY LINE.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER NWA, CWA, NCH
      BOOLEAN WA(NWA)
      CHARACTER*160 CA
C----
      INTEGER IC, IWC, IWA
      BOOLEAN CW
C
C---- IF THE FIRST WORD TO BE USED FOR THIS LINE IS OFF THE END OF WA,
C---- GIVE UP NOW.
C
      IWA = CWA + 1
      IF( IWA .GT. NWA )THEN
         FBZPUT = -4
         RETURN
      ENDIF
C
C---- IF THE STRING ENDS WITH A COLON OR PERCENT CHARACTER, ADD A
C---- SPACE TO THE END OF THE STRING, IF POSSIBLE.
C
      IF( NCH .GT. 0 )THEN
         IF( (CA(NCH:NCH) .EQ. '%') .OR. (CA(NCH:NCH) .EQ. ':') )THEN
            IF( NCH .EQ. 160 )THEN
               FBZPUT = -12
               RETURN
            ENDIF
            NCH = NCH + 1
            CA(NCH:NCH) = ' '
         ENDIF
      ENDIF
C
C---- INSERT CHARACTERS INTO WA STARTING AT CWA.
C
      IWC = 0
      CW = 0
      DO 1 IC = 1,NCH
         IWC = IWC + 1
C
C---- IF THE WORD IS FULL, TRY TO GET ANOTHER WORD.
C
         IF( IWC .GT. 10 )THEN
            WA(IWA) = CW
            IWA = IWA + 1
            IF( IWA .GT. NWA )THEN
               FBZPUT = -11
               RETURN
            ENDIF
            CW = 0
            IWC = 1
         ENDIF
C
C---- INSERT CHARACTER AT IWC IN CW
C
         CALL FBPTC(CW,IWC,CA(IC:IC))
 1    CONTINUE
C
C---- ALL CHARACTERS HAVE BEEN INSERTED. IF THERE ARE 9 CHARACTERS IN
C---- THE LAST WORD, THERE IS NOT ENOUGH ROOM FOR THE TERMINATING
C---- ZERO 12 BIT BYTE. INSERT A SPACE THEN ADD AN ALL ZERO WORD.
C
      IF( IWC .GT. 8 )THEN
         IF( IWC .EQ. 9 )THEN
            IWC = IWC + 1
            CALL FBPTC(CW,IWC,' ')
         ENDIF
         WA(IWA) = CW
         CW = 0
         IWA = IWA + 1
         IF( IWA .GT. NWA )THEN
            FBZPUT = -11
            RETURN
         ENDIF
         WA(IWA) = CW
      ELSE
         WA(IWA) = CW
      ENDIF
C
C---- RETURN THE INDEX OF THE LAST USED WORD IN WA.
C
      FBZPUT = IWA
      RETURN
      END
