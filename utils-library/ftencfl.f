      PROGRAM ENCFL(OUTPUT=/256,TAPE6=OUTPUT)
C======================================================================
C ENCODE A FILE AS HEXADECIMAL ASCII CODES IN CODED FORMAT.
C======================================================================
      IMPLICIT CHARACTER*1 (A-Z)
      INTEGER KNORMAL, KASCII, KBINARY, KMXRECL, KPRIMOD, KAT, KCARAT
      INTEGER KGUESS, TCARAT, NGUESS, MAXWRDS
      PARAMETER( KNORMAL=1, KASCII=2, KBINARY=3, KGUESS=4 )
      PARAMETER( KMXRECL=256, KPRIMOD=53791, MAXWRDS=16384 )
      PARAMETER( KAT=64, KCARAT=94, TCARAT=2, NGUESS=3 )
C
      CHARACTER*(KMXRECL) INLINE
      CHARACTER*80 KEY, VALUE
      CHARACTER*65 ROUTE
      CHARACTER*7 INFLNM, OUTFLNM, CFTYPE, USN
      CHARACTER*4 UJN, JSN
      CHARACTER*10 SDATE, STIME
      INTEGER NIN, NOUT, NTOTAL, NCHKS, IFTYPE, IPREFIX, ISTAT, I
      INTEGER ICFLEN, IASC, IWORD, ISHFL, FIN, NWR, CWA, NWF, NREC, NC
      INTEGER INFLEN, IFWA, IWOFF, FBCLOSE, GUESSTY, IGETUSR, IGETUI
      INTEGER LNBC, FBOPEN, FBREAD, FBZGET, STATUS, ATEOF, FILESZ
      BOOLEAN BDATA(36), BINVAL, WBUFGET, WBUF(1)
      LOGICAL DEBUG, SKIP
C
C---- INITIALIZE.
C
      DEBUG = .FALSE.
      INFLNM = ' '
      OUTFLNM = ' '
      CFTYPE = 'GUESS'
      ROUTE = ' '
      CWA = 0
C
C---- PARSE COMMAND LINE ARGUMENTS.
C
 1    CONTINUE
         CALL GETPARM( KEY, VALUE, ISTAT )
         IF( ISTAT .EQ. -1 )GOTO 2
            IF( ISTAT .EQ. 1 )THEN
               WRITE(6,700)KEY(1:LNBC(KEY,1,1))
 700           FORMAT(1X,'UNKNOWN KEY ONLY OPTION ',A)
            ELSE
               IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'I' )THEN
                  INFLNM = VALUE(1:MIN(7,LNBC(VALUE,1,1)))
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'O' )THEN
                  OUTFLNM = VALUE(1:MIN(7,LNBC(VALUE,1,1)))
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'T' )THEN
                  CFTYPE = VALUE(1:MIN(7,LNBC(VALUE,1,1)))
               ELSE IF( KEY(1:LNBC(KEY,1,1)) .EQ. 'R' )THEN
                  ROUTE = VALUE(1:MIN(65,LNBC(VALUE,1,1)))
               ELSE
                  WRITE(6,701)KEY(1:LNBC(KEY,1,1))
 701              FORMAT(1X,'UNKNOWN KEY-VAL OPTION ',A)
               ENDIF
            ENDIF
         GOTO 1
 2    CONTINUE
C
C---- CHECK WE HAVE THE REQUIRED ARGUMENTS.
C
      IF( INFLNM(1:1) .EQ. ' ' )GOTO 934
      IF( OUTFLNM(1:1) .EQ. ' ' )GOTO 935
      IF( DEBUG )THEN
         WRITE(6,*)'IN=',INFLNM,' OUT=',OUTFLNM
      ENDIF
C
C---- CHECK CFTYPE IS VALID.
C
      ICFLEN = LNBC(CFTYPE,1,1)
      IF(CFTYPE(1:ICFLEN) .EQ. 'NORMAL')THEN
         IFTYPE = KNORMAL
      ELSE IF(CFTYPE(1:ICFLEN) .EQ. 'ASCII')THEN
         IFTYPE = KASCII
      ELSE IF(CFTYPE(1:ICFLEN) .EQ. 'BINARY')THEN
         IFTYPE = KBINARY
      ELSE IF(CFTYPE(1:ICFLEN) .EQ. 'GUESS')THEN
         IFTYPE = KGUESS
      ELSE
         STOP 'UNKNOWN INPUT FILE TYPE SPECIFIED.'
      ENDIF
C
C---- FIND THE SIZE OF THE INPUT FILE IN WORDS.
C
      INFLEN = LNBC(INFLNM,1,1)
      NWF = FILESZ(INFLNM(1:INFLEN),.TRUE.)
      IF( NWF .EQ. 0 )GOTO 99
      WRITE(6,111)NWF
 111  FORMAT(1X,'INPUT FILE SIZE IS ',I6,' WORDS.')
C
C---- ALLOCATE BUFFER TO HOLD A SYSTEM LOGICAL RECORD (SLR)
C
      CALL CMMALF(NWF+2,0,0,IFWA)
      IWOFF = IFWA - LOCF(WBUF(1)) + 1
C
C---- IF GUESSING THE FILE TYPE, TRY TO DO THAT NOW.
C
      IF( IFTYPE .EQ. KGUESS )THEN
         IFTYPE = GUESSTY(INFLNM(1:INFLEN),CFTYPE)
         IF( IFTYPE .LT. 0 )GOTO 9977
      ENDIF
C
C---- OPEN THE INPUT FILE.
C
      FIN = FBOPEN(8,INFLNM(1:INFLEN),'R')
      IF( FIN .LT. 0 )GOTO 99
C
C---- READ A SYSTEM LOGICAL RECORD (SLR).
C
      STATUS = ATEOF = FBREAD(8,WBUF(IWOFF),NWF,NWR)
      IF( STATUS .LT. 0 )GOTO 999
      IF( ATEOF .EQ. 0 )GOTO 20
C
C---- CREATE THE OUTPUT FILE.
C
      OPEN(UNIT=9,FILE=OUTFLNM(1:LNBC(OUTFLNM,1,1)),
     + STATUS='NEW',ERR=97)
C
C---- GET INFORMATION FOR A HEADER LINE AND WRITE IT.
C
      CALL CUHASH(IGETUI(),UJN)
      NC = IGETUSR(USN)
      CALL CGETJN(JSN)
      CALL GETDATE(SDATE)
      CALL GETTIME(STIME)
      WRITE(9,166)INFLNM(1:INFLEN),USN(1:NC),UJN,JSN,SDATE,STIME
 166  FORMAT('*ENCFL NOS2 ',A7,1X,A7,1X,A4,1X,A4,1X,A10,1X,A10,14X,'Z')
C
C---- IF THERE IS A ROUTE OPTION, ADD INFO FOR THAT TO THE HEADER.
C
      IF( ROUTE .NE. ' ' )THEN
      WRITE(9,165)ROUTE
 165  FORMAT('*ROUTE ',A65,1X,'Z')
      ENDIF
C
C---- WRITE THE FILE TYPE AND SIZE IN WORDS.
C
      WRITE(9,177,ERR=998)CFTYPE,NWF
 177  FORMAT(A7,1X,'W',1X,I6,57X,'Z')
 100  FORMAT(A)
C
C---- INITIALIZE VARIABLE COMMON TO BINARY AND CODED.
C
      NOUT = 0
      NTOTAL = 0
      NCHKS = 0
      NREC = 0
C
C---- PROCESS BINARY INPUT FILES IN THIS SECTION.
C---- INITIALIZE BINARY SPECIFIC VARIABLES.
C
      IF( IFTYPE .EQ. KBINARY )THEN
         IWORD = 0
         ISHFL = 0
         BINVAL = 0
C
C---- START OF BYTE PROCESSING LOOP. BYTES COME FROM WORD PAIR (15 BTS)
C---- IF THE SHIFT AMOUNT IS 0, MOVE TO A NEW WORD. IF SLR USED UP
C---- THEN FINISH.
C
 801     CONTINUE
            IF( ISHFL .EQ. 0 )THEN
               IWORD = IWORD + 1
               IF( IWORD .GT. NWR )GOTO 20
            ENDIF
C
C---- INCREMENT OUTPUT BYTES INDEX. GET RIGHT SHIFTED INPUT WORD.
C
            NOUT = NOUT + 1
            BINVAL = SHIFT( WBUFGET(WBUF(IWOFF),IWORD), -ISHFL )
C
C---- SHIFT OF 56 INDICATES BYTE SPANS TOP OF WORD 1 AND BOT WORD 2
C
            IF( ISHFL .EQ. 56 )THEN
               BDATA(NOUT) = AND( BINVAL, O"17" )
               IWORD = IWORD + 1
               IF( IWORD .GT. NWR )GOTO 220
               BINVAL = WBUFGET(WBUF(IWOFF),IWORD)
               BDATA(NOUT) = OR( BDATA(NOUT),
     +            SHIFT( AND( BINVAL, O"17" ), 4 ) )
               ISHFL = 4
C
C---- SHIFT OF 52 INDICATES TOP BYTE OF WORD 2.
C
            ELSE IF( ISHFL .EQ. 52 )THEN
               BDATA(NOUT) = AND( BINVAL, O"377" )
               ISHFL = 0
C
C---- OTHERWISE, 8 BIT BYTE WITH NO SPECIAL CASE.
C
            ELSE
               BDATA(NOUT) = AND( BINVAL, O"377" )
               ISHFL = ISHFL + 8
            ENDIF
C
C---- MAINTAIN CHECKSUM AND TOTAL BYTE COUNT.
C
 220        CONTINUE
            NCHKS = NCHKS + BDATA(NOUT)
            IF( NCHKS .GT. KPRIMOD )NCHKS = NCHKS - KPRIMOD
            NTOTAL = NTOTAL + 1
C
C---- IF OUTPUT BYTE BUFFER IS FULL, WRITE IT TO CODED OUTPUT FILE.
C
            IF( NOUT .EQ. 36 )THEN
               WRITE(9,720,ERR=998)BDATA,NOUT
               NOUT = 0
            ENDIF
            IF( IWORD .GT. NWR )GOTO 20
C
C---- PROCESS NEXT BYTE.
C
            GOTO 801
C
C---- END OF BINARY PROCESSING SECTION.
C
         ENDIF
C
C---- PROCESS CODED INPUT FILES IN THIS SECTION.
C---- LOOP READING INPUT LINES UNTIL EOF
C
      IPREFIX = 0
 10   CONTINUE
         CWA = FBZGET(WBUF(IWOFF),NWR,CWA,INLINE,NIN)
C
C---- IF ALL WORDS USED IN THIS SLR, WRITE EOR, TRY TO READ NEXT SLR.
C
         IF( CWA .LT. 0 )THEN
            STATUS = ATEOF = FBREAD(8,WBUF(IWOFF),NWF,NWR)
            IF( STATUS .LT. 0 )GOTO 999
C
C---- INSERT EOR MARKER HERE, IF NOT AT EOF.
C
            IF( ATEOF .EQ. 0 )GOTO 20
            NREC = NREC + 1
            NOUT = NOUT + 1
            BDATA(NOUT) = 255
            NCHKS = NCHKS + BDATA(NOUT)
            IF( NCHKS .GT. KPRIMOD )NCHKS = NCHKS - KPRIMOD
C---- IF THE BDATA ARRAY IS FULL, CONVERT TO HEX CHARS AND WRITE TO
C---- THE OUTPUT FILE.
            IF( NOUT .EQ. 36 )THEN
               WRITE(9,720,ERR=998)BDATA,NOUT
               NTOTAL = NTOTAL + NOUT
               NOUT = 0
            ENDIF
C
C---- HANDLE EOF CONDITIONS.
C
            IF( ATEOF .EQ. 0 )GOTO 20
            CWA = 0
            CWA = FBZGET(WBUF(IWOFF),NWR,CWA,INLINE,NIN)
            IF( CWA .EQ. 0 )GOTO 20
         ENDIF
         IF( DEBUG )THEN
            WRITE(6,100)INLINE(1:NIN)
         ENDIF
         NIN = LNBC(INLINE(1:NIN),1,0)
C
C---- IF NIN IS 0, OUTPUT A NEWLINE CODE FOR THIS EMPTY RECORD.
C
         IF( NIN .EQ. 0 )THEN
            IF( DEBUG )THEN
               WRITE(6,*)'NEWLINE ONLY'
            ENDIF
            NOUT = NOUT + 1
            BDATA(NOUT) = 10
            NCHKS = NCHKS + BDATA(NOUT)
            IF( NCHKS .GT. KPRIMOD )NCHKS = NCHKS - KPRIMOD
C---- IF THE BDATA ARRAY IS FULL, CONVERT TO HEX CHARS AND WRITE TO
C---- THE OUTPUT FILE.
            IF( NOUT .EQ. 36 )THEN
               WRITE(9,720,ERR=998)BDATA,NOUT
               NTOTAL = NTOTAL + NOUT
               NOUT = 0
            ENDIF
C
C---- NOT AN EMPTY RECORD (NIN .NE. 0). PROCESS EACH LINE CHARACTER.
C
         ELSE
C
C---- CONVERT EACH CHARACTER TO AN ASCII CODE.
C
            IPREFIX = 0
            DO 3 I=1,NIN
               SKIP = .FALSE.
               IASC = ICHAR(INLINE(I:I)) + 32
C---- IF IN ASCII MODE, SEE IF THIS IS A PREFIX CHARACTER.
C---- BUT ONLY IF THERE IS NO ACTIVE PREFIX CHARACTER.
               IF( (IFTYPE .EQ. KASCII) .AND. (IPREFIX .EQ. 0) )THEN
                  IF( IASC .EQ. KAT )THEN
                     IPREFIX = KAT
                  ELSE IF( IASC .EQ. KCARAT )THEN
                     IPREFIX = KCARAT
                  ENDIF
                  SKIP = (IPREFIX .NE. 0)
                  IF( DEBUG )THEN
                     WRITE(6,*)'IPRX=',IPREFIX,' C=',INLINE(I:I),SKIP
                  ENDIF
               ENDIF
C---- IF SKIP IS .FALSE. ADD A CODE TO THE END OF THE OUTPUT BYTES.
C---- THE CODE MAY NEED TO BE MODIFIED DEPENDING ON ANY PREFIX.
               IF( .NOT. SKIP )THEN
                  IF( IPREFIX .EQ. KCARAT )THEN
                     IF( IASC .GE. 65 )THEN
                        IASC = IASC + 32
                     ELSE IF( IASC .GE. 48 .AND. IASC .LE. 51 )THEN
                        IASC = IASC + 75
                     ENDIF
                  ELSE IF( IPREFIX .EQ. KAT )THEN
C---- (AT)A -> (AT)
                     IF( IASC .EQ. 65 )THEN
                        IASC = 64
C---- (AT)B -> (CARAT)
                     ELSE IF( IASC .EQ. 66 )THEN
                        IASC = 94
C---- (AT)D -> (COLON)
                     ELSE IF( IASC .EQ. 68 )THEN
                        IASC = 58
C---- (AT)G -> (BACK-QUOTE)
                     ELSE IF( IASC .EQ. 71 )THEN
                        IASC = 96
                     ENDIF
                  ENDIF
C---- ADD THIS ASCII CODE TO BDATA ARRAY.
                  NOUT = NOUT + 1
                  BDATA(NOUT) = IASC
                  NCHKS = NCHKS + BDATA(NOUT)
                  IF( NCHKS .GT. KPRIMOD )NCHKS = NCHKS - KPRIMOD
C---- IF THE BDATA ARRAY IS FULL, CONVERT TO HEX CHARS AND WRITE TO
C---- THE OUTPUT FILE.
               IF( NOUT .EQ. 36 )THEN
                  WRITE(9,720,ERR=998)BDATA,NOUT
                  NTOTAL = NTOTAL + NOUT
 720              FORMAT(36(Z2),I2.2)
                  NOUT = 0
               ENDIF
C---- RESET THE PREFIX AS A CHARACTER HAS BEEN OUTPUT.
               IPREFIX = 0
            ENDIF
 3       CONTINUE
C
C---- END OF INPUT LINE. INSERT A NEWLINE CODE.
C
         NOUT = NOUT + 1
         BDATA(NOUT) = 10
         NCHKS = NCHKS + BDATA(NOUT)
         IF( NCHKS .GT. KPRIMOD )NCHKS = NCHKS - KPRIMOD
C---- IF THE BDATA ARRAY IS FULL, CONVERT TO HEX CHARS AND WRITE
            IF( NOUT .EQ. 36 )THEN
               WRITE(9,720,ERR=998)BDATA,NOUT
               NTOTAL = NTOTAL +  NOUT
               NOUT = 0
            ENDIF
            IPREFIX = 0
C---- END OF NOT EMPTY RECORD CASE.
         ENDIF
C
C---- GET THE NEXT INPUT LINE.
C
         GOTO 10
C
C---- END OF INPUT FILE. BINARY FILE PROCESSING JUMPS HERE ON EOF.
C
 20   CONTINUE
C
C---- IF ANY DATA IS OUTSTANDING, FLUSH IT OUT.
C
      IF( NOUT .GT. 0 )THEN
         DO 200 I=NOUT+1,36
            BDATA(I) = 0
 200     CONTINUE
         WRITE(9,720,ERR=998)BDATA,NOUT
         IF( IFTYPE .NE. KBINARY )NTOTAL = NTOTAL + NOUT
      ENDIF
C
C---- WRITE A TERMINATING LINE OF ALL ZEROS WITH 0 VALID COUNT.
C
      DO 201 I=1,36
         BDATA(I) = 0
 201  CONTINUE
      NOUT = 0
      WRITE(9,720,ERR=998)BDATA,NOUT
C
C---- WRITE THE CHECKSUM AND BYTE COUNT.
C
      WRITE(9,300,ERR=997)NCHKS,NTOTAL
 300  FORMAT(I5,1X,I10)
C
C---- CLOSE THE INPUT AND OUTPUT FILES.
C
      STATUS = FBCLOSE(FIN,.FALSE.)
      IF( STATUS .LT. 0 )GOTO 996
      CLOSE(UNIT=9,ERR=995)
C
C---- NORMAL END.
C
      WRITE(6,666)NTOTAL,NREC
 666  FORMAT(1X,'OUTPUT ',I6,' 8 BIT BYTES AND ',I3,' EORS.')
      STOP 'NORMAL COMPLETION'
C
C---- ERROR STOPS
C
 934  STOP 'INPUT FILE NAME IS REQUIRED.'
 935  STOP 'OUTPUT FILE NAME IS REQUIRED.'
 99   STOP 'CANNOT OPEN INPUT FILE.'
 81   STOP 'CANNOT REWIND INPUT FILE.'
 97   STOP 'CANNOT CREATE OUTPUT FILE.'
 899  STOP 'CANNOT READ BINARY FILE WORD PAIR.'
 999  STOP 'CANNOT READ INPUT LINE.'
 998  STOP 'CANNOT WRITE OUTPUT LINE.'
 997  STOP 'CANNOT WRITE CHECK SUM AND COUNT.'
 996  STOP 'CANNOT CLOSE INPUT FILE.'
 995  STOP 'CANNOT CLOSE OUTPUT FILE.'
 9977 STOP 'FILE TYPE GUESSING FAILED.'
      END
C
      BOOLEAN FUNCTION WBUFGET(WBUF,IWORD)
C----------------------------------------------------------------------
C GET WBUF(IWORD) FOR A DYNAMICALLY ALLOCATED ARRAY, WBUF. THIS MUST
C BE ACCESSED RELATIVE TO AN OFFSET (TO WHERE CMMALF HAS ACTUALLY
C ALLOCATED SPACE). THUS, WBUF(IWOFF) IS PASSED TO THIS FUNCTION. THIS
C IS A WORKAROUND FOR FORTRAN NOT HAVING A POINTER VARIABLE TYPE.
C----------------------------------------------------------------------
      BOOLEAN WBUF(1)
      INTEGER IWORD
      WBUFGET = WBUF(IWORD)
      RETURN
      END
C
      INTEGER FUNCTION GUESSTY(CFLNAM,CFTYPE)
C----------------------------------------------------------------------
C TRY TO GUESS THE TYPE OF A FILE FROM THE CONTENTS OF ITS START.
C RETURNS 'NORMAL' OR 'ASCII' IN CFTYPE. RETURN THE FILE TYPE CODE OR
C -1 ON ERROR.
C----------------------------------------------------------------------
      IMPLICIT CHARACTER*1 (A-Z)
      CHARACTER*(*) CFLNAM
      CHARACTER*6 CFTYPE
C
      INTEGER KNORMAL, KASCII, KBINARY, DCARAT, TCARAT, DCOLON, TCOLON
      PARAMETER( KNORMAL=1, KASCII=2, KBINARY=3 )
      PARAMETER( DCARAT=62, TCARAT=2, DCOLON=0, TCOLON=1000000 )
      INTEGER FIN, STATUS, I, J, NCARAT, NWR, ICH, NCOLON
      BOOLEAN WBUF(51)
      INTEGER FBOPEN, FBREAD, FBGTC, FBCLOSE
C
C---- SET THE DEFAULT TYPE.
C
      GUESSTY = KNORMAL
      CFTYPE = 'NORMAL'
C
C---- OPEN THE INPUT FILE.
C
      FIN = FBOPEN(8,CFLNAM,'R')
      IF( FIN .LT. 0 )GOTO 999
C
C---- READ A SYSTEM LOGICAL RECORD (SLR).
C
      STATUS = FBREAD(8,WBUF,50,NWR)
      IF( STATUS .LE. 0 )GOTO 999
C
C---- LOOK FOR CARATS + COLONS IN THE FIRST 500 CHARACTERS OF THE FILE.
C
      NCARAT = 0
      NCOLON = 0
      DO 1 I=1,NWR
         DO 2 J=1,10
            ICH = FBGTC(WBUF(I),J)
            IF( ICH .EQ. DCARAT )THEN
               NCARAT = NCARAT + 1
            ENDIF
            IF( ICH .EQ. DCOLON )THEN
               NCOLON = NCOLON + 1
            ENDIF
 2       CONTINUE
 1    CONTINUE
C
C---- TRY TO INFER THE FILE TYPE FROM THE COUNTS OF COLONS AND CARATS.
C---- UNFORTUNATELY, THIS DOES NOT WORK CORRECTLY FOR BINARY FILES
C
      IF( NCOLON .GT. TCOLON )THEN
C------- IF MORE THAN TCOLON COLONS WERE FOUND, ASSUME IT IS BINARY
         CFTYPE = 'BINARY'
         GUESSTY = KBINARY
      ELSE IF( NCARAT .GT. TCARAT )THEN
C------- IF MORE THAN TCARAT CARATS WERE FOUND, ASSUME IT IS 6/12
         CFTYPE = 'ASCII'
         GUESSTY = KASCII
      ELSE
C------- OTHERWISE, DEFAULT TO NORMAL TEXT FILE.
         CFTYPE = 'NORMAL'
         GUESSTY = KNORMAL
      ENDIF
      WRITE(6,403)CFTYPE
 403  FORMAT(1X,'GUESSED FILE TYPE TO BE ',A)
C
C---- CLOSE THE FILE AND RETURN.
C
      STATUS = FBCLOSE(FIN,.FALSE.)
      IF( STATUS .LT. 0 )GOTO 999
      RETURN
 999  CONTINUE
      GUESSTY = -1
      RETURN
      END
